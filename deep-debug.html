<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Manifold Deep Debug</title>
		<style>
			body {
				font-family: system-ui, sans-serif;
				max-width: 1000px;
				margin: 0 auto;
				padding: 2rem;
			}
			.debug {
				background: #f8f9fa;
				padding: 1rem;
				margin: 1rem 0;
				border-radius: 4px;
			}
			.error {
				background: #f8d7da;
				border: 1px solid #dc3545;
			}
			.success {
				background: #d4edda;
				border: 1px solid #28a745;
			}
			pre {
				background: white;
				padding: 1rem;
				border-radius: 4px;
				overflow: auto;
			}
		</style>
	</head>
	<body>
		<h1>ðŸ”¬ Manifold Deep Debug</h1>

		<div class="debug">
			<h3>Step 1: Expression Parser Test</h3>
			<button id="test-parser">Test Expression Parser</button>
			<pre id="parser-output"></pre>
		</div>

		<div class="debug">
			<h3>Step 2: State Resolution Test</h3>
			<button id="test-states">Test State Resolution</button>
			<pre id="state-output"></pre>
		</div>

		<div class="debug">
			<h3>Step 3: Manual Text Node Processing</h3>
			<div id="text-target">
				Hello ${user.name}, you are ${user.age} years old!
			</div>
			<button id="test-text">Process Text Node</button>
			<pre id="text-output"></pre>
		</div>

		<div class="debug">
			<h3>Step 4: Manual Attribute Processing</h3>
			<div
				id="attr-target"
				data-if="${counter > 5}"
				style="display: none"
			>
				Counter is greater than 5
			</div>
			<button id="test-attr">Process Attributes</button>
			<pre id="attr-output"></pre>
		</div>

		<script type="module">
			import { state, register, derived } from "./src/index.js";
			import _evaluateExpression from "./src/expression-parser.js";

			// Set up global states
			window.user = state({ name: "John Doe", age: 25 });
			window.counter = state(3);

			function log(elementId, message) {
				const element = document.getElementById(elementId);
				element.textContent += message + "\n";
				console.log(message);
			}

			function clearLog(elementId) {
				document.getElementById(elementId).textContent = "";
			}

			// Test 1: Expression Parser
			document.getElementById("test-parser").onclick = () => {
				clearLog("parser-output");

				const expressions = [
					"user.name",
					"user.age",
					"counter > 5",
					'user.name + " is " + user.age',
					"counter",
				];

				expressions.forEach((expr) => {
					log("parser-output", `\n--- Testing: "${expr}" ---`);
					try {
						const result = _evaluateExpression(expr);
						log("parser-output", `âœ“ Parsed successfully`);
						log("parser-output", `  Function: ${typeof result.fn}`);
						log(
							"parser-output",
							`  State refs: ${result._stateRefs?.size || 0}`
						);

						if (result._stateRefs) {
							for (const ref of result._stateRefs) {
								log(
									"parser-output",
									`    - ${ref._name}: ${typeof ref._state}`
								);
								log(
									"parser-output",
									`      State value: ${ref._state?.value}`
								);
							}
						}

						// Test execution with global context
						const testContext = {
							user: window.user.value,
							counter: window.counter.value,
						};
						const evalResult = result.fn(testContext);
						log(
							"parser-output",
							`  Evaluation result: ${evalResult}`
						);
					} catch (error) {
						log("parser-output", `âœ— Error: ${error.message}`);
					}
				});
			};

			// Test 2: State Resolution
			document.getElementById("test-states").onclick = () => {
				clearLog("state-output");

				log("state-output", "--- Global State Objects ---");
				log("state-output", `window.user: ${window.user}`);
				log(
					"state-output",
					`window.user.value: ${JSON.stringify(window.user.value)}`
				);
				log("state-output", `window.counter: ${window.counter}`);
				log(
					"state-output",
					`window.counter.value: ${window.counter.value}`
				);

				log(
					"state-output",
					"\n--- Testing Expression with Real States ---"
				);
				const expr = "user.name";
				const result = _evaluateExpression(expr);

				// Create props object like the registry would
				const props = {};
				if (result._stateRefs) {
					for (const ref of result._stateRefs) {
						log(
							"state-output",
							`Setting props.${ref._name} = ${ref._state}`
						);
						props[ref._name] = ref._state;
					}
				}

				log(
					"state-output",
					`Props object: ${JSON.stringify(Object.keys(props))}`
				);

				try {
					const evalResult = result.fn(props);
					log("state-output", `Evaluation with props: ${evalResult}`);

					// Test with actual state values
					const valueProps = {};
					for (const [key, state] of Object.entries(props)) {
						valueProps[key] = state.value;
					}
					const evalResult2 = result.fn(valueProps);
					log(
						"state-output",
						`Evaluation with values: ${evalResult2}`
					);
				} catch (error) {
					log("state-output", `Error: ${error.message}`);
				}
			};

			// Test 3: Manual Text Node Processing
			document.getElementById("test-text").onclick = () => {
				clearLog("text-output");

				const target = document.getElementById("text-target");
				const textNode = target.firstChild;

				log("text-output", `Original text: "${textNode.textContent}"`);

				// Manual implementation of processTextNode logic
				const originalText = textNode.textContent || "";
				const expressions = [];

				log("text-output", "\n--- Finding expressions ---");
				let match;
				const regex = /\$\{[^}]*\}/g;
				while ((match = regex.exec(originalText))) {
					log("text-output", `Found: "${match[0]}"`);
					const expr = match[0].slice(2, -1);
					log("text-output", `  Expression: "${expr}"`);

					try {
						const { _stateRefs, fn } = _evaluateExpression(expr);
						log(
							"text-output",
							`  Parsed successfully, ${
								_stateRefs?.size || 0
							} state refs`
						);

						// Create props
						const props = {};
						if (_stateRefs) {
							for (const ref of _stateRefs) {
								props[ref._name] = ref._state;
								log(
									"text-output",
									`    Added props.${ref._name}`
								);
							}
						}

						if (fn) {
							const computedState = derived(() => fn(props));
							expressions.push([match[0], computedState]);
							log("text-output", `  Created computed state`);

							// Set up effect
							computedState.effect((value) => {
								log("text-output", `  Effect fired: ${value}`);
								let newText = originalText;
								for (const [matchStr, state] of expressions) {
									newText = newText.replaceAll(
										matchStr,
										`${state.value}`
									);
								}
								textNode.textContent = newText;
								log(
									"text-output",
									`  Updated text: "${newText}"`
								);
							});
						}
					} catch (error) {
						log("text-output", `  Error: ${error.message}`);
					}
				}

				log("text-output", `\nFound ${expressions.length} expressions`);

				// Test state update
				setTimeout(() => {
					log("text-output", "\n--- Testing state update ---");
					window.user.value = {
						...window.user.value,
						name: "Updated Name",
					};
				}, 1000);
			};

			// Test 4: Manual Attribute Processing
			document.getElementById("test-attr").onclick = () => {
				clearLog("attr-output");

				const target = document.getElementById("attr-target");
				log("attr-output", `Element: ${target.tagName}`);
				log("attr-output", `Attributes: ${target.attributes.length}`);

				for (const attr of target.attributes) {
					log(
						"attr-output",
						`\n--- Attribute: ${attr.name} = "${attr.value}" ---`
					);

					if (attr.value.startsWith("${")) {
						const expr = attr.value.slice(2, -1);
						log("attr-output", `Expression: "${expr}"`);

						try {
							const { _stateRefs, fn } =
								_evaluateExpression(expr);
							log(
								"attr-output",
								`Parsed: ${_stateRefs?.size || 0} state refs`
							);

							if (fn) {
								const props = {};
								if (_stateRefs) {
									for (const ref of _stateRefs) {
										props[ref._name] = ref._state;
									}
								}

								if (attr.name === "data-if") {
									log(
										"attr-output",
										"Processing as conditional..."
									);
									const showState = derived(() => fn(props));

									showState.effect((value) => {
										log(
											"attr-output",
											`Conditional result: ${value}`
										);
										target.style.display = value
											? ""
											: "none";
									});

									// Test updates
									setTimeout(() => {
										log(
											"attr-output",
											"\n--- Testing counter updates ---"
										);
										[2, 8, 4, 10].forEach((val, i) => {
											setTimeout(() => {
												window.counter.value = val;
												log(
													"attr-output",
													`Set counter to: ${val}`
												);
											}, i * 500);
										});
									}, 1000);
								}
							}
						} catch (error) {
							log("attr-output", `Error: ${error.message}`);
						}
					}
				}
			};

			console.log("ðŸ”¬ Deep debug initialized");
		</script>
	</body>
</html>
