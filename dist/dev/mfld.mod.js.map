{"version":3,"file":"mfld.mod.js","sources":["../../src/updates.js","../../src/store.js","../../src/util.js","../../src/fetch.js","../../src/bindsync.js","../../src/conditionals.js","../../src/registrar.js","../../src/index.module.js"],"sourcesContent":["/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = false;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n/** @type {HTMLElement | null} */\r\nlet spacer;\r\nlet spacerHeight = \"\";\r\n\r\n// Polyfill requestAnimationFrame\r\nlet tick = globalThis?.requestAnimationFrame || ((fn)=> setTimeout(fn, 0));\r\n\r\nexport function _addToNextTickQueue(fn) {\r\n    if(fn) _nextTickQueue.push(fn);\r\n}\r\n\r\n/** @export @param {(DomWorkOrder | Function)} update */\r\nexport function _scheduleUpdate(update) {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = true;\r\n        tick(_runUpdates);\r\n    }\r\n}\r\n\r\nfunction _addSpacer(inEl, wrapper, wrapperHeight, replaceWholeObject = false, ops) {\r\n    if(!ops.trans?.smartTransition ?? true) return;\r\n    //Conserve parent size\r\n    spacer = document.createElement(\"div\");\r\n    \r\n    let { paddingTop, paddingBottom } = wrapper instanceof Element ? window.getComputedStyle(wrapper) : { paddingTop: 0, paddingBottom: 0 };\r\n    spacerHeight = spacer.style.height = `calc(${(Math.abs(wrapperHeight - (inEl?.clientHeight || 0)))}px - ${paddingTop} - ${paddingBottom})`;\r\n\r\n    wrapper?.after(spacer);\r\n}\r\n\r\nfunction _adjustSizing(inEl, ops) {\r\n    if(!ops.trans?.smartTransition ?? true) return;\r\n    let dur = (ops?.trans?.dur?.[0] || ops?.trans?.dur || 600)/2\r\n\r\n    _scheduleUpdate(()=> {\r\n        spacer?.remove();\r\n        inEl?.animate?.([\r\n            { height: spacerHeight },\r\n            { height: `${inEl.clientHeight || 0}px` }\r\n        ], dur);\r\n    });\r\n}\r\n\r\nfunction _runUpdates() {\r\n    cancelAnimationFrame = false;\r\n    \r\n    /**\r\n    * @type {DomWorkOrder[]}\r\n    */\r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") (/** @type {Function} */ order)();\r\n        else {\r\n            let wrapperHeight = order.out ? order.out.clientHeight : 0;\r\n\r\n            // Prepend\r\n            if(order.relation == \"prepend\") {\r\n                _addSpacer?.(order.in, order.out, wrapperHeight, false, order.ops);\r\n\r\n                //Prepend\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) order.out?.prepend(order.in);\r\n                    _adjustSizing?.(order.in, order.ops);\r\n                });\r\n            }\r\n            // Remove old children\r\n            else {\r\n                if([\"swapinner\", \"swapouter\"].includes(order.relation)) {\r\n                    //Remove old children before appending (if swapping children)\r\n                    let container = /** @type {HTMLElement}*/(order.out?.cloneNode(true));\r\n\r\n                    order.out?.after(container);\r\n                    let getDimensionsAfterUpdate = order.relation == \"swapinner\" ? true : false;\r\n\r\n                    if(order.relation == \"swapinner\") {\r\n                        container.style.border = \"none\";\r\n                        order.out.replaceChildren();\r\n                    }\r\n\r\n                    // Transition old children out\r\n                    _applyTransition(container, \"out\", order.ops, undefined, order.out, getDimensionsAfterUpdate);\r\n                }\r\n\r\n                _addSpacer?.(order.in, order.out, wrapperHeight, false, order.ops);\r\n\r\n                // Transition incoming element and append\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) {\r\n                        if(order.relation == \"swapouter\") order.out?.replaceWith(order.in)\r\n                        else order.out?.appendChild(order.in);\r\n                    }\r\n                    _adjustSizing?.(order.in, order.ops);\r\n                });\r\n            }\r\n\r\n            order.done?.(order.in);\r\n        }\r\n    }\r\n\r\n    //Handle queued nextTick functions\r\n    for(let fn of _nextTickQueue) fn();\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @param {HTMLElement} [refElement]\r\n * @param {boolean} [getDimensionsAfterUpdate]\r\n * @returns \r\n */\r\nfunction _applyTransition(el, dir, ops, fn, refElement, getDimensionsAfterUpdate = false) {\r\n    //Handle text nodes\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        let text = el.textContent;\r\n        let newNode = document?.createElement(\"div\");\r\n        newNode.textContent = text;\r\n        el.replaceWith(newNode);\r\n        el = newNode;\r\n    }\r\n\r\n    if(el) {\r\n        let dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n\r\n        //Initiate transition\r\n        let transClass = ops?.trans?.class || \"mf-trans\";\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        //Wait to apply class\r\n        if(dir == \"out\") {\r\n            // Set dimensions\r\n            if(!refElement) refElement = el;\r\n            if(!refElement) return;\r\n            let dimensions = {};\r\n            if((ops.trans?.smartTransition ?? true) && getDimensionsAfterUpdate == false) {\r\n                let style = getComputedStyle(refElement);\r\n                dimensions.w = `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`;\r\n                dimensions.left = `calc(${refElement.getBoundingClientRect().left}px + ${window.scrollX}px)`;\r\n                dimensions.top = `calc(${refElement.getBoundingClientRect().top}px + ${window.scrollY}px)`;\r\n            }\r\n\r\n            _scheduleUpdate(()=> {\r\n                if(ops.trans?.smartTransition ?? true) {\r\n                    if(getDimensionsAfterUpdate && refElement) {\r\n                        let style = getComputedStyle(refElement);\r\n                        dimensions.w = `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`;\r\n                        dimensions.left = `calc(${refElement.getBoundingClientRect().left}px + ${window.scrollX}px)`;\r\n                        dimensions.top = `calc(${refElement.getBoundingClientRect().top}px + ${window.scrollY}px)`;\r\n                    }\r\n                    \r\n                    el.style.position = \"fixed\";\r\n                    el.style.width = dimensions.w;\r\n                    el.style.left = dimensions.left;\r\n                    el.style.top = dimensions.top;\r\n                    el.style.margin = \"0\";\r\n                }\r\n\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                el.classList?.add(\"out\");\r\n            })\r\n        }\r\n        //If dir == in\r\n        else {\r\n            el?.classList?.add(\"in\");\r\n            if(dur) el.style.transitionDuration = `${dur}ms`;\r\n            fn?.();\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    setTimeout(()=> _scheduleUpdate(()=> el?.classList?.remove(dir)), 0);\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                //Wrapup\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}","/** \n * @template T\n * @typedef {import(\"./index.module.js\").UpdaterFunction<T>} UpdaterFunction \n */\n/** \n * @template T\n * @typedef {import(\"./index.module.js\").StoreOptions<T>} StoreOptions \n */\n\nimport { _scheduleUpdate } from \"./updates.js\";\n\n/**\n * @callback SubFunction\n * @param {any} value\n * @param {string} [ref]\n * @returns {void}\n */\n\n/**\n * @param {any} input \n * @returns {any}\n */\nfunction _hashAny(input) {\n    if(!input) return 0;\n    if(typeof input == 'number') return input;\n    if(input === true) return 1;\n\n    if(input instanceof Map) return _hashAny(Array.from(input.entries()));\n    else if(input instanceof Set) return _hashAny(Array.from(input));\n\n    let hash = 0;\n    for(let char of new TextEncoder().encode(\n        typeof input == 'string' ? input : input?.toString() || \"\"\n    )) \n        hash = ((hash << 5) - hash) + char;\n    return hash;\n}\n\n//Static\n/** @type {Map<string, Store<any>>} */ if(!globalThis.MfSt) globalThis.MfSt = new Map();\n/** @type {Map<string, Function>} */ if(!globalThis.MfFn) globalThis.MfFn = new Map();\n\n/**\n * @template T\n */\nexport class Store {\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\n    /** @type {string | undefined} */ _storedHash = undefined;\n    /** @type {Set<Store<any>>} */ _upstreamStores = new Set();\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    constructor(name, ops) {\n        return this._modify(name, ops);        \n    }\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    _modify(name, ops) {\n        this.name = name;\n        // @ts-ignore\n        MfSt.set(name, this);\n        \n        (ops?.upstream?.map(s=> {\n            let S = _store(s);\n            this._upstreamStores.add(S);\n            S._downstreamStores.add(this);\n            return S;\n        }) || []);\n\n        this.value = ops?.value;\n        this._updater = ops?.updater;\n        this._auto_update();\n        return this;\n    }\n\n    /**\n     * @param {(T)=> void} sub\n     * @param {string | undefined} [ref]\n     * @param {boolean} [immediate]\n     */\n    sub(sub, ref, immediate = true) {\n        this._subscriptions.set(ref || String(Date.now() + Math.random()), sub);\n        if(immediate) sub?.(this.value);\n    }\n\n    //Update (manual or automated -- cascades downstream on batch updates)\n    /**\n    * @template T\n    * @param {T | ((T)=> T | Promise<T>)} value\n    */\n    async update(value) {\n        return new Promise(async (resolve)=> {\n            //Apply new value   \n            let newValue = (typeof value == \"function\" ? /** @type {Function} */(await value)?.(this.value) : value);\n            let newHash = _hashAny(newValue);\n            \n            if(newHash !== this._storedHash) {\n                this.value = newValue;\n                this._storedHash = newHash;\n\n                // Add this store to the work order\n                for(let ds of this._downstreamStores) await ds._auto_update();\n\n                // Wait for next animation frame to return the value\n                _scheduleUpdate(()=> {\n                    for(let [ref, sub] of this?._subscriptions || []) sub?.(this.value, ref);\n                    resolve(this.value);\n                });\n            }\n            else resolve(this.value);\n        });\n    }\n\n    async _auto_update() {\n        let newVal = await this._updater?.(\n            Array.from(this._upstreamStores)?.map(S => S?.value) || [], \n            /** @type {T} */(this?.value)\n        );\n\n        await this.update(newVal === undefined ? this.value : newVal);\n    }\n}\n\n/**\n * STORE STATIC METHODS\n */\n/**\n * @template T\n * @param {string} name - The name of the store\n * @param {StoreOptions<T> | T} [ops] - Options to update the store\n * @returns {Store<T>}\n */\nexport function _store(name, ops) {\n    // @ts-ignore\n    let found_store = MfSt.get(name);\n    if(ops) {\n        if(found_store) {\n            return found_store._modify(name, ops);\n        }\n        return new Store(name, ops);\n    }\n    return found_store || new Store(name, /** @type {StoreOptions<T>}*/(ops));\n}","export let ATTR_PREFIX = \"mf\";\r\nexport let _inputNestSplitRx = /[\\.\\[\\]\\?]{1,}/g;\r\n\r\n/**\r\n * Get or set nested store values\r\n * @param {any} obj \r\n * @param {(string | number)[]} path \r\n * @param {any} [newval] \r\n * @returns \r\n */\r\nexport function _nestedValue(obj, path, newval) {\r\n    let ptr = obj;\r\n\r\n    for(let key of path) {\r\n        //Dynamically letruct object if it doesn't exist\r\n        if(ptr == undefined) ptr = typeof key == \"number\" ? [] : {};\r\n\r\n        //Set or get value\r\n        if(newval == undefined || path[path.length - 1] !== key) ptr = ptr instanceof Map ? ptr?.get(key) : ptr?.[key];\r\n        else ptr instanceof Map ? ptr.set(key, newval) : ptr[key] = newval;\r\n    }\r\n\r\n    return ptr;\r\n}\r\n\r\nexport function _getStorePathFromKey(s) {\r\n    let [storeName, ...path] = (s)?.split(_inputNestSplitRx);\r\n    return [storeName, path?.map(sp=> !isNaN(parseInt(sp)) ? parseInt(sp) : sp).filter(sp=> sp) || []];\r\n}\r\n\r\nfunction _getOverride(name, el, ops, parse = true, def = \"{}\", as) {\r\n    let override = el.dataset[`${ATTR_PREFIX}${name}`];\r\n    if(!override) return undefined;\r\n    if(name == \"overrides\") return ops.profiles?.[override || \"\"]?.fetch || JSON.parse(override || \"{}\");\r\n    if(parse) return JSON.parse(override || def);\r\n    if(as == \"num\") return parseInt(override) || undefined;\r\n    if(as == \"bool\") return override == \"true\" ? true : override == \"false\" ? false : undefined;\r\n    return override;\r\n}\r\n\r\n/**\r\n * Get or set nested store values\r\n * @param {import(\"./index.module\").MfldOps} ops\r\n * @param {HTMLElement} el\r\n * @returns {import(\"./index.module\").MfldOps}\r\n */\r\nexport function _getOpOverrides(ops, el) {\r\n    let overrides = _getOverride(\"overrides\", el, ops);\r\n\r\n    let newops = {\r\n        profiles: ops.profiles,\r\n        fetch: {\r\n            ...ops.fetch,\r\n            ...{\r\n                responseType: _getOverride(\"responsetype\", el, ops, false) || ops.fetch?.responseType\r\n            },\r\n            ...(overrides?.fetch || {}),\r\n            ...(_getOverride(\"fetch\", el, ops) || {}),\r\n        },\r\n        trans: {\r\n            ...ops.trans,\r\n            ...{\r\n                dur: _getOverride(\"transdur\", el, ops, true, \"[]\", \"num\") || ops.trans?.dur,\r\n                swap: _getOverride(\"transswap\", el, ops, false, \"\", \"num\") || ops.trans?.swap,\r\n                class: _getOverride(\"transclass\", el, ops, false) || ops.trans?.class,\r\n                smartTransition: _getOverride(\"transsmart\", el, ops, false, undefined, \"bool\") || ops.trans?.smartTransition,\r\n            },\r\n            ...(overrides?.trans || {}),\r\n            ...(_getOverride(\"trans\", el, ops) || {}),\r\n        },\r\n    }\r\n\r\n    return newops;\r\n}\r\n\r\n/**\r\n * @param {{el: HTMLElement, datakey: string} | string} data \r\n * @returns {{ storeList?: string[], func?: Function, storeName?: string}}\r\n */\r\nexport function _parseFunction(data) {\r\n    let condition = \"\";\r\n    let storeName = \"\";\r\n    if(typeof data === \"string\") {\r\n        condition = data;\r\n        storeName = data;\r\n    }\r\n    else {\r\n        condition = data?.el?.dataset?.[data?.datakey] || \"\";\r\n        storeName = condition;\r\n\r\n        if(!condition && data?.el?.dataset?.[`${ATTR_PREFIX}else`] !== undefined) {\r\n            condition = \"return true\";\r\n            storeName = `ELSE:${data?.el?.dataset?.[data?.datakey] || \"\"}`;\r\n        }\r\n    }\r\n\r\n    if(!condition) return {};\r\n\r\n    let [stores, fn] = condition?.split(\"=>\")?.map(s=> s.trim()) || [\"\", \"\"];\r\n    if(!fn) {\r\n        fn = stores.slice();\r\n        stores = \"\";\r\n    }\r\n\r\n    // Set up function to evaluate store values\r\n    let storeList = stores?.split(\",\")?.map(s=> s.replace(/[()]/g, \"\").trim());\r\n    // @ts-ignore\r\n    let func = globalThis[fn] || MfFn?.get(fn);\r\n\r\n    // If function is not found, try to create it; account for implicit returns\r\n    if(!func) {\r\n        if(!fn.match(/^\\s{0,}\\{/) && !fn.includes(\"return\")) fn = fn.replace(/^\\s{0,}/, \"return \");\r\n        func = new Function(...storeList, fn);\r\n    }\r\n\r\n    return { storeList, func, storeName };\r\n}","import { _getOpOverrides, _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _registerSubs } from \"./registrar.js\";\r\nimport { _store } from \"./store.js\";\r\n\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {string} trigger \r\n * @param {MfldOps} _ops\r\n * @param {string} href\r\n * @param {string} [method] \r\n * @param {string[]} [input]\r\n * @param {Function} [processFunc]\r\n */\r\nexport function _handleFetch(el, trigger, _ops, href, method, input, processFunc) {\r\n    /**\r\n     * @param {Event} [e]\r\n     */\r\n    let ev = async e=> {  \r\n        e?.preventDefault();\r\n        e?.stopPropagation();\r\n\r\n        let fetchOps = _getOpOverrides(_ops, el);\r\n\r\n        // Set from target element if relevant; fall back to \"get\"\r\n        if(!method) method = /** @type {any}*/(e?.target)?.method || \"get\";\r\n\r\n        // if([\"click\", \"submit\"].includes(trigger) || [\"A\", \"FORM\"].includes(target?.nodeName)) {\r\n        //     history.pushState(\r\n        //         {fetchData, elId: el.id}, \r\n        //         \"\", \r\n        //         target?.href || target?.action || \"\"\r\n        //     );\r\n        // }\r\n    \r\n        //Make sure we're allowed to fetch\r\n        let externalPermissions = fetchOps?.fetch?.externals?.find(allowed=> href?.startsWith(allowed.domain)) || \r\n            !href.match(/^https?:\\/\\//) || href.includes(location.origin) ? {\r\n                scripts: true,\r\n                styles: true,\r\n        } : undefined;\r\n\r\n        // Parse input\r\n        let body = input;\r\n        if(processFunc) {\r\n            body = processFunc?.(\r\n                ...(input?.map(s=> _store(s).value) || [])\r\n            )\r\n        }\r\n\r\n        //Fetch data\r\n        let data = await fetch(href, {\r\n            ...(fetchOps?.fetch?.request || {}),\r\n            headers: {\r\n                ...fetchOps?.fetch?.request?.headers,\r\n                \"Manifold-App-Fetch\": \"true\",\r\n            },\r\n            method,\r\n            body: typeof body == \"string\" ? body : JSON.stringify(body),\r\n        })\r\n        .catch(error=> {\r\n            fetchOps?.fetch?.err?.(error) || console.error(\"FETCH ERROR\", error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fetchOps?.fetch?.onCode?.(code, data) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let resp = await data?.[fetchOps?.fetch?.responseType || \"text\"]();\r\n\r\n        // Handle resolutions\r\n        for(let instruction of [\"append\", \"prepend\", \"swapinner\", \"swapouter\"]) {\r\n            let ds = el.dataset[`${ATTR_PREFIX}${instruction}`];\r\n            if(ds === undefined) continue;\r\n            let [selector, toReplace] = ds?.split(\"->\").map(s=> s.trim()) || [];\r\n\r\n            //Extract content and schedule a DOM update\r\n            let fullMarkup = (new DOMParser())?.parseFromString?.(resp, 'text/html');\r\n            if(fullMarkup) {\r\n                _scheduleUpdate({\r\n                    in: /** @type {HTMLElement} */ (fullMarkup.querySelector(selector || \"body\")),\r\n                    out: /** @type {HTMLElement} */ (toReplace ? document.querySelector(toReplace) : el),\r\n                    relation: /** @type {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"}*/(instruction),\r\n                    ops: fetchOps,\r\n                    done: (el)=> {\r\n                        _registerSubs(el)\r\n                    },\r\n                })\r\n            }\r\n        }\r\n\r\n        let resolveTxt = el.dataset?.[`${ATTR_PREFIX}resolve`];\r\n        let resolveFunc = _parseFunction(resolveTxt || \"\")?.func;\r\n        resolveFunc?.(resp);\r\n\r\n            // //Clear existing scripts/styles\r\n            // for(let s of [pageScripts, pageStyles]) {\r\n            //     let elements = s.get(fullMarkup) || [];\r\n            //     elements.forEach(el => el.remove());\r\n            //     s.set(fullMarkup, []);\r\n            // }\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n    }\r\n\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}","import { _store } from \"./store\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _getStorePathFromKey, _inputNestSplitRx, _nestedValue, ATTR_PREFIX } from \"./util\";\r\n\r\nexport function _handleBindSync(el, input, output, trigger, mode, processFunc) {\r\n    /**\r\n     * HANDLE MF-BIND - inputs are stores, output is element property\r\n     */\r\n    if(mode == `${ATTR_PREFIX}bind`) {\r\n        let stores = input.map(_getStorePathFromKey);\r\n        let domSubscription = ()=> {\r\n            _scheduleUpdate(()=> {\r\n                let storeValues = stores.map(s=> _nestedValue(_store(s[0])?.value, s[1]));\r\n                let val = processFunc?.(...storeValues, el) ?? storeValues[0];\r\n                if(output && val !== undefined) {\r\n                    let parts = output.split(\":\");\r\n                    if(parts.length > 1) {\r\n                        switch(parts[0]) {\r\n                            case \"style\": el.style[parts[1]] = val; break;\r\n                            case \"attr\": el.setAttribute(parts[1], val); break;\r\n                            default: el[output] = val;\r\n                        }\r\n                    }\r\n                    else el[output] = val;\r\n                }\r\n\r\n                //Make sure to update dependent stores on value update\r\n                el.dispatchEvent(new CustomEvent(trigger));\r\n            });\r\n        }\r\n    \r\n        //Add subscription - run whenever store updates\r\n        for(let s of stores) _store(s?.[0]|| \"\")?.sub(domSubscription);\r\n    }\r\n\r\n    else {\r\n        /**\r\n         * HANDLE MF-SYNC - inputs are element properties, output is a store\r\n         */\r\n        if(mode == `${ATTR_PREFIX}sync`) {\r\n            let [storeName, path] = _getStorePathFromKey(output || \"\");\r\n            let ev = ()=> {\r\n                let propValues = input.map(prop=> {\r\n                    prop = prop.trim();\r\n                    let parts = prop.split(\":\");\r\n                    if(parts.length > 1) {\r\n                        switch(parts[0]) {\r\n                            case \"style\": return el.style[prop] ?? undefined;\r\n                            case \"attr\": return el.getAttribute(prop) ?? undefined;\r\n                            default: return el[prop] ?? undefined;\r\n                        }\r\n                    }\r\n                    else return el[prop] ?? undefined;\r\n                });\r\n\r\n                let value = processFunc?.(...propValues) ?? propValues[0];\r\n                \r\n                if(storeName && value !== undefined) {\r\n                    _store(storeName)?.update?.(curVal=> {\r\n                        return path?.length ? _nestedValue(curVal, path, value) : value\r\n                    });\r\n                }\r\n            }\r\n            if(trigger == \"$mount\") ev();\r\n            else el.addEventListener(trigger, ev);\r\n        }\r\n    }\r\n}","import { _registerSubs } from \"./registrar\";\nimport { _store } from \"./store\";\nimport { _scheduleUpdate } from \"./updates\";\nimport { _getOpOverrides, _getStorePathFromKey, _parseFunction, ATTR_PREFIX } from \"./util\";\n\n/**\n * @param {HTMLElement} el\n * @param {HTMLElement} rootElement \n * @returns {HTMLElement}\n */\nfunction _ensureTemplate(el, rootElement) {\n    // Make sure this is a template\n    if(el.tagName != \"TEMPLATE\") {\n        let newEl = document.createElement(\"template\");\n        newEl.innerHTML = el.innerHTML;                \n        for(let attr of el.attributes) {\n            newEl.setAttribute(attr.name, attr.value);\n        }\n        el.replaceWith(newEl);\n\n        // If not, it's default content\n        rootElement.innerHTML = el.innerHTML;\n        return newEl;\n    }\n    return el;\n}\n\n/**\n * @param {any} obj \n * @param {(value: any, index: any, array?: any)=> void} cb \n */\nfunction _iterable(obj, cb) {\n    if(obj instanceof Map) for(const [key, value] of obj.entries()) cb(key, value);\n    else {\n        try { \n            let arr = Array.from(obj);\n            if(arr?.length) arr.forEach(cb);\n            else for(let key in obj) cb(key, obj[key]);\n        }\n        catch(e) { console.error(`${obj} is not iterable`); }\n    }\n  }\n\n/**\n * @param {string} [storeName] \n * @param {string[]} [storeList] \n * @param {any[]} [conditionChain] \n * @param {number} [upstreamConditionsLen] \n * @param {Function} [func] \n * @returns \n */\nfunction _registerConditionStore(storeName, storeList, conditionChain, upstreamConditionsLen, func) {\n    // Register new store (to prevent excess evaluations)\n    return _store(storeName || \"\", {\n        upstream: [...storeList || [], ...conditionChain || []],\n        updater: (list)=> {\n            if(upstreamConditionsLen) {\n                for(let condition of list.slice(-upstreamConditionsLen) || []) {\n                    if(condition) return false;\n                }\n            }\n            return func?.(...list);\n        }\n    });\n}\n\n/**\n * Handle conditional and loop elements\n * @param {HTMLElement} el \n * @param {string} mode \n * @param {import(\"./index.module\").MfldOps} _ops \n */\nexport function _handleConditionals(el, mode, _ops) {\n    let ops = _getOpOverrides(_ops, el);\n    let rootElement = document.createElement(\"div\");\n    el.before(rootElement);\n\n    if(mode == `${ATTR_PREFIX}if`) {\n        rootElement.classList.add(\"mfld-active-condition\");\n\n        // Set up conditions\n        let siblingPtr = el;\n        let conditionChain = [];\n        while(siblingPtr) {\n            if(!siblingPtr) break;\n            let { storeList, func, storeName } = _parseFunction({\n                el: siblingPtr, \n                datakey: conditionChain.length ? `${ATTR_PREFIX}elseif`: mode\n        });\n            if(!storeList && !func) break;\n\n            // Ensure template\n            siblingPtr = _ensureTemplate(siblingPtr, rootElement);\n\n            // Register condition store\n            let upstreamConditionsLen = conditionChain.length;\n            let conditionStore = _registerConditionStore(storeName, storeList, conditionChain, upstreamConditionsLen, func);\n            conditionChain.push(conditionStore.name);\n\n            // Subscribe\n            let siblingClone = /** @type {HTMLElement}*/(siblingPtr.cloneNode(true));\n            conditionStore?.sub(val=> {\n                if(!val) return;\n                let sib = document.createElement(\"div\");\n                sib.innerHTML = siblingClone.innerHTML;\n                if(siblingClone?.tagName == \"TEMPLATE\") {\n                    _scheduleUpdate({\n                        in: sib,\n                        out: rootElement,\n                        relation: \"swapinner\",\n                        ops,\n                        done: ((el) => _registerSubs(el)),\n                    })\n                }\n            });\n\n            siblingPtr = /** @type {HTMLElement} */(siblingPtr?.nextElementSibling);\n        }\n    }\n\n    if(mode == `${ATTR_PREFIX}each`) {\n        rootElement.classList.add(\"mfld-loop-result\");\n\n        let [ funcStr, aliases ] = el.dataset[`${ATTR_PREFIX}each`]?.split(\"as\")?.map(s=> s.trim()) || [];\n        let [ valueName, keyName ] = aliases.split(/\\s{0,},\\s{0,}/)?.map(s=> s.trim()) || [\"value\", \"key\"];\n        let { storeList, func, storeName } = _parseFunction(funcStr);  \n        \n        // Ensure template\n        el = _ensureTemplate(el, rootElement);\n\n        // Register condition store\n        let conditionStore = _registerConditionStore(`LOOP:${storeName}`, storeList, [], 0, func);\n        conditionStore?.sub(val=> {\n            _scheduleUpdate(()=> rootElement.replaceChildren());\n            _iterable(val || [], (key, value)=> {\n                let html = el.innerHTML;\n\n                // Get all logical bindings and replace values\n                let replacements = el.innerHTML.match(/\\${[^}]*}/g) || [];\n                for(let rep of replacements) {\n                    let repClean = rep.replace(/^\\$\\{|\\}$/g, \"\");\n\n                    try {\n                        let fn = _parseFunction(`(${keyName}, ${valueName})=> ${repClean}`)?.func;\n                        html = html.replace(rep, fn?.(value, key) || \"\");\n                    }\n                    catch(e) {\n                        console.error(\"Syntax error in loop function\", e);\n                    }\n                }\n\n                // Replace values\n                let item = document.createElement(\"div\");\n                item.innerHTML = html;\n                \n                _scheduleUpdate({\n                    in: item,\n                    out: rootElement,\n                    relation: \"append\",\n                    ops,\n                    done: ((el) => _registerSubs(el))\n                });\n            });\n        })\n    }\n}","import { _store } from \"./store.js\";\nimport { _scheduleUpdate } from \"./updates.js\";\nimport { _parseFunction, ATTR_PREFIX } from \"./util.js\";\nimport { _handleFetch } from \"./fetch.js\";\nimport { _handleBindSync } from \"./bindsync.js\";\nimport { _handleConditionals } from \"./conditionals.js\";\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\n\n/** @type {Partial<MfldOps>} */\nlet _ops = {};\nlet _commaSepRx = /, {0,}/g;\nlet _elIdx = 0;\nlet _modes = [\"bind\", \"sync\", \"if\", \"each\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\"].map(m=> `${ATTR_PREFIX}${m}`);\nlet pageScripts = new WeakMap();\nlet pageStyles = new WeakMap();\n\n// globalThis.addEventListener(\"popstate\", (e)=> {\n//     let el = document?.getElementById(e.state?.elId);\n//     if(e?.state?.fetchData) {\n//         _fetchHttp(\n//             \"get\", \n//             \"\",\n//             e.state.fetchData,\n//             el,\n//             el=> {if(el) _registerSubs(el)}\n//         );\n//     }\n// });\n\n/**!\n * @param {Partial<MfldOps>} newops \n * @param {string} [profileName] \n */\nexport function _setOptions(newops, profileName) {\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\n    else _ops = { ..._ops, ...newops };\n}\n\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\n/**\n * @param {HTMLElement | null} [parent] \n */\nexport function _registerSubs(parent) {\n    /** @type {NodeListOf<HTMLElement> | []} */\n    let els = (parent || document.body).querySelectorAll(\n        `[data-${_modes.join(`],[data-`)}]${_ops.fetch?.auto != false ? \",a\" : \"\"}`\n    ) || [];\n\n    for(let el of els) {\n        /** @type {HTMLElement} */\n        if(!el.id) el.id = `${_elIdx++}`;\n\n        //Loop over all data attributes (modes)\n        for(let mode in el.dataset) {\n            //HANDLE CONDITIONALS AND LOOPS\n            if([`${ATTR_PREFIX}if`, `${ATTR_PREFIX}each`].includes(mode)) {\n                _handleConditionals(el, mode, _ops);\n                continue;\n            }\n\n            if(!_modes.includes(mode)) continue;\n            let shouldHaveTriggers = ![`${ATTR_PREFIX}bind`].includes(mode);\n            let err_detail = `(#${el.id} on ${mode})`;\n\n            //Loop over provided settings\n            for(let setting of el.dataset?.[mode]?.split(\";\") || []) {\n                //Break out settings\n                let [sourceParts, output] = setting?.split(\"->\")?.map(s=> s.trim()) || [];\n                let triggers = shouldHaveTriggers ? _paramsInParens(sourceParts.slice(0, sourceParts.indexOf(\")\"))) : [];\n                let funcAndInput = shouldHaveTriggers ? sourceParts.slice(sourceParts.indexOf(\")\") + 1) : sourceParts;\n                let processFuncName = funcAndInput.includes(\"=>\") ? funcAndInput : funcAndInput.includes(\"(\") ? funcAndInput.match(/^[^\\(]{1,}/)?.[0] || \"\" : \"\";\n                let input = processFuncName ? _paramsInParens(funcAndInput.slice(0, (funcAndInput.indexOf(\")\") || -2) + 1)) : funcAndInput.split(_commaSepRx)?.map(s=> s.trim());\n\n                //Handle errors\n                if(shouldHaveTriggers && !triggers?.length) { console.error(`No trigger: ${err_detail}.`); break; }\n\n                /** @type {Function | undefined} */\n                let processFunc = _parseFunction(processFuncName)?.func;\n                if(processFuncName) {\n                    if(!processFunc) console.warn(`\"${processFuncName}\" not registered: ${err_detail}`);\n                }\n                else if(input.length > 1) console.warn(`Multiple inputs without function: ${err_detail}`);\n\n                //Loop over triggers\n                if(!triggers?.length) triggers = [\"\"]\n                for(let trigger of triggers) {\n                    if(mode.match(/bind|sync/)) _handleBindSync(el, input, output, trigger, mode, processFunc);\n                    else {\n                        if(!output) {\n                            output = input[0];\n                            input = [];\n                        }\n                        _handleFetch(el, trigger, _ops, output, mode.replace(ATTR_PREFIX, \"\"), input, processFunc);\n                    }\n                }\n            }; //End loop settings\n        }   //End loop dataset modes\n    };  //End loop elements\n}\n\n/**\n * @param {string} str \n * @returns \n */\nfunction _paramsInParens(str) {\n    if(str?.includes(\"(\")) {\n        let matches = str.match(/[^\\(\\)]{1,}/g);\n        str = matches?.[matches.length - 1] || \"\";\n    }\n    return str?.split(_commaSepRx)?.map(s=> s.trim()) || [];\n}","import { _store } from \"./store.js\";\nimport { _addToNextTickQueue } from \"./updates.js\";\nimport { _registerSubs, _setOptions } from \"./registrar.js\";\n\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\n\n/**!\n * @typedef {object} ExternalOptions\n * @property {string} domain - The domain name these settings apply to\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\n * @property {boolean} [styles] - Allow styles from this domain to apply\n */\n\n/**!\n * @typedef {object} FetchOptions\n * @property {RequestInit} [request] - Fetch request options\n * @property {\"json\"|\"text\"} [responseType] - Response type (default: \"text\")\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\n * @property {(code: number, data: void | Response)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\n * @property {boolean} [auto] - Automatically fetch content on page load\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\n */\n\n/**!\n * @typedef {object} TransitionOptions\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\n * @property {boolean} [smartTransition] - Enable smart transitions (default: true)\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\n */\n\n/**!\n * Manifold options for `fetch`, `trans`, and `profiles`.\n * @typedef {Object} MfldOps\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\n */\n\n/**!\n * @template T\n * @callback UpdaterFunction\n * @param {Array<any>} upstreamValues\n * @param {T} value\n * @returns {T | Promise<T>}\n */\n\n/**\n * @template T\n * @callback ValueDeterminer\n * @param {T} [currentValue]\n * @returns {T | Promise<T> | undefined}\n */\n\n/**!\n * @template T\n * @callback UpdateFunction\n * @param {T | ValueDeterminer<T>} value\n * @returns {T | Promise<T> | undefined}\n */\n\n/**!\n * @template T\n * @typedef {Object} StoreOptions\n * @property {T} [value]\n * @property {Array<string>} [upstream]\n * @property {UpdaterFunction<T>} [updater]\n */\n\n/**!\n * @template T\n * @typedef {Function} SubFunction\n * @param {T} value\n * @returns {void}\n */\n\n/**!\n * @template T\n * @typedef Store\n * @prop {T} value - The store's current value (read only)\n * @prop {UpdateFunction<T>} update - Update the store's current value\n * @prop {SubFunction<T>} sub - Add a subscription function to the store\n */\n\n/**!\n * @typedef {Function} MfldFunc\n * @param {any} val\n * @param {HTMLElement} [el]\n */\n\n/**!\n * The global Manifold interface.\n */\nexport let Mfld = {\nstore: \n/**!\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @template T\n* @param {string} store_name\n* @param {StoreOptions<T> | T} store_ops\n* @return {Store<T>}\n*/ (store_name, store_ops)=> {\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\n    }\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\n},\nustore: \n/**!\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @param {string} store_name\n* @param {StoreOptions<any> | any} store_ops\n* @return {Store<any>}\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\nget:\n/**!\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\n * @param {string} store_name\n * @return {Store<any>}\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\nfunc: \n/**!\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\n * @param {string} func_name\n * @return {MfldFunc}\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(\n// @ts-ignore\n MfFn?.get(func_name)),\nfuncs: \n/**!\n * - Add functions to the Manifold function registry in key-value pairs.\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\n * @param {{ [key: string]: MfldFunc }} funcs\n */ funcs=> {for(let key in funcs) \n// @ts-ignore\n MfFn.set(key, funcs[key])},\nconfig:\n/**!\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\n * @param {MfldOps} new_ops\n * @param {string} [profile_name]\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\n onTick:\n /**!\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\n  * @param {()=> void} cb\n  */ (cb)=> _addToNextTickQueue(cb),\nregister:\n/**!\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\n * @param {HTMLElement | string | null} [parent]\n */ (parent)=> {\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\n        _registerSubs(parent)\n    },\n};"],"names":["spacer","workArray","cancelAnimationFrame","_nextTickQueue","spacerHeight","tick","globalThis","requestAnimationFrame","fn","setTimeout","_scheduleUpdate","update","push","_runUpdates","_addSpacer","inEl","wrapper","wrapperHeight","replaceWholeObject","ops","trans","smartTransition","document","createElement","paddingTop","paddingBottom","Element","window","getComputedStyle","style","height","Math","abs","clientHeight","after","_adjustSizing","dur","remove","animate","order","out","relation","in","_applyTransition","prepend","includes","container","cloneNode","getDimensionsAfterUpdate","border","replaceChildren","undefined","replaceWith","appendChild","done","el","dir","refElement","nodeType","Node","TEXT_NODE","text","textContent","newNode","Array","isArray","transClass","class","classList","add","hooks","dimensions","w","clientWidth","paddingLeft","paddingRight","left","getBoundingClientRect","scrollX","top","scrollY","position","width","margin","transitionDuration","swap","_hashAny","input","Map","from","entries","Set","hash","char","TextEncoder","encode","toString","MfSt","MfFn","Store","_updater","_subscriptions","_storedHash","_upstreamStores","_downstreamStores","constructor","name","this","_modify","set","upstream","map","s","S","_store","value","updater","_auto_update","sub","ref","immediate","String","Date","now","random","Promise","async","resolve","newValue","newHash","ds","newVal","found_store","get","ATTR_PREFIX","_inputNestSplitRx","_nestedValue","obj","path","newval","ptr","key","length","_getStorePathFromKey","storeName","split","sp","isNaN","parseInt","filter","_getOverride","parse","def","as","override","dataset","profiles","fetch","JSON","_getOpOverrides","overrides","responseType","_parseFunction","data","condition","datakey","stores","trim","slice","storeList","replace","func","match","Function","_handleFetch","trigger","_ops","href","method","processFunc","ev","e","preventDefault","stopPropagation","fetchOps","target","externals","find","allowed","startsWith","domain","location","origin","body","request","headers","stringify","catch","error","err","console","code","status","onCode","resp","instruction","selector","toReplace","fullMarkup","DOMParser","parseFromString","querySelector","_registerSubs","resolveTxt","resolveFunc","addEventListener","_handleBindSync","output","mode","domSubscription","storeValues","val","parts","setAttribute","dispatchEvent","CustomEvent","propValues","prop","getAttribute","curVal","_ensureTemplate","rootElement","tagName","newEl","innerHTML","attr","attributes","_registerConditionStore","conditionChain","upstreamConditionsLen","list","_handleConditionals","before","siblingPtr","conditionStore","siblingClone","sib","nextElementSibling","funcStr","aliases","valueName","keyName","cb","arr","forEach","_iterable","html","replacements","rep","repClean","item","_commaSepRx","_elIdx","_modes","m","parent","els","querySelectorAll","join","auto","id","shouldHaveTriggers","err_detail","setting","sourceParts","triggers","_paramsInParens","indexOf","funcAndInput","processFuncName","warn","str","matches","Mfld","store","store_name","store_ops","hasOwnProperty","ustore","func_name","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register"],"mappings":"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"}