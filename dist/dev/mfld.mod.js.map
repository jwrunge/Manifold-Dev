{"version":3,"file":"mfld.mod.js","sources":["../../src/updates.js","../../src/store.js","../../src/http.js","../../src/registrar.js","../../src/index.module.js"],"sourcesContent":["/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/** @type {{ adjust?: Function, space?: Function, size?: Function } | undefined} */\r\nlet smartOutro = globalThis.smartOutro;\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"$append\" | \"$prepend\" | \"$replace\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = false;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n// Polyfill requestAnimationFrame\r\nlet tick = globalThis?.requestAnimationFrame || ((fn)=> setTimeout(fn, 0));\r\n\r\n/** @type {Map<Store<any>, (any | ((any)=> any))>} */ export let _workOrder = new Map();\r\n\r\nexport function _addToNextTickQueue(fn) {\r\n    if(fn) _nextTickQueue.push(fn);\r\n}\r\n\r\n/** @export @param {(DomWorkOrder | Function)} update */\r\nexport function _scheduleUpdate(update) {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = true;\r\n        tick(_runUpdates);\r\n    }\r\n}\r\n\r\nfunction _runUpdates() {\r\n    cancelAnimationFrame = false;\r\n\r\n    // Update stores and cascade downstream\r\n    for(let [S] of _workOrder) {\r\n        // @ts-ignore\r\n        for(let [ref, sub] of S?._subscriptions || []) sub?.(S.value, ref);\r\n    }\r\n\r\n    // Clear work order and update derived stores\r\n    _workOrder.clear();\r\n    \r\n    /**\r\n    * @type {DomWorkOrder[]}\r\n    */\r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") (/** @type {Function} */ order)();\r\n        else {\r\n            // Remove old children\r\n            if([\"$replace\", \"$append\"].includes(order.relation)) {\r\n                if(order.relation == \"$replace\") {\r\n                    //Remove old children before appending\r\n                    let container = document?.createElement(\"div\");\r\n                    for(let child of Array.from(order.out?.childNodes || [])) {\r\n                        container.appendChild(child);\r\n                    }\r\n                    order.out?.replaceChildren(container);\r\n                    _applyTransition(container, \"out\", order.ops);\r\n                }\r\n\r\n                smartOutro?.space?.(order.in, order.out);\r\n\r\n                //Append\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) order.out?.appendChild(order.in);\r\n                    smartOutro?.adjust?.(order.in, order.ops);\r\n                });\r\n            }\r\n            //Insert after old element before removing\r\n            else _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                order.out?.after(order.in);\r\n                smartOutro?.space?.(order.in, order.out);\r\n                smartOutro?.adjust?.(order.in, order.ops);\r\n\r\n                //Remove old element\r\n                if(order.relation == \"$prepend\") _applyTransition(order.out, \"out\", order.ops);\r\n            });\r\n\r\n            order.done?.(order.in);\r\n        }\r\n    }\r\n\r\n    //Handle queued nextTick functions\r\n    _nextTickQueue.forEach(fn=> fn());\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @returns \r\n */\r\nfunction _applyTransition(el, dir, ops, fn) {\r\n    //Handle text nodes\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        let text = el.textContent;\r\n        let newNode = document?.createElement(\"div\");\r\n        newNode.textContent = text;\r\n        el.replaceWith(newNode);\r\n        el = newNode;\r\n    }\r\n\r\n    if(el) {\r\n        let dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n\r\n        //Initiate transition\r\n        let transClass = ops?.trans?.class || \"mf-trans\";\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        //Wait to apply class\r\n        if(dir == \"out\") {\r\n            _scheduleUpdate(()=> {\r\n                smartOutro?.size?.(el);\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                el.classList?.add(dir);\r\n            })\r\n        }\r\n        //If dir == in\r\n        else {\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                    el?.classList?.add(dir);\r\n                    fn?.();\r\n\r\n                    //Remove transition class\r\n                    _scheduleUpdate(()=> {\r\n                        el?.classList?.remove(dir);\r\n                    });\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                //Wrapup\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                el?.classList?.remove(dir);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}","/** \r\n * @template T\r\n * @typedef {import(\"./index.module.js\").UpdaterFunction<T>} UpdaterFunction \r\n */\r\n/** \r\n * @template T\r\n * @typedef {import(\"./index.module.js\").StoreOptions<T>} StoreOptions \r\n */\r\n\r\nimport { _scheduleUpdate, _workOrder } from \"./updates.js\";\r\n\r\n/**\r\n * @callback SubFunction\r\n * @param {any} value\r\n * @param {string} [ref]\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * @param {any} input \r\n * @returns {any}\r\n */\r\nfunction _hashAny(input) {\r\n    if(!input) return 0;\r\n    if(typeof input == 'number') return input;\r\n    if(input === true) return 1;\r\n\r\n    if(input instanceof Map) return _hashAny(Array.from(input.entries()));\r\n    else if(input instanceof Set) return _hashAny(Array.from(input));\r\n\r\n    let hash = 0;\r\n    for(let char of new TextEncoder().encode(\r\n        typeof input == 'string' ? input : input?.toString() || \"\"\r\n    )) \r\n        hash = ((hash << 5) - hash) + char;\r\n    return hash;\r\n}\r\n\r\n//Static\r\n/** @type {Map<string, Store<any>>} */ if(!globalThis.MfSt) globalThis.MfSt = new Map();\r\n/** @type {Map<string, Function>} */ if(!globalThis.MfFn) globalThis.MfFn = new Map();\r\n\r\n/**\r\n * @template T\r\n */\r\nexport class Store {\r\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\r\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\r\n    /** @type {string | undefined} */ _storedHash = undefined;\r\n    /** @type {Set<Store<any>>} */ _upstreamStores;\r\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    constructor(name, ops) {\r\n        return this._modify(name, ops);        \r\n    }\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    _modify(name, ops) {\r\n        this.name = name;\r\n        // @ts-ignore\r\n        MfSt.set(name, this);\r\n        \r\n        this._upstreamStores = new Set(ops?.upstream?.map(s=> _store(s)) || []);\r\n        this._upstreamStores.forEach(s=> s?._downstreamStores?.add(this));\r\n        this.value = ops?.value;\r\n        this._updater = ops?.updater;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {(T)=> void} sub\r\n     * @param {string | undefined} ref\r\n     */\r\n    sub(sub, ref) {\r\n        this._subscriptions.set(ref || String(Date.now() + Math.random()), sub);\r\n        sub?.(this.value);\r\n    }\r\n\r\n    //Update (manual or automated -- cascades downstream on batch updates)\r\n    /**\r\n    * @template T\r\n    * @param {T | ((T)=> T | Promise<T>)} value\r\n    */\r\n    async update(value) {\r\n        return new Promise(async (resolve)=> {\r\n            //Apply new value   \r\n            let newValue = (typeof value == \"function\" ? /** @type {Function} */(await value)?.(this.value) : value);\r\n            let newHash = _hashAny(newValue);\r\n            if(newHash !== this._storedHash) {\r\n                this.value = newValue;\r\n                this._storedHash = newHash;\r\n\r\n                // Add this store to the work order\r\n                _workOrder.set(this, await value);\r\n                for(let ds of this._downstreamStores) _workOrder.set(ds, await ds._auto_update());\r\n\r\n                // Wait for next animation frame to return the value\r\n                _scheduleUpdate(()=> {\r\n                    resolve(this.value);\r\n                });\r\n            }\r\n            else resolve(this.value);\r\n        });\r\n    }\r\n\r\n    async _auto_update() {\r\n        await this.update(\r\n            await this._updater?.(\r\n                Array.from(this._upstreamStores)?.map(S => S?.value) || [], \r\n                /** @type {T} */(this?.value)\r\n            ) || this.value,\r\n        )\r\n    }\r\n}\r\n\r\n/**\r\n * STORE STATIC METHODS\r\n */\r\n/**\r\n * @template T\r\n * @param {string} name - The name of the store\r\n * @param {StoreOptions<T> | T} [ops] - Options to update the store\r\n * @returns {Store<T>}\r\n */\r\nexport function _store(name, ops) {\r\n    // @ts-ignore\r\n    let found_store = MfSt.get(name);\r\n    if(ops) {\r\n        if(found_store) {\r\n            return found_store._modify(name, ops);\r\n        }\r\n        return new Store(name, ops);\r\n    }\r\n    return found_store || new Store(name, /** @type {StoreOptions<T>}*/(ops));\r\n}","import { _scheduleUpdate } from \"./updates.js\";\r\n\r\n//Track scripts and styles\r\nlet pageScripts = new WeakMap();\r\nlet pageStyles = new WeakMap();\r\nlet parser = globalThis.DOMParser ? new DOMParser() : undefined;\r\n\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n//Fetch page and replace content\r\n/**\r\n * \r\n * @param {MfldOps} ops \r\n * @param {{method: string, href: string, el: HTMLElement}} target\r\n * @param {(el: HTMLElement | null)=> void} done \r\n * @returns \r\n */\r\nexport async function _fetchHttp(target, ops, done) {\r\n    if(!parser) return;\r\n    \r\n    //Make sure we're allowed to fetch\r\n    if(!ops.fetch?.externals?.some(allowed=> target?.href?.startsWith(allowed.domain))) {\r\n        //Fetch data\r\n        let fOps = ops.fetch;\r\n        let data = await fetch(target?.href, {\r\n            ...(fOps?.request || {}),\r\n            method: target?.method,\r\n            body: fOps?.request?.body ? JSON.stringify(fOps?.request?.body || {}) : undefined,\r\n        })\r\n        .catch(error=> {\r\n            fOps?.err?.(error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fOps?.onCode?.(code) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let text = await data?.[ops.fetch?.type || \"text\"]();\r\n        ops.fetch?.cb?.(text);\r\n\r\n        if((ops?.fetch?.type) != \"json\") {\r\n            //Extract content\r\n            let fullMarkup = parser.parseFromString(text, 'text/html').body;\r\n        \r\n            // //Clear existing scripts/styles\r\n            // clearDynamicElements(parent, pageScripts, \"script\");\r\n            // clearDynamicElements(parent, pageStyles, \"style\");;\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n\r\n            // ops.replace.forEach(r => {\r\n            //     let [ extract, relation, replace ] = r.split(/\\s*(>|\\/|\\+)\\s*/);\r\n\r\n            //     // let outEl = [\"this\", \"self\"].includes(replace) ? parent : document.querySelector(replace);\r\n// globalThis.document?.\r\n            //     _scheduleUpdate({\r\n            //         in: /** @type {HTMLElement} */ (fullMarkup.querySelector(extract)),\r\n            //         out: /** @type {HTMLElement} */ ([\"this\", \"self\"].includes(replace) ? parent : document.querySelector(replace)),\r\n            //         relation,globalThis.document?.\r\n            //         ops,\r\n            //         done,\r\n            //     })\r\n            // });\r\n        }\r\n    }\r\n}\r\n\r\n// //Clear dynamic elements\r\n// function clearDynamicElements(parent: HTMLElement, map: WeakMap<HTMLElement, any[]>, type: string) {\r\n//     let elements = map.get(parent) || [];\r\n//     elements.forEach(el => el.remove());\r\n//     map.set(parent, []);\r\n// }","import { _store } from \"./store.js\";\r\nimport { _fetchHttp } from \"./http.js\";\r\nimport { _scheduleUpdate } from \"./updates.js\";\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/** @type {Partial<MfldOps>} */\r\nlet _ops = {};\r\n\r\nlet ATTR_PREFIX = \"mf\";\r\n\r\nlet _commaSepRx = /, {0,}/g;\r\nlet _elIdx = 0;\r\nlet pageScripts = new WeakMap();\r\nlet pageStyles = new WeakMap();\r\n\r\n// globalThis.addEventListener(\"popstate\", (e)=> {\r\n//     let el = document?.getElementById(e.state?.elId);\r\n//     if(e?.state?.fetchData) {\r\n//         _fetchHttp(\r\n//             \"get\", \r\n//             \"\",\r\n//             e.state.fetchData,\r\n//             el,\r\n//             el=> {if(el) _registerSubs(el)}\r\n//         );\r\n//     }\r\n// });\r\n\r\n/**!\r\n * @param {Partial<MfldOps>} newops \r\n * @param {string} [profileName] \r\n */\r\nexport function _setOptions(newops, profileName) {\r\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\r\n    else _ops = { ..._ops, ...newops };\r\n}\r\n\r\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\r\n/**\r\n * @param {HTMLElement | null} [parent] \r\n */\r\nexport function _registerSubs(parent) {   \r\n    /** @type {NodeListOf<HTMLElement> | []} */\r\n    let els = (parent || document.body).querySelectorAll(\r\n        `[data-${ATTR_PREFIX}${[\"bind\", \"sync\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\"].join(`],[data-${ATTR_PREFIX}`)}]${_ops.fetch?.auto != false ? \",a\" : \"\"}`\r\n    ) || [];\r\n\r\n    for(let el of els) {\r\n        /** @type {HTMLElement} */\r\n        if(!el.id) el.id = `${_elIdx++}`;\r\n\r\n        //Loop over all data attributes (modes)\r\n        for(let mode in el.dataset) {\r\n            let shouldHaveTriggers = mode != `${ATTR_PREFIX}bind`;\r\n            let err_detail = `(#${el.id} on ${mode})`;\r\n\r\n            //Loop over provided settings\r\n            el.dataset?.[mode]?.split(\";\").forEach(setting=> {\r\n                //Break out settings\r\n                let _parts = setting?.split(/(?:(?:\\)|->) ?){1,}/g) || []; \r\n        \r\n                //Extract settings\r\n                let triggers = shouldHaveTriggers ? _paramsInParens(_parts.splice(0,1)[0]) : [];\r\n                let processFuncName = _parts[0]?.includes(\"(\") ? _parts[0]?.match(/^[^\\(]{1,}/)?.[0] || \"\" : \"\";\r\n                let output = _paramsInParens(_parts.splice(mode == `${ATTR_PREFIX}sync` ? 1 : 0, 1)[0]);\r\n                let input = _paramsInParens(_parts[0]);\r\n\r\n                //Handle errors\r\n                if(shouldHaveTriggers && !triggers?.length) throw(`No trigger: ${err_detail}.`)\r\n\r\n                /** @type {Function | undefined} */\r\n                let processFunc;\r\n                if(processFuncName) {\r\n                    // @ts-ignore\r\n                    processFunc = globalThis[processFuncName] || MfFn?.get(processFuncName);\r\n                    if(!processFunc) console.warn(`\"${processFuncName}\" not registered: ${err_detail}`);\r\n                    if(((!shouldHaveTriggers && output.length > 1) || (shouldHaveTriggers && input.length > 1))) throw(`Multiple sources: ${err_detail}`);\r\n                }\r\n\r\n                //Map output names and paths\r\n                let outputData = output.map((ext)=> {\r\n                    let [ name, ...sourcePathArr ] = ext.split(/[\\.\\[\\]\\?]{1,}/g);\r\n                    return {\r\n                        name,\r\n                        path: sourcePathArr.map(sp=> !isNaN(parseInt(sp)) \r\n                            ? parseInt(sp) \r\n                            : sp)\r\n                            .filter(sp=> sp) /** @type {(string | number)[]} */\r\n                    }\r\n                });\r\n\r\n                //Loop over triggers\r\n                if(!triggers?.length) triggers = [\"\"]\r\n                for(let trigger of triggers) {\r\n                    /**\r\n                     * HANDLE MF-FETCH\r\n                     */\r\n                    //No input loops for fetch\r\n                    if(!mode.match(/bind|sync/)) {\r\n                        if(input.length > 1 || output.length > 1) throw(`Multiple sources: ${err_detail}`);\r\n                        _handleFetch(el, trigger, mode.replace(ATTR_PREFIX, \"\"), input[0], output[0]);\r\n                        return;\r\n                    }\r\n\r\n                    //Loop over input\r\n                    if(!input?.length) input = [ \"\" ];\r\n                    for(let i=0; i < input.length; i++) {\r\n                        /**\r\n                         * HANDLE MF-BIND\r\n                         */\r\n                        if(mode == `${ATTR_PREFIX}bind`) {\r\n                            let domSubscription = ()=> {\r\n                                _scheduleUpdate(()=> {\r\n                                    let val = processFunc?.(\r\n                                        ...outputData.map(\r\n                                            s=> _nestedValue(_store(s.name)?.value, s.path)\r\n                                        ), el\r\n                                    ) ??\r\n                                    _nestedValue(\r\n                                        _store(outputData[0].name || \"\")?.value, outputData[0].path\r\n                                    );\r\n\r\n                                    if(val !== undefined) el[input[i]] = val;\r\n\r\n                                    //Make sure to update dependent stores on value update\r\n                                    el.dispatchEvent(new CustomEvent(trigger))\r\n                                });\r\n                            }\r\n                        \r\n                            //Add subscription - run whenever store updates\r\n                            for(let store of outputData) _store(store.name)?.sub(domSubscription, el.id);\r\n                        }\r\n\r\n                        /**\r\n                         * HANDLE MF-SYNC\r\n                         */\r\n                        else if(mode == `${ATTR_PREFIX}sync`) {\r\n                            if(outputData.length > 1) throw(`Only one store supported: ${err_detail}`)\r\n                            let ev = ()=> {\r\n                                let prop = input[i].trim();\r\n                                let value = el[prop] ?? el.getAttribute(prop) ?? el.dataset[prop] ?? undefined;\r\n                                \r\n                                if(processFunc) value = processFunc?.(value, el);\r\n                                let store = _store(outputData[0]?.name);\r\n                                \r\n                                if(value !== undefined) {\r\n                                    store?.update?.(curVal=> {\r\n                                        return outputData[0]?.path?.length ? _nestedValue(curVal, outputData[0]?.path, value) : value\r\n                                    });\r\n                                }\r\n                            }\r\n                            if(trigger == \"$mount\") ev();\r\n                            else el.addEventListener(trigger, ev);\r\n                        }\r\n                    }   //End loop input\r\n                }   //End loop triggers\r\n            }); //End loop settings\r\n        }   //End loop dataset modes\r\n    };  //End loop elements\r\n}\r\n\r\n//Get or set nested store values\r\n/**\r\n * \r\n * @param {any} obj \r\n * @param {(string | number)[]} path \r\n * @param {any} [newval] \r\n * @returns \r\n */\r\nfunction _nestedValue(obj, path, newval) {\r\n    let ptr = obj;\r\n\r\n    for(let key of path) {\r\n        //Dynamically letruct object if it doesn't exist\r\n        if(ptr == undefined) ptr = typeof key == \"number\" ? [] : {};\r\n\r\n        //Set or get value\r\n        if(newval == undefined || path[path.length - 1] !== key) ptr = ptr instanceof Map ? ptr?.get(key) : ptr?.[key];\r\n        else ptr instanceof Map ? ptr.set(key, newval) : ptr[key] = newval;\r\n    }\r\n\r\n    return ptr;\r\n}\r\n\r\n/**\r\n * @param {string} str \r\n * @returns \r\n */\r\nfunction _paramsInParens(str) {\r\n    if(str?.includes(\"(\")) {\r\n        let matches = str.match(/[^\\(\\)]{1,}/g);\r\n        str = matches?.[matches.length - 1] || \"\";\r\n    }\r\n    return str?.split(_commaSepRx)?.map(s=> s.trim()) || [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {string} trigger \r\n * @param {string} [method] \r\n * @param {BodyInit | null} [input]\r\n * @param {string} [href]\r\n */\r\nfunction _handleFetch(el, trigger, method, input, href) {\r\n    /**\r\n     * @param {Event} [e]\r\n     */\r\n    let ev = async e=> {  \r\n        e?.preventDefault();\r\n        e?.stopPropagation();\r\n        let overrides = el.dataset[`${ATTR_PREFIX}overrides`] || \"{}\";\r\n\r\n        /** @type {MfldOps[\"fetch\"]} */\r\n        let fetchOps = {\r\n            ..._ops,\r\n            ..._ops.profiles?.[overrides]?.fetch || JSON.parse(overrides),\r\n        };\r\n\r\n        // If no input data was provided, it's the href; use fetchOps.body if it exists (input overrides this)\r\n        if(!href) {\r\n            href = typeof input == \"string\" ? structuredClone(input) : null || /** @type {string} */(/** @type {any}*/(e?.target)?.href);\r\n            input = fetchOps?.request?.body;\r\n        }\r\n\r\n        // Set from target element if relevant; fall back to \"get\"\r\n        if(!method) method = /** @type {any}*/(e?.target)?.method || \"get\";\r\n\r\n        // if([\"click\", \"submit\"].includes(trigger) || [\"A\", \"FORM\"].includes(target?.nodeName)) {\r\n        //     history.pushState(\r\n        //         {fetchData, elId: el.id}, \r\n        //         \"\", \r\n        //         target?.href || target?.action || \"\"\r\n        //     );\r\n        // }\r\n    \r\n        //Make sure we're allowed to fetch\r\n        let fOps = fetchOps;\r\n\r\n        let externalPermissions = fetchOps?.externals?.find(allowed=> href?.startsWith(allowed.domain)) || \r\n            !href.match(/^https?:\\/\\//) || href.includes(location.origin) ? {\r\n                scripts: true,\r\n                styles: true,\r\n        } : undefined;\r\n\r\n        //Fetch data\r\n        let data = await fetch(href, {\r\n            ...(fOps?.request || {}),\r\n            method,\r\n            body: typeof input == \"string\" ? input : JSON.stringify(input),\r\n        })\r\n        .catch(error=> {\r\n            fOps?.err?.(error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fOps?.onCode?.(code) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let resp = await data?.[fetchOps?.type || \"text\"]();\r\n        fetchOps?.cb?.(resp);\r\n\r\n        // Handle resolutions\r\n        let resolve = el.dataset[`${ATTR_PREFIX}resolve`];\r\n        if([\"$append\", \"$prepend\", \"$replace\"].includes(resolve || \"\")) {\r\n            console.log(\"RESOLVE\", resolve, resp);\r\n\r\n            //Extract content\r\n            if(fOps?.type == \"text\") {\r\n                let fullMarkup = new DOMParser()?.parseFromString?.(resp, 'text/html');\r\n\r\n                if(fullMarkup) {\r\n                    _scheduleUpdate({\r\n                        in: /** @type {HTMLElement} */ (fullMarkup.querySelector(\"body\")),\r\n                        out: /** @type {HTMLElement} */ el,\r\n                        //@ts-ignore\r\n                        relation: resolve,\r\n                        ops: fOps,\r\n                        done: ()=> true,\r\n                    })\r\n                }\r\n                else {\r\n                    // Handle paste text\r\n                }\r\n            }\r\n\r\n            // //Clear existing scripts/styles\r\n            // for(let s of [pageScripts, pageStyles]) {\r\n            //     let elements = s.get(fullMarkup) || [];\r\n            //     elements.forEach(el => el.remove());\r\n            //     s.set(fullMarkup, []);\r\n            // }\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n        }\r\n        else if(resolve) {\r\n\r\n        }\r\n    }\r\n\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}","import { _store } from \"./store.js\";\r\nimport { _addToNextTickQueue } from \"./updates.js\";\r\nimport { _registerSubs, _setOptions } from \"./registrar.js\";\r\n\r\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\r\n\r\n/**!\r\n * @typedef {object} ExternalOptions\r\n * @property {string} domain - The domain name these settings apply to\r\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\r\n * @property {boolean} [styles] - Allow styles from this domain to apply\r\n */\r\n\r\n/**!\r\n * @typedef {object} FetchOptions\r\n * @property {RequestInit} [request] - Fetch request options\r\n * @property {\"json\"|\"text\"} [type] - Response type (default: \"text\")\r\n * @property {(val: any)=> void} [cb] - Callback function - run on successful fetch; *val* is the un-parsed response body\r\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\r\n * @property {(code: number)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\r\n * @property {boolean} [auto] - Automatically fetch content on page load\r\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\r\n */\r\n\r\n/**!\r\n * @typedef {object} TransitionOptions\r\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\r\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\r\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\r\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\r\n */\r\n\r\n/**!\r\n * Manifold options for `fetch`, `trans`, and `profiles`.\r\n * @typedef {Object} MfldOps\r\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\r\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\r\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback UpdaterFunction\r\n * @param {Array<any>} upstreamValues\r\n * @param {T} value\r\n * @returns {T | Promise<T>}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef {Object} StoreOptions\r\n * @property {T} [value]\r\n * @property {Array<string>} [upstream]\r\n * @property {UpdaterFunction<T>} [updater]\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef Store\r\n * @prop {T} value - The store's current value (read only)\r\n * @prop {function(T | function(T):T|Promise<T>|undefined):T|Promise<T>|undefined} update - Update the store's current value\r\n * @prop {function(function(T):void,string):void} sub - Add a subscription function to the store\r\n */\r\n\r\n/**!\r\n * @typedef {Function} MfldFunc\r\n * @param {any} val\r\n * @param {HTMLElement} [el]\r\n */\r\n\r\n/**!\r\n * The global Manifold interface.\r\n */\r\nexport let Mfld = {\r\nstore: \r\n/**!\r\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @template T\r\n* @param {string} store_name\r\n* @param {StoreOptions<T> | T} store_ops\r\n* @return {Store<T>}\r\n*/ (store_name, store_ops)=> {\r\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\r\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\r\n    }\r\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\r\n},\r\nustore: \r\n/**!\r\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @param {string} store_name\r\n* @param {StoreOptions<any> | any} store_ops\r\n* @return {Store<any>}\r\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\r\nget:\r\n/**!\r\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\r\n * @param {string} store_name\r\n * @return {Store<any>}\r\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\r\nfunc: \r\n/**!\r\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\r\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\r\n * @param {string} func_name\r\n * @return {MfldFunc}\r\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(\r\n// @ts-ignore\r\n MfFn?.get(func_name)),\r\nfuncs: \r\n/**!\r\n * - Add functions to the Manifold function registry in key-value pairs.\r\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \r\n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\r\n * @param {{ [key: string]: MfldFunc }} funcs\r\n */ funcs=> {for(let key in funcs) \r\n// @ts-ignore\r\n MfFn.set(key, funcs[key])},\r\nconfig:\r\n/**!\r\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\r\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\r\n * @param {MfldOps} new_ops\r\n * @param {string} [profile_name]\r\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\r\n onTick:\r\n /**!\r\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\r\n  * @param {()=> void} cb\r\n  */ (cb)=> _addToNextTickQueue(cb),\r\nregister:\r\n/**!\r\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\r\n * @param {HTMLElement | string | null} [parent]\r\n */ (parent)=> {\r\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\r\n        _registerSubs(parent)\r\n    },\r\n};"],"names":["smartOutro","globalThis","workArray","cancelAnimationFrame","_nextTickQueue","tick","requestAnimationFrame","fn","setTimeout","_workOrder","Map","_scheduleUpdate","update","push","_runUpdates","S","ref","sub","_subscriptions","value","clear","order","includes","relation","container","document","createElement","child","Array","from","out","childNodes","appendChild","replaceChildren","_applyTransition","ops","space","in","adjust","after","done","forEach","el","dir","nodeType","Node","TEXT_NODE","text","textContent","newNode","replaceWith","dur","isArray","trans","transClass","class","classList","add","hooks","size","style","transitionDuration","remove","swap","_hashAny","input","entries","Set","hash","char","TextEncoder","encode","toString","MfSt","MfFn","Store","_updater","undefined","_storedHash","_upstreamStores","_downstreamStores","constructor","name","this","_modify","set","upstream","map","s","_store","updater","String","Date","now","Math","random","Promise","async","resolve","newValue","newHash","ds","_auto_update","found_store","get","DOMParser","_ops","ATTR_PREFIX","_commaSepRx","_elIdx","_nestedValue","obj","path","newval","ptr","key","length","_paramsInParens","str","matches","match","split","trim","_handleFetch","trigger","method","href","ev","e","preventDefault","stopPropagation","overrides","dataset","fetchOps","profiles","fetch","JSON","parse","structuredClone","target","request","body","fOps","externals","find","allowed","startsWith","domain","location","origin","data","stringify","catch","error","err","code","status","onCode","resp","type","cb","console","log","fullMarkup","parseFromString","querySelector","addEventListener","Mfld","store","store_name","store_ops","hasOwnProperty","ustore","func","func_name","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register","parent","els","querySelectorAll","join","auto","id","mode","shouldHaveTriggers","err_detail","setting","processFunc","_parts","triggers","splice","processFuncName","output","warn","outputData","ext","sourcePathArr","sp","isNaN","parseInt","filter","replace","i","domSubscription","val","dispatchEvent","CustomEvent","prop","getAttribute","curVal","_registerSubs"],"mappings":"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"}