{"version":3,"file":"mfld.mod.js","sources":["../../src/util.js","../../src/updates.js","../../src/store.js","../../src/fetch.js","../../src/bindsync.js","../../src/conditionals.js","../../src/registrar.js","../../src/index.module.js"],"sourcesContent":["export let ATTR_PREFIX = \"mf_\";\r\nexport let _inputNestSplitRx = /[\\.\\[\\]\\?]{1,}/g;\r\n\r\n/**\r\n * Get or set nested store values\r\n * @param {any} obj \r\n * @param {(string | number)[]} path \r\n * @param {any} [newval] \r\n * @returns \r\n */\r\nexport function _nestedValue(obj, path, newval) {\r\n    let ptr = obj;\r\n\r\n    for(let key of path) {\r\n        //Dynamically letruct object if it doesn't exist\r\n        if(ptr == undefined) ptr = typeof key == \"number\" ? [] : {};\r\n\r\n        //Set or get value\r\n        if(newval == undefined || path[path.length - 1] !== key) ptr = ptr instanceof Map ? ptr?.get(key) : ptr?.[key];\r\n        else ptr instanceof Map ? ptr.set(key, newval) : ptr[key] = newval;\r\n    }\r\n\r\n    return ptr;\r\n}\r\n\r\nexport function _getStorePathFromKey(s) {\r\n    let [storeName, ...path] = (s)?.split(_inputNestSplitRx);\r\n    return [storeName, path?.map(sp=> !isNaN(parseInt(sp)) ? parseInt(sp) : sp).filter(sp=> sp) || []];\r\n}\r\n\r\nfunction _getOverride(name, el, ops, parse = true, def = \"{}\", as) {\r\n    let override = el.dataset[`${ATTR_PREFIX}${name}`];\r\n    if(!override) return undefined;\r\n    if(name == \"overrides\") return ops.profiles?.[override || \"\"]?.fetch || JSON.parse(override || \"{}\");\r\n    if(parse) return JSON.parse(override || def);\r\n    if(as == \"num\") return parseInt(override) || undefined;\r\n    if(as == \"bool\") return override == \"true\" ? true : override == \"false\" ? false : undefined;\r\n    return override;\r\n}\r\n\r\n/**\r\n * Get or set nested store values\r\n * @param {import(\"./index.module\").MfldOps} ops\r\n * @param {HTMLElement} el\r\n * @returns {import(\"./index.module\").MfldOps}\r\n */\r\nexport function _getOpOverrides(ops, el) {\r\n    let overrides = _getOverride(\"overrides\", el, ops);\r\n\r\n    let newops = {\r\n        profiles: ops.profiles,\r\n        fetch: {\r\n            ...ops.fetch,\r\n            ...{\r\n                responseType: _getOverride(\"responsetype\", el, ops, false) || ops.fetch?.responseType\r\n            },\r\n            ...(overrides?.fetch || {}),\r\n            ...(_getOverride(\"fetch\", el, ops) || {}),\r\n        },\r\n        trans: {\r\n            ...ops.trans,\r\n            ...{\r\n                dur: _getOverride(\"transdur\", el, ops, true, \"[]\", \"num\") || ops.trans?.dur,\r\n                swap: _getOverride(\"transswap\", el, ops, false, \"\", \"num\") || ops.trans?.swap,\r\n                class: _getOverride(\"transclass\", el, ops, false) || ops.trans?.class,\r\n                smartTransition: _getOverride(\"transsmart\", el, ops, false, undefined, \"bool\") || ops.trans?.smartTransition,\r\n            },\r\n            ...(overrides?.trans || {}),\r\n            ...(_getOverride(\"trans\", el, ops) || {}),\r\n        },\r\n    }\r\n\r\n    return newops;\r\n}\r\n\r\n/**\r\n * @param {{el: HTMLElement, datakey: string} | string} data \r\n * @returns {{ storeList?: string[], func?: Function, storeName?: string}}\r\n */\r\nexport function _parseFunction(data) {\r\n    let condition = \"\";\r\n    let storeName = \"\";\r\n    if(typeof data === \"string\") {\r\n        condition = data;\r\n        storeName = data;\r\n    }\r\n    else {\r\n        condition = data?.el?.dataset?.[data?.datakey] || \"\";\r\n        storeName = condition;\r\n\r\n        if(!condition && data?.el?.dataset?.[`${ATTR_PREFIX}else`] !== undefined) {\r\n            condition = \"return true\";\r\n            storeName = `ELSE:${data?.el?.dataset?.[data?.datakey] || \"\"}`;\r\n        }\r\n    }\r\n\r\n    console.log(\"PARSED FUNCTION\", data, condition, storeName)\r\n\r\n    if(!condition) return {};\r\n\r\n    let [stores, fn] = condition?.split(\"=>\")?.map(s=> s.trim()) || [\"\", \"\"];\r\n    if(!fn) {\r\n        fn = stores.slice();\r\n        stores = \"\";\r\n    }\r\n\r\n    // Set up function to evaluate store values\r\n    let storeList = stores?.split(\",\")?.map(s=> s.replace(/[()]/g, \"\").trim());\r\n    // @ts-ignore\r\n    let func = globalThis[fn] || MfFn?.get(fn);\r\n\r\n    // If function is not found, try to create it; account for implicit returns\r\n    if(!func) {\r\n        if(!fn.match(/^\\s{0,}\\{/) && !fn.includes(\"return\")) fn = fn.replace(/^\\s{0,}/, \"return \");\r\n        func = new Function(...storeList, fn);\r\n    }\r\n\r\n    return { storeList, func, storeName };\r\n}","/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\nimport { ATTR_PREFIX } from \"./util.js\";\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = false;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n/** @type {HTMLElement | null} */\r\nlet spacer;\r\nlet spacerHeight = \"\";\r\n\r\n// Polyfill requestAnimationFrame\r\nlet tick = globalThis?.requestAnimationFrame || ((fn)=> setTimeout(fn, 0));\r\n\r\nexport function _addToNextTickQueue(fn) {\r\n    if(fn) _nextTickQueue.push(fn);\r\n}\r\n\r\n/** @export @param {(DomWorkOrder | Function)} update */\r\nexport function _scheduleUpdate(update) {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = true;\r\n        tick(_runUpdates);\r\n    }\r\n}\r\n\r\nfunction _addSpacer(inEl, wrapper, wrapperHeight, replaceWholeObject = false, ops) {\r\n    if(!ops.trans?.smartTransition ?? true) return;\r\n    //Conserve parent size\r\n    spacer = document.createElement(\"div\");\r\n    \r\n    let { paddingTop, paddingBottom } = wrapper instanceof Element ? window.getComputedStyle(wrapper) : { paddingTop: 0, paddingBottom: 0 };\r\n    spacerHeight = spacer.style.height = `calc(${(Math.abs(wrapperHeight - (inEl?.clientHeight || 0)))}px - ${paddingTop} - ${paddingBottom})`;\r\n\r\n    wrapper?.after(spacer);\r\n}\r\n\r\nfunction _adjustSizing(inEl, ops) {\r\n    if(!ops.trans?.smartTransition ?? true) return;\r\n    let dur = (ops?.trans?.dur?.[0] || ops?.trans?.dur || 600)/2\r\n\r\n    _scheduleUpdate(()=> {\r\n        spacer?.remove();\r\n        inEl?.animate?.([\r\n            { height: spacerHeight },\r\n            { height: `${inEl.clientHeight || 0}px` }\r\n        ], dur);\r\n    });\r\n}\r\n\r\nfunction _runUpdates() {\r\n    cancelAnimationFrame = false;\r\n    \r\n    /**\r\n    * @type {DomWorkOrder[]}\r\n    */\r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") (/** @type {Function} */ order)();\r\n        else {\r\n            let wrapperHeight = order.out ? order.out.clientHeight : 0;\r\n\r\n            // Prepend\r\n            if(order.relation == \"prepend\") {\r\n                _addSpacer?.(order.in, order.out, wrapperHeight, false, order.ops);\r\n\r\n                //Prepend\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) order.out?.prepend(order.in);\r\n                    _adjustSizing?.(order.in, order.ops);\r\n                });\r\n            }\r\n            // Remove old children\r\n            else {\r\n                if([\"swapinner\", \"swapouter\"].includes(order.relation)) {\r\n                    //Remove old children before appending (if swapping children)\r\n                    let container = /** @type {HTMLElement | null}*/(order.out?.cloneNode(true));\r\n\r\n                    if(container) {\r\n                        order.out?.after(container);\r\n                        let getDimensionsAfterUpdate = order.relation == \"swapinner\" ? true : false;\r\n\r\n                        if(order.relation == \"swapinner\") {\r\n                            container.style.border = \"none\";\r\n                            order.out.replaceChildren();\r\n                        }\r\n\r\n                        // Transition old children out\r\n                        _applyTransition(container, \"out\", order.ops, undefined, order.out, getDimensionsAfterUpdate);\r\n                    }\r\n                }\r\n\r\n                _addSpacer?.(order.in, order.out, wrapperHeight, false, order.ops);\r\n\r\n                // Transition incoming element and append\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) {\r\n                        if(order.relation == \"swapouter\") order.out?.replaceWith(order.in)\r\n                        else order.out?.appendChild(order.in);\r\n                    }\r\n                    _adjustSizing?.(order.in, order.ops);\r\n                });\r\n            }\r\n\r\n            order.done?.(order.in);\r\n        }\r\n    }\r\n\r\n    //Handle queued nextTick functions\r\n    for(let fn of _nextTickQueue) fn();\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @param {HTMLElement} [refElement]\r\n * @param {boolean} [getDimensionsAfterUpdate]\r\n * @returns \r\n */\r\nexport function _applyTransition(el, dir, ops, fn, refElement, getDimensionsAfterUpdate = false) {\r\n    //Handle text nodes\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        let text = el.textContent;\r\n        let newNode = document?.createElement(\"div\");\r\n        newNode.textContent = text;\r\n        el.replaceWith(newNode);\r\n        el = newNode;\r\n    }\r\n\r\n    if(el) {\r\n        let dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n\r\n        //Initiate transition\r\n        let transClass = ops?.trans?.class || `${ATTR_PREFIX}trans`;\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        //Wait to apply class\r\n        if(dir == \"out\") {\r\n            // Set dimensions\r\n            if(!refElement) refElement = el;\r\n            if(!refElement) return;\r\n            let dimensions = {};\r\n            if((ops.trans?.smartTransition ?? true) && getDimensionsAfterUpdate == false) {\r\n                let style = getComputedStyle(refElement);\r\n                dimensions.w = `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`;\r\n                dimensions.left = `calc(${refElement.getBoundingClientRect().left}px + ${window.scrollX}px)`;\r\n                dimensions.top = `calc(${refElement.getBoundingClientRect().top}px + ${window.scrollY}px)`;\r\n            }\r\n\r\n            _scheduleUpdate(()=> {\r\n                if(ops.trans?.smartTransition ?? true) {\r\n                    if(getDimensionsAfterUpdate && refElement) {\r\n                        let style = getComputedStyle(refElement);\r\n                        dimensions.w = `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`;\r\n                        dimensions.left = `calc(${refElement.getBoundingClientRect().left}px + ${window.scrollX}px)`;\r\n                        dimensions.top = `calc(${refElement.getBoundingClientRect().top}px + ${window.scrollY}px)`;\r\n                    }\r\n                    \r\n                    el.style.position = \"fixed\";\r\n                    el.style.width = dimensions.w;\r\n                    el.style.left = dimensions.left;\r\n                    el.style.top = dimensions.top;\r\n                    el.style.margin = \"0\";\r\n                }\r\n\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                el.classList?.add(\"out\");\r\n            })\r\n        }\r\n        //If dir == in\r\n        else {\r\n            el?.classList?.add(\"in\");\r\n            if(dur) el.style.transitionDuration = `${dur}ms`;\r\n            fn?.();\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    setTimeout(()=> _scheduleUpdate(()=> el?.classList?.remove(dir)), 0);\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                //Wrapup\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}","/** \r\n * @template T\r\n * @typedef {import(\"./index.module.js\").UpdaterFunction<T>} UpdaterFunction \r\n */\r\n/** \r\n * @template T\r\n * @typedef {import(\"./index.module.js\").StoreOptions<T>} StoreOptions \r\n */\r\n\r\nimport { _scheduleUpdate } from \"./updates.js\";\r\n\r\n/**\r\n * @callback SubFunction\r\n * @param {any} value\r\n * @param {string} [ref]\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * @param {any} input \r\n * @returns {any}\r\n */\r\nfunction _hashAny(input) {\r\n    if(!input) return 0;\r\n    if(typeof input == 'number') return input;\r\n    if(input === true) return 1;\r\n\r\n    if(input instanceof Map) return _hashAny(Array.from(input.entries()));\r\n    else if(input instanceof Set) return _hashAny(Array.from(input));\r\n\r\n    let hash = 0;\r\n    for(let char of new TextEncoder().encode(\r\n        typeof input == 'string' ? input : input?.toString() || \"\"\r\n    )) \r\n        hash = ((hash << 5) - hash) + char;\r\n    return hash;\r\n}\r\n\r\n//Static\r\n/** @type {Map<string, Store<any>>} */ if(!globalThis.MfSt) globalThis.MfSt = new Map();\r\n/** @type {Map<string, Function>} */ if(!globalThis.MfFn) globalThis.MfFn = new Map();\r\n\r\n/**\r\n * @template T\r\n */\r\nexport class Store {\r\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\r\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\r\n    /** @type {string | undefined} */ _storedHash = undefined;\r\n    /** @type {Set<Store<any>>} */ _upstreamStores = new Set();\r\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    constructor(name, ops) {\r\n        return this._modify(name, ops);        \r\n    }\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    _modify(name, ops) {\r\n        this.name = name;\r\n        // @ts-ignore\r\n        MfSt.set(name, this);\r\n        \r\n        (ops?.upstream?.map(s=> {\r\n            let S = _store(s);\r\n            this._upstreamStores.add(S);\r\n            S._downstreamStores.add(this);\r\n            return S;\r\n        }) || []);\r\n\r\n        this.value = ops?.value;\r\n        this._updater = ops?.updater;\r\n        this._auto_update();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {(T)=> void} sub\r\n     * @param {string | undefined} [ref]\r\n     * @param {boolean} [immediate]\r\n     */\r\n    sub(sub, ref, immediate = true) {\r\n        this._subscriptions.set(ref || String(Date.now() + Math.random()), sub);\r\n        if(immediate) sub?.(this.value);\r\n    }\r\n\r\n    //Update (manual or automated -- cascades downstream on batch updates)\r\n    /**\r\n    * @template T\r\n    * @param {T | ((T)=> T | Promise<T>)} value\r\n    */\r\n    async update(value) {\r\n        return new Promise(async (resolve)=> {\r\n            //Apply new value   \r\n            let newValue = (typeof value == \"function\" ? /** @type {Function} */(await value)?.(this.value) : value);\r\n            let newHash = _hashAny(newValue);\r\n            \r\n            if(newHash !== this._storedHash) {\r\n                this.value = newValue;\r\n                this._storedHash = newHash;\r\n\r\n                // Add this store to the work order\r\n                for(let ds of this._downstreamStores) await ds._auto_update();\r\n\r\n                // Wait for next animation frame to return the value\r\n                _scheduleUpdate(()=> {\r\n                    for(let [ref, sub] of this?._subscriptions || []) sub?.(this.value, ref);\r\n                    resolve(this.value);\r\n                });\r\n            }\r\n            else resolve(this.value);\r\n        });\r\n    }\r\n\r\n    async clearHash() {\r\n        this._storedHash = undefined;\r\n    }\r\n\r\n    async _auto_update() {\r\n        let newVal = await this._updater?.(\r\n            Array.from(this._upstreamStores)?.map(S => S?.value) || [], \r\n            /** @type {T} */(this?.value)\r\n        );\r\n\r\n        await this.update(newVal === undefined ? this.value : newVal);\r\n    }\r\n}\r\n\r\n/**\r\n * STORE STATIC METHODS\r\n */\r\n/**\r\n * @template T\r\n * @param {string} name - The name of the store\r\n * @param {StoreOptions<T> | T} [ops] - Options to update the store\r\n * @returns {Store<T>}\r\n */\r\nexport function _store(name, ops) {\r\n    // @ts-ignore\r\n    let found_store = MfSt.get(name);\r\n    if(ops) {\r\n        if(found_store) {\r\n            return found_store._modify(name, ops);\r\n        }\r\n        return new Store(name, ops);\r\n    }\r\n    return found_store || new Store(name, /** @type {StoreOptions<T>}*/(ops));\r\n}","import { _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _registerSubs } from \"./registrar.js\";\r\nimport { _store } from \"./store.js\";\r\n\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {string} trigger \r\n * @param {MfldOps} fetchOps\r\n * @param {string} href\r\n * @param {string} [method] \r\n * @param {any} [input]\r\n * @param {Function} [processFunc]\r\n */\r\nexport function _handleFetch(el, trigger, fetchOps, href, method, input, processFunc) {\r\n    /**\r\n     * @param {Event} [e]\r\n     */\r\n    let ev = async e=> {  \r\n        e?.preventDefault();\r\n        e?.stopPropagation();\r\n\r\n        // Set from target element if relevant; fall back to \"get\"\r\n        if(!method) method = /** @type {any}*/(e?.target)?.method || \"get\";\r\n    \r\n        //Make sure we're allowed to fetch\r\n        let externalPermissions = fetchOps?.fetch?.externals?.find(allowed=> href?.startsWith(allowed.domain)) || \r\n            !href.match(/^https?:\\/\\//) || href.includes(location.origin) ? {\r\n                scripts: true,\r\n                styles: true,\r\n        } : undefined;\r\n\r\n        // Parse input\r\n        let body = Array.isArray(input) ? input[0] : input == \"$form\" ? new FormData(/** @type {HTMLFormElement}*/(el)) : input;\r\n        if(processFunc) {\r\n            let toFunc = Array.isArray(input) ? (input?.map(s=> _store(s).value) || []) : [body];\r\n            body = processFunc?.(...toFunc)\r\n        }\r\n\r\n        //Fetch data\r\n        let data = await fetch(href, {\r\n            ...(fetchOps?.fetch?.request || {}),\r\n            headers: {\r\n                ...fetchOps?.fetch?.request?.headers,\r\n                \"Manifold-App-Fetch\": \"true\",\r\n            },\r\n            method,\r\n            body: input == \"$form\" || typeof body == \"string\" ? body : JSON.stringify(body),\r\n        })\r\n        .catch(error=> {\r\n            fetchOps?.fetch?.err?.(error) || console.error(\"FETCH ERROR\", error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fetchOps?.fetch?.onCode?.(code, data) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let resp = await data?.[fetchOps?.fetch?.responseType || \"text\"]();\r\n\r\n        // Handle resolutions\r\n        for(let instruction of [\"append\", \"prepend\", \"swapinner\", \"swapouter\"]) {\r\n            let ds = el.dataset[`${ATTR_PREFIX}${instruction}`];\r\n            if(ds === undefined) continue;\r\n            let [selector, toReplace] = ds?.split(\"->\").map(s=> s.trim()) || [];\r\n\r\n            //Extract content and schedule a DOM update\r\n            let fullMarkup = (new DOMParser())?.parseFromString?.(resp, 'text/html');\r\n            if(fullMarkup) {\r\n                _scheduleUpdate({\r\n                    in: /** @type {HTMLElement} */ (fullMarkup.querySelector(selector || \"body\")),\r\n                    out: /** @type {HTMLElement} */ (toReplace ? document.querySelector(toReplace) : el),\r\n                    relation: /** @type {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"}*/(instruction),\r\n                    ops: fetchOps,\r\n                    done: (el)=> {\r\n                        _registerSubs(el)\r\n                    },\r\n                });\r\n            }\r\n        }\r\n\r\n        //Push to history if requested\r\n        if(el.dataset?.[`${ATTR_PREFIX}pushstate`] !== undefined) {\r\n            history.pushState({}, \"\", href);\r\n        }\r\n\r\n        let resolveTxt = el.dataset?.[`${ATTR_PREFIX}resolve`];\r\n        let resolveFunc = _parseFunction(resolveTxt || \"\")?.func;\r\n        resolveFunc?.(resp);\r\n\r\n            // //Clear existing scripts/styles\r\n            // for(let s of [pageScripts, pageStyles]) {\r\n            //     let elements = s.get(fullMarkup) || [];\r\n            //     elements.forEach(el => el.remove());\r\n            //     s.set(fullMarkup, []);\r\n            // }\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n    }\r\n\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}","import { _store } from \"./store\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _getStorePathFromKey, _inputNestSplitRx, _nestedValue, ATTR_PREFIX } from \"./util\";\r\n\r\nexport function _handleBindSync(el, input, output, trigger, mode, processFunc) {\r\n    /**\r\n     * HANDLE MF-BIND - inputs are stores, output is element property\r\n     */\r\n    if(mode == `${ATTR_PREFIX}bind`) {\r\n        let stores = input.map(_getStorePathFromKey);\r\n        let domSubscription = ()=> {\r\n            _scheduleUpdate(()=> {\r\n                let storeValues = stores.map(s=> _nestedValue(_store(s[0])?.value, s[1]));\r\n                let val = processFunc?.(...storeValues, el) ?? storeValues[0];\r\n                if(output && val !== undefined) {\r\n                    let parts = output.split(\":\");\r\n                    if(parts.length > 1) {\r\n                        switch(parts[0]) {\r\n                            case \"style\": el.style[parts[1]] = val; break;\r\n                            case \"attr\": el.setAttribute(parts[1], val); break;\r\n                            default: el[output] = val;\r\n                        }\r\n                    }\r\n                    else el[output] = val;\r\n                }\r\n\r\n                //Make sure to update dependent stores on value update\r\n                el.dispatchEvent(new CustomEvent(trigger));\r\n            });\r\n        }\r\n    \r\n        //Add subscription - run whenever store updates\r\n        for(let s of stores) _store(s?.[0]|| \"\")?.sub(domSubscription);\r\n    }\r\n\r\n    else {\r\n        /**\r\n         * HANDLE MF-SYNC - inputs are element properties, output is a store\r\n         */\r\n        if(mode == `${ATTR_PREFIX}sync`) {\r\n            let [storeName, path] = _getStorePathFromKey(output || \"\");\r\n            let ev = ()=> {\r\n                let propValues = input.map(prop=> {\r\n                    prop = prop.trim();\r\n                    let parts = prop.split(\":\");\r\n                    if(parts.length > 1) {\r\n                        switch(parts[0]) {\r\n                            case \"style\": return el.style[prop] ?? undefined;\r\n                            case \"attr\": return el.getAttribute(prop) ?? undefined;\r\n                            default: return el[prop] ?? undefined;\r\n                        }\r\n                    }\r\n                    else return el[prop] ?? undefined;\r\n                });\r\n\r\n                let value = processFunc?.(...propValues) ?? propValues[0];\r\n                \r\n                if(storeName && value !== undefined) {\r\n                    _store(storeName)?.update?.(curVal=> {\r\n                        return path?.length ? _nestedValue(curVal, path, value) : value\r\n                    });\r\n                }\r\n            }\r\n            if(trigger == \"$mount\") ev();\r\n            else el.addEventListener(trigger, ev);\r\n        }\r\n    }\r\n}","import { _registerSubs } from \"./registrar\";\r\nimport { _store } from \"./store\";\r\nimport { _applyTransition, _scheduleUpdate } from \"./updates\";\r\nimport { _getStorePathFromKey, _parseFunction, ATTR_PREFIX } from \"./util\";\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n * @returns {HTMLElement}\r\n */\r\nfunction _ensureTemplate(el) {\r\n    // Make sure this is a template\r\n    if(el.tagName != \"TEMPLATE\") {\r\n        let newEl = document.createElement(\"template\");\r\n        newEl.innerHTML = el.innerHTML;                \r\n        for(let attr of el.attributes) {\r\n            newEl.setAttribute(attr.name, attr.value);\r\n        }\r\n        el.replaceWith(newEl);\r\n\r\n        // If not, it's default content\r\n        return newEl;\r\n    }\r\n    return el;\r\n}\r\n\r\n/**\r\n * @param {any} obj \r\n * @param {(value: any, index: any, array?: any)=> void} cb \r\n */\r\nfunction _iterable(obj, cb) {\r\n    if(obj instanceof Map) for(const [key, value] of obj.entries()) cb(key, value);\r\n    else {\r\n        try { \r\n            let arr = Array.from(obj);\r\n            if(arr?.length) arr.forEach(cb);\r\n            else for(let key in obj) cb(key, obj[key]);\r\n        }\r\n        catch(e) { console.error(`${obj} is not iterable`); }\r\n    }\r\n}\r\n\r\n// Returns the sibling that fails the condition\r\n/**\r\n * @param {HTMLElement | null} [sib] \r\n * @param {Function} [breakFn] \r\n * @param {Function} [cb] \r\n * @returns {HTMLElement | null}\r\n */\r\nfunction _iterateSiblings(sib, breakFn, cb) {\r\n    if(breakFn(sib)) return sib;\r\n    sib = cb?.(sib) || sib;\r\n    return _iterateSiblings(sib?.nextElementSibling, breakFn, cb);\r\n}\r\n\r\n/**\r\n * @param {string} [storeName] \r\n * @param {string[]} [storeList] \r\n * @param {any[]} [conditionChain] \r\n * @param {number} [upstreamConditionsLen] \r\n * @param {Function} [func] \r\n * @returns \r\n */\r\nfunction _registerConditionStore(storeName, storeList, conditionChain, upstreamConditionsLen, func) {\r\n    // Register new store (to prevent excess evaluations)\r\n    return _store(storeName || \"\", {\r\n        upstream: [...storeList || [], ...conditionChain || []],\r\n        updater: (list)=> {\r\n            if(upstreamConditionsLen) {\r\n                for(let condition of list.slice(storeList?.length || 0) || []) {\r\n                    if(condition) return false;\r\n                }\r\n            }\r\n            let res = func?.(...list);\r\n            if(res) for(let condition of conditionChain || []) {\r\n                console.log(\"Clearing condition for\", condition)\r\n                _store(condition)?.clearHash?.();\r\n            }\r\n            return res;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Handle conditional and loop elements\r\n * @param {HTMLElement} el \r\n * @param {string} mode \r\n * @param {import(\"./index.module\").MfldOps} ops \r\n */\r\nexport function _handleConditionals(el, mode, ops) {\r\n    let startElement = document.createElement(\"template\");\r\n    let endElement = document.createElement(\"template\");\r\n    startElement.classList.add(\"mfld-start\");\r\n    endElement.classList.add(\"mfld-end\");\r\n    el.before(startElement);\r\n\r\n    if(mode == `${ATTR_PREFIX}if`) {\r\n        // Set up conditions\r\n        let conditionChain = [];\r\n        let upstreamConditionsLen = conditionChain.length;\r\n\r\n        // Iterate siblings to add implicit else\r\n        let breakSibling = _iterateSiblings(\r\n            startElement?.nextElementSibling,\r\n            (sib)=> sib?.dataset[`${ATTR_PREFIX}if`] == undefined && sib?.dataset[`${ATTR_PREFIX}elseif`] == undefined && sib?.dataset[`${ATTR_PREFIX}else`] == undefined,\r\n        );\r\n\r\n        if(breakSibling?.previousElementSibling?.dataset[`${ATTR_PREFIX}else`] == undefined) {\r\n            // Register implicit else\r\n            let implElse = document.createElement(\"template\");\r\n            implElse.dataset[`${ATTR_PREFIX}else`] = \"()=> true\";\r\n            implElse.innerHTML = \"<div>VISIBLE IF NO CONDITIONS</div>\"\r\n            sib.after(implElse);\r\n        }\r\n        \r\n        // Iterate siblings to get condition branches\r\n        _iterateSiblings(\r\n            startElement?.nextElementSibling,\r\n            (sib)=> {\r\n                let end = 0;\r\n                for(let i of [\"if\", \"elseif\", \"else\"]) if(sib?.dataset[`${ATTR_PREFIX}${i}`] == undefined) end++;\r\n                if(end < 3) return false;\r\n                sib?.before(endElement);\r\n                return true;\r\n            },\r\n            (sib)=> {\r\n                let { storeList, func, storeName } = _parseFunction({\r\n                    el: sib, \r\n                    datakey: conditionChain.length ? sib.dataset?.[`${ATTR_PREFIX}elseif`] ? `${ATTR_PREFIX}elseif` : `${ATTR_PREFIX}else` : mode\r\n                });\r\n                if(!storeList && !func) {\r\n                    console.error(\"Early condition abort on\", storeName, sib);\r\n                    return;\r\n                }\r\n    \r\n                // Ensure template\r\n                sib = _ensureTemplate(sib);\r\n    \r\n                // Register condition store\r\n                let conditionStore = _registerConditionStore(storeName, storeList, conditionChain, upstreamConditionsLen, func);\r\n                conditionChain.push(conditionStore.name);\r\n    \r\n                // Subscribe\r\n                conditionStore?.sub(val=> {\r\n                    if(!val) {\r\n                        return;\r\n                    }\r\n    \r\n                    _scheduleUpdate(()=> {\r\n                        _iterateSiblings(\r\n                            startElement?.nextElementSibling, \r\n                            (sib)=> sib?.classList?.contains(\"mfld-end\"),\r\n                            (sib)=> { \r\n                                if(sib?.nodeName != \"TEMPLATE\") _applyTransition(/** @type {HTMLElement}*/(sib), \"out\", ops, ()=> sib?.remove()); \r\n                            }\r\n                        );\r\n                    });\r\n    \r\n                    // Replace values\r\n                    _scheduleUpdate(()=> {\r\n                        let sibClone = sib.cloneNode(true);\r\n                        for(let element of /** @type {HTMLTemplateElement}*/(sibClone).content.children) {\r\n                            endElement.before(element);\r\n                            _applyTransition(/** @type {HTMLElement}*/(element), \"in\", ops, ()=> _registerSubs(/** @type {HTMLElement}*/(element)));\r\n                        }\r\n                    });\r\n                });  \r\n                \r\n                return sib;\r\n            },\r\n        );\r\n    }\r\n\r\n    if(mode == `${ATTR_PREFIX}each`) {\r\n        el.before(endElement);\r\n\r\n        let [ funcStr, aliases ] = el.dataset[`${ATTR_PREFIX}each`]?.split(\"as\")?.map(s=> s.trim()) || [];\r\n        let [ valueName, keyName ] = aliases.split(/\\s{0,},\\s{0,}/)?.map(s=> s.trim()) || [\"value\", \"key\"];\r\n        let { storeList, func, storeName } = _parseFunction(funcStr);  \r\n        \r\n        // Ensure template\r\n        el = _ensureTemplate(el);\r\n\r\n        // Register condition store\r\n        let conditionStore = _registerConditionStore(`LOOP:${storeName}`, storeList, [], 0, func);\r\n        conditionStore?.sub(val=> {\r\n            _scheduleUpdate(()=> {\r\n                _iterateSiblings(\r\n                    startElement?.nextElementSibling, \r\n                    (sib)=> sib?.classList?.contains(\"mfld-end\"),\r\n                    (sib)=> _applyTransition(/** @type {HTMLElement}*/(sib), \"out\", ops, ()=> sib?.remove()), \r\n                );\r\n            });\r\n            _scheduleUpdate(()=> {\r\n                _iterable(val || [], (key, value)=> {\r\n                    let html = el.innerHTML;\r\n\r\n                    // Get all logical bindings and replace values\r\n                    let replacements = el.innerHTML.match(/\\${[^}]*}/g) || [];\r\n                    for(let rep of replacements) {\r\n                        let repClean = rep.replace(/^\\$\\{|\\}$/g, \"\");\r\n\r\n                        try {\r\n                            let fn = _parseFunction(`(${keyName}, ${valueName})=> ${repClean}`)?.func;\r\n                            html = html.replace(rep, fn?.(value, key) || \"\");\r\n                        }\r\n                        catch(e) {\r\n                            console.error(\"Syntax error in loop function\", e);\r\n                        }\r\n                    }\r\n\r\n                    let item = /** @type {HTMLTemplateElement}*/(el.cloneNode(true));\r\n                    item.innerHTML = html;\r\n\r\n                    // Replace values\r\n                    for(let element of item.content.children) {\r\n                        endElement.before(element);\r\n                        _applyTransition(/** @type {HTMLElement}*/(element), \"in\", ops, ()=> _registerSubs(/** @type {HTMLElement}*/(element)));\r\n                    }\r\n                });\r\n            });\r\n        })\r\n    }\r\n}","import { _store } from \"./store.js\";\r\nimport { _scheduleUpdate } from \"./updates.js\";\r\nimport { _getOpOverrides, _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _handleFetch } from \"./fetch.js\";\r\nimport { _handleBindSync } from \"./bindsync.js\";\r\nimport { _handleConditionals } from \"./conditionals.js\";\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/** @type {Partial<MfldOps>} */\r\nlet _ops = {};\r\nlet _commaSepRx = /, {0,}/g;\r\nlet _modes = [\"bind\", \"sync\", \"if\", \"each\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\"].map(m=> `${ATTR_PREFIX}${m}`);\r\n\r\n/**!\r\n * @param {Partial<MfldOps>} newops \r\n * @param {string} [profileName] \r\n */\r\nexport function _setOptions(newops, profileName) {\r\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\r\n    else _ops = { ..._ops, ...newops };\r\n}\r\n\r\n// Handle location state changes\r\nglobalThis.addEventListener(\"popstate\", (e)=> {\r\n    // for(let update of e.state) {\r\n    //     _scheduleUpdate(update);\r\n    // }\r\n});\r\n\r\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\r\n/**\r\n * @param {HTMLElement | null} [parent] \r\n */\r\nexport function _registerSubs(parent) {\r\n    if(parent && parent.nodeType == Node.TEXT_NODE) return;\r\n    \r\n    /** @type {NodeListOf<HTMLElement> | []} */\r\n    let els = (parent || document.body).querySelectorAll(\r\n        `[data-${_modes.join(`],[data-`)}],a,form`\r\n    ) || [];\r\n\r\n    for(let el of els) {\r\n        let _op_overrides = _getOpOverrides(_ops, el);\r\n\r\n        //Check for <a> and <form> elements\r\n        if(el.dataset?.[`${ATTR_PREFIX}promote`] !== undefined) {\r\n            let [mode, href, input, trigger] = el.tagName == \"A\" ?\r\n                [\"get\", /** @type {HTMLAnchorElement}*/(el).href, \"\", \"click\"] : \r\n                [/** @type {HTMLFormElement}*/(el).method.toLowerCase(), /** @type {HTMLFormElement}*/(el).action, \"$form\", \"submit\"];\r\n\r\n            if(href) {\r\n                _handleFetch(el, trigger, _op_overrides, href, mode, input);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        //Loop over all data attributes (modes)\r\n        for(let mode in el.dataset) {\r\n            //HANDLE CONDITIONALS AND LOOPS\r\n            if([`${ATTR_PREFIX}if`, `${ATTR_PREFIX}each`].includes(mode)) {\r\n                _handleConditionals(el, mode, _op_overrides);\r\n                continue;\r\n            }\r\n\r\n            if(!_modes.includes(mode)) continue;\r\n            let shouldHaveTriggers = ![`${ATTR_PREFIX}bind`].includes(mode);\r\n\r\n            //Loop over provided settings\r\n            for(let setting of el.dataset?.[mode]?.split(\";\") || []) {\r\n                //Break out settings\r\n                let [sourceParts, output] = setting?.split(\"->\")?.map(s=> s.trim()) || [];\r\n                let triggers = shouldHaveTriggers ? _paramsInParens(sourceParts.slice(0, sourceParts.indexOf(\")\"))) : [];\r\n                let funcAndInput = shouldHaveTriggers ? sourceParts.slice(sourceParts.indexOf(\")\") + 1) : sourceParts;\r\n                let processFuncName = funcAndInput.includes(\"=>\") ? funcAndInput : funcAndInput.includes(\"(\") ? funcAndInput.match(/^[^\\(]{1,}/)?.[0] || \"\" : \"\";\r\n                let input = processFuncName ? _paramsInParens(funcAndInput.slice(0, (funcAndInput.indexOf(\")\") || -2) + 1)) : funcAndInput.split(_commaSepRx)?.map(s=> s.trim());\r\n\r\n                //Handle errors\r\n                if(shouldHaveTriggers && !triggers?.length) { console.error(\"No trigger\", el); break; }\r\n\r\n                /** @type {Function | undefined} */\r\n                let processFunc = _parseFunction(processFuncName)?.func;\r\n                if(processFuncName) {\r\n                    if(!processFunc) console.warn(`\"${processFuncName}\" not registered`, el);\r\n                }\r\n                else if(input.length > 1) console.warn(\"Multiple inputs without function\", el);\r\n\r\n                //Loop over triggers\r\n                if(!triggers?.length) triggers = [\"\"]\r\n                for(let trigger of triggers) {\r\n                    if(mode.match(/bind|sync/)) _handleBindSync(el, input, output, trigger, mode, processFunc);\r\n                    else {\r\n                        if(!output) {\r\n                            output = input[0];\r\n                            input = [];\r\n                        }\r\n                        _handleFetch(el, trigger, _op_overrides, output, mode.replace(ATTR_PREFIX, \"\"), input, processFunc);\r\n                    }\r\n                }\r\n            }; //End loop settings\r\n        }   //End loop dataset modes\r\n    };  //End loop elements\r\n}\r\n\r\n/**\r\n * @param {string} str \r\n * @returns \r\n */\r\nfunction _paramsInParens(str) {\r\n    if(str?.includes(\"(\")) {\r\n        let matches = str.match(/[^\\(\\)]{1,}/g);\r\n        str = matches?.[matches.length - 1] || \"\";\r\n    }\r\n    return str?.split(_commaSepRx)?.map(s=> s.trim()) || [];\r\n}","import { _store } from \"./store.js\";\r\nimport { _addToNextTickQueue } from \"./updates.js\";\r\nimport { _registerSubs, _setOptions } from \"./registrar.js\";\r\n\r\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\r\n\r\n/**!\r\n * @typedef {object} ExternalOptions\r\n * @property {string} domain - The domain name these settings apply to\r\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\r\n * @property {boolean} [styles] - Allow styles from this domain to apply\r\n */\r\n\r\n/**!\r\n * @typedef {object} FetchOptions\r\n * @property {RequestInit} [request] - Fetch request options\r\n * @property {\"json\"|\"text\"} [responseType] - Response type (default: \"text\")\r\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\r\n * @property {(code: number, data: void | Response)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\r\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\r\n */\r\n\r\n/**!\r\n * @typedef {object} TransitionOptions\r\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\r\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\r\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\r\n * @property {boolean} [smartTransition] - Enable smart transitions (default: true)\r\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\r\n */\r\n\r\n/**!\r\n * Manifold options for `fetch`, `trans`, and `profiles`.\r\n * @typedef {Object} MfldOps\r\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\r\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\r\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback UpdaterFunction\r\n * @param {Array<any>} upstreamValues\r\n * @param {T} value\r\n * @returns {T | Promise<T>}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback ValueDeterminer\r\n * @param {T} [currentValue]\r\n * @returns {T | Promise<T> | undefined}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback UpdateFunction\r\n * @param {T | ValueDeterminer<T>} value\r\n * @returns {T | Promise<T> | undefined}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback SubDeterminer\r\n * @param {T} value\r\n * @returns {void}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback SubFunction\r\n * @param {SubDeterminer<T>} value The store's current value\r\n * @returns void\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef {Object} StoreOptions\r\n * @property {T} [value]\r\n * @property {Array<string>} [upstream]\r\n * @property {UpdaterFunction<T>} [updater]\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef Store\r\n * @prop {T} value - The store's current value (read only)\r\n * @prop {UpdateFunction<T>} update - Update the store's current value\r\n * @prop {SubFunction<T>} sub - Add a subscription function to the store\r\n */\r\n\r\n/**!\r\n * @typedef {Function} MfldFunc\r\n * @param {any} val\r\n * @param {HTMLElement} [el]\r\n */\r\n\r\n/**!\r\n * The global Manifold interface.\r\n */\r\nexport let Mfld = {\r\nstore: \r\n/**!\r\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @template T\r\n* @param {string} store_name\r\n* @param {StoreOptions<T> | T} store_ops\r\n* @return {Store<T>}\r\n*/ (store_name, store_ops)=> {\r\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\r\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\r\n    }\r\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\r\n},\r\nustore: \r\n/**!\r\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @param {string} store_name\r\n* @param {StoreOptions<any> | any} store_ops\r\n* @return {Store<any>}\r\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\r\nget:\r\n/**!\r\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\r\n * @param {string} store_name\r\n * @return {Store<any>}\r\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\r\nfunc: \r\n/**!\r\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\r\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\r\n * @param {string} func_name\r\n * @return {MfldFunc}\r\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(\r\n// @ts-ignore\r\n MfFn?.get(func_name)),\r\nfuncs: \r\n/**!\r\n * - Add functions to the Manifold function registry in key-value pairs.\r\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \r\n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\r\n * @param {{ [key: string]: MfldFunc }} funcs\r\n */ funcs=> {for(let key in funcs) \r\n// @ts-ignore\r\n MfFn.set(key, funcs[key])},\r\nconfig:\r\n/**!\r\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\r\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\r\n * @param {MfldOps} new_ops\r\n * @param {string} [profile_name]\r\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\r\n onTick:\r\n /**!\r\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\r\n  * @param {()=> void} cb\r\n  */ (cb)=> _addToNextTickQueue(cb),\r\nregister:\r\n/**!\r\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\r\n * @param {HTMLElement | string | null} [parent]\r\n */ (parent)=> {\r\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\r\n        _registerSubs(parent)\r\n    },\r\n};"],"names":["ATTR_PREFIX","_inputNestSplitRx","_nestedValue","obj","path","newval","ptr","key","undefined","length","Map","get","set","_getStorePathFromKey","s","storeName","split","map","sp","isNaN","parseInt","filter","_getOverride","name","el","ops","parse","def","as","override","dataset","profiles","fetch","JSON","_getOpOverrides","overrides","responseType","trans","dur","swap","class","smartTransition","_parseFunction","data","condition","datakey","console","log","stores","fn","trim","slice","storeList","replace","func","globalThis","MfFn","match","includes","Function","spacer","workArray","cancelAnimationFrame","_nextTickQueue","spacerHeight","tick","requestAnimationFrame","setTimeout","_scheduleUpdate","update","push","_runUpdates","_addSpacer","inEl","wrapper","wrapperHeight","replaceWholeObject","document","createElement","paddingTop","paddingBottom","Element","window","getComputedStyle","style","height","Math","abs","clientHeight","after","_adjustSizing","remove","animate","order","out","relation","in","_applyTransition","prepend","container","cloneNode","getDimensionsAfterUpdate","border","replaceChildren","replaceWith","appendChild","done","dir","refElement","nodeType","Node","TEXT_NODE","text","textContent","newNode","Array","isArray","transClass","classList","add","hooks","dimensions","w","clientWidth","paddingLeft","paddingRight","left","getBoundingClientRect","scrollX","top","scrollY","position","width","margin","transitionDuration","_hashAny","input","from","entries","Set","hash","char","TextEncoder","encode","toString","MfSt","Store","_updater","_subscriptions","_storedHash","_upstreamStores","_downstreamStores","constructor","this","_modify","upstream","S","_store","value","updater","_auto_update","sub","ref","immediate","String","Date","now","random","Promise","async","resolve","newValue","newHash","ds","clearHash","newVal","found_store","_handleFetch","trigger","fetchOps","href","method","processFunc","ev","e","preventDefault","stopPropagation","target","externals","find","allowed","startsWith","domain","location","origin","body","FormData","toFunc","request","headers","stringify","catch","error","err","code","status","onCode","resp","instruction","selector","toReplace","fullMarkup","DOMParser","parseFromString","querySelector","_registerSubs","history","pushState","resolveTxt","resolveFunc","addEventListener","_handleBindSync","output","mode","domSubscription","storeValues","val","parts","setAttribute","dispatchEvent","CustomEvent","propValues","prop","getAttribute","curVal","_ensureTemplate","tagName","newEl","innerHTML","attr","attributes","_iterateSiblings","sib","breakFn","cb","nextElementSibling","_registerConditionStore","conditionChain","upstreamConditionsLen","list","res","_handleConditionals","startElement","endElement","before","breakSibling","previousElementSibling","implElse","end","i","conditionStore","contains","nodeName","sibClone","element","content","children","funcStr","aliases","valueName","keyName","arr","forEach","_iterable","html","replacements","rep","repClean","item","_ops","_commaSepRx","_modes","m","parent","els","querySelectorAll","join","_op_overrides","toLowerCase","action","shouldHaveTriggers","setting","sourceParts","triggers","_paramsInParens","indexOf","funcAndInput","processFuncName","warn","str","matches","Mfld","store","store_name","store_ops","hasOwnProperty","ustore","func_name","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register"],"mappings":"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"}