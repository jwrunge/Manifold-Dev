{"version":3,"file":"mfld.mod.js","sources":["../../src/updates.js","../../src/store.js","../../src/http.js","../../src/exports.js","../../src/fetch.js","../../src/registrar.js","../../src/index.module.js"],"sourcesContent":["/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = false;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n/** @type {HTMLElement | null} */\r\nlet spacer;\r\nlet spacerHeight = \"\";\r\n\r\n// Polyfill requestAnimationFrame\r\nlet tick = globalThis?.requestAnimationFrame || ((fn)=> setTimeout(fn, 0));\r\n\r\nexport function _addToNextTickQueue(fn) {\r\n    if(fn) _nextTickQueue.push(fn);\r\n}\r\n\r\n/** @export @param {(DomWorkOrder | Function)} update */\r\nexport function _scheduleUpdate(update) {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = true;\r\n        tick(_runUpdates);\r\n    }\r\n}\r\n\r\nfunction _addSpacer(inEl, wrapper, wrapperHeight) {\r\n    //Conserve parent size\r\n    spacer = document.createElement(\"div\");\r\n    let { paddingTop, paddingBottom } = wrapper instanceof Element ? window.getComputedStyle(wrapper) : { paddingTop: 0, paddingBottom: 0 };\r\n\r\n    spacerHeight = spacer.style.height = `calc(${(Math.abs(wrapperHeight - (inEl?.clientHeight || 0)))}px - ${paddingTop} - ${paddingBottom})`;\r\n    wrapper?.after(spacer);\r\n}\r\n\r\nfunction _adjustSizing(inEl) {\r\n    _scheduleUpdate(()=> {\r\n        spacer?.remove();\r\n        inEl?.animate?.([\r\n            { height: spacerHeight },\r\n            { height: `${inEl.clientHeight || 0}px` }\r\n        ], 300);\r\n    });\r\n}\r\n\r\nfunction _runUpdates() {\r\n    cancelAnimationFrame = false;\r\n    \r\n    /**\r\n    * @type {DomWorkOrder[]}\r\n    */\r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") (/** @type {Function} */ order)();\r\n        else {\r\n            let wrapperHeight = order.out ? order.out.clientHeight : 0;\r\n\r\n            // Remove old children\r\n            if([\"swapinner\", \"append\"].includes(order.relation)) {\r\n                if(order.relation == \"swapinner\") {\r\n                    //Remove old children before appending (if swapping children)\r\n                    let container = document?.createElement(\"div\");\r\n                    for(let child of Array.from(order.out?.childNodes || [])) {\r\n                        container.appendChild(child);\r\n                    }\r\n                    order.out?.replaceChildren(container);\r\n\r\n                    // Transition old children out\r\n                    _applyTransition(container, \"out\", order.ops);\r\n                }\r\n\r\n                _addSpacer?.(order.in, order.out, wrapperHeight);\r\n\r\n                // Transition incoming element and append\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) order.out?.appendChild(order.in);\r\n                    _adjustSizing?.(order.in);\r\n                });\r\n            }\r\n            //Prepend\r\n            else if(order.relation == \"prepend\") {\r\n                _addSpacer?.(order.in, order.out, wrapperHeight);\r\n\r\n                //Prepend\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) order.out?.prepend(order.in);\r\n                    _adjustSizing?.(order.in);\r\n                });\r\n            }\r\n            //Insert after old element before removing\r\n            else {\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    order.out?.after(order.in);\r\n                    _addSpacer?.(order.in, order.out, wrapperHeight);\r\n                    _adjustSizing?.(order.in);\r\n                });\r\n                _applyTransition(order.out, \"out\", order.ops);\r\n            }\r\n\r\n            order.done?.(order.in);\r\n        }\r\n    }\r\n\r\n    //Handle queued nextTick functions\r\n    _nextTickQueue.forEach(fn=> fn());\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @returns \r\n */\r\nfunction _applyTransition(el, dir, ops, fn) {\r\n    //Handle text nodes\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        let text = el.textContent;\r\n        let newNode = document?.createElement(\"div\");\r\n        newNode.textContent = text;\r\n        el.replaceWith(newNode);\r\n        el = newNode;\r\n    }\r\n\r\n    if(el) {\r\n        let dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n\r\n        //Initiate transition\r\n        let transClass = ops?.trans?.class || \"mf-trans\";\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        //Wait to apply class\r\n        if(dir == \"out\") {\r\n            _scheduleUpdate(()=> {\r\n                if(true) {\r\n                    el.style.width = `${(el).clientWidth}px`;\r\n                    el.style.height = `${(el).clientHeight}px`;\r\n                    el.style.position = \"absolute\";\r\n                }\r\n\r\n                // smartOutro?.size?.(el);\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                el.classList?.add(\"out\");\r\n            })\r\n        }\r\n        //If dir == in\r\n        else {\r\n            el?.classList?.add(\"in\");\r\n            if(dur) el.style.transitionDuration = `${dur}ms`;\r\n            fn?.();\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    setTimeout(()=> _scheduleUpdate(()=> el?.classList?.remove(dir)), 0);\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                //Wrapup\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}","/** \n * @template T\n * @typedef {import(\"./index.module.js\").UpdaterFunction<T>} UpdaterFunction \n */\n/** \n * @template T\n * @typedef {import(\"./index.module.js\").StoreOptions<T>} StoreOptions \n */\n\nimport { _scheduleUpdate } from \"./updates.js\";\n\n/**\n * @callback SubFunction\n * @param {any} value\n * @param {string} [ref]\n * @returns {void}\n */\n\n/**\n * @param {any} input \n * @returns {any}\n */\nfunction _hashAny(input) {\n    if(!input) return 0;\n    if(typeof input == 'number') return input;\n    if(input === true) return 1;\n\n    if(input instanceof Map) return _hashAny(Array.from(input.entries()));\n    else if(input instanceof Set) return _hashAny(Array.from(input));\n\n    let hash = 0;\n    for(let char of new TextEncoder().encode(\n        typeof input == 'string' ? input : input?.toString() || \"\"\n    )) \n        hash = ((hash << 5) - hash) + char;\n    return hash;\n}\n\n//Static\n/** @type {Map<string, Store<any>>} */ if(!globalThis.MfSt) globalThis.MfSt = new Map();\n/** @type {Map<string, Function>} */ if(!globalThis.MfFn) globalThis.MfFn = new Map();\n\n/**\n * @template T\n */\nexport class Store {\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\n    /** @type {string | undefined} */ _storedHash = undefined;\n    /** @type {Set<Store<any>>} */ _upstreamStores;\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    constructor(name, ops) {\n        return this._modify(name, ops);        \n    }\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    _modify(name, ops) {\n        this.name = name;\n        // @ts-ignore\n        MfSt.set(name, this);\n        \n        this._upstreamStores = new Set(ops?.upstream?.map(s=> _store(s)) || []);\n        this._upstreamStores.forEach(s=> s?._downstreamStores?.add(this));\n        this.value = ops?.value;\n        this._updater = ops?.updater;\n\n        return this;\n    }\n\n    /**\n     * @param {(T)=> void} sub\n     * @param {string | undefined} [ref]\n     * @param {boolean} [immediate]\n     */\n    sub(sub, ref, immediate = true) {\n        this._subscriptions.set(ref || String(Date.now() + Math.random()), sub);\n        if(immediate) sub?.(this.value);\n    }\n\n    //Update (manual or automated -- cascades downstream on batch updates)\n    /**\n    * @template T\n    * @param {T | ((T)=> T | Promise<T>)} value\n    */\n    async update(value) {\n        if(this.name === \"(store1, store3)=> return store1 == 'Last one' || store3 == 'three' \"){\n            console.log(\"UPDATING WITH VALUE\", value);\n        }\n        return new Promise(async (resolve)=> {\n            //Apply new value   \n            let newValue = (typeof value == \"function\" ? /** @type {Function} */(await value)?.(this.value) : value);\n            let newHash = _hashAny(newValue);\n            \n            if(newHash !== this._storedHash) {\n                this.value = newValue;\n                this._storedHash = newHash;\n\n                // Add this store to the work order\n                for(let ds of this._downstreamStores) await ds._auto_update();\n\n                // Wait for next animation frame to return the value\n                _scheduleUpdate(()=> {\n                    for(let [ref, sub] of this?._subscriptions || []) sub?.(this.value, ref);\n                    resolve(this.value);\n                });\n            }\n            else resolve(this.value);\n        });\n    }\n\n    async _auto_update() {\n        if(this.name === \"(store1, store3)=> return store1 == 'Last one' || store3 == 'three' \") console.log(\"UPDATING AUTO\")\n        let newVal = await this._updater?.(\n            Array.from(this._upstreamStores)?.map(S => S?.value) || [], \n            /** @type {T} */(this?.value)\n        );\n\n        await this.update(newVal === undefined ? this.value : newVal);\n    }\n}\n\n/**\n * STORE STATIC METHODS\n */\n/**\n * @template T\n * @param {string} name - The name of the store\n * @param {StoreOptions<T> | T} [ops] - Options to update the store\n * @returns {Store<T>}\n */\nexport function _store(name, ops) {\n    // @ts-ignore\n    let found_store = MfSt.get(name);\n    if(ops) {\n        if(found_store) {\n            return found_store._modify(name, ops);\n        }\n        return new Store(name, ops);\n    }\n    return found_store || new Store(name, /** @type {StoreOptions<T>}*/(ops));\n}","import { _scheduleUpdate } from \"./updates.js\";\r\n\r\n//Track scripts and styles\r\nlet pageScripts = new WeakMap();\r\nlet pageStyles = new WeakMap();\r\nlet parser = globalThis.DOMParser ? new DOMParser() : undefined;\r\n\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n//Fetch page and replace content\r\n/**\r\n * \r\n * @param {MfldOps} ops \r\n * @param {{method: string, href: string, el: HTMLElement}} target\r\n * @param {(el: HTMLElement | null)=> void} done \r\n * @returns \r\n */\r\nexport async function _fetchHttp(target, ops, done) {\r\n    if(!parser) return;\r\n    \r\n    //Make sure we're allowed to fetch\r\n    if(!ops.fetch?.externals?.some(allowed=> target?.href?.startsWith(allowed.domain))) {\r\n        //Fetch data\r\n        let fOps = ops.fetch;\r\n        let data = await fetch(target?.href, {\r\n            ...(fOps?.request || {}),\r\n            method: target?.method,\r\n            body: fOps?.request?.body ? JSON.stringify(fOps?.request?.body || {}) : undefined,\r\n        })\r\n        .catch(error=> {\r\n            fOps?.err?.(error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fOps?.onCode?.(code) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let text = await data?.[ops.fetch?.type || \"text\"]();\r\n        ops.fetch?.cb?.(text);\r\n\r\n        if((ops?.fetch?.type) != \"json\") {\r\n            //Extract content\r\n            let fullMarkup = parser.parseFromString(text, 'text/html').body;\r\n        \r\n            // //Clear existing scripts/styles\r\n            // clearDynamicElements(parent, pageScripts, \"script\");\r\n            // clearDynamicElements(parent, pageStyles, \"style\");;\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n\r\n            // ops.replace.forEach(r => {\r\n            //     let [ extract, relation, replace ] = r.split(/\\s*(>|\\/|\\+)\\s*/);\r\n\r\n            //     // let outEl = [\"this\", \"self\"].includes(replace) ? parent : document.querySelector(replace);\r\n// globalThis.document?.\r\n            //     _scheduleUpdate({\r\n            //         in: /** @type {HTMLElement} */ (fullMarkup.querySelector(extract)),\r\n            //         out: /** @type {HTMLElement} */ ([\"this\", \"self\"].includes(replace) ? parent : document.querySelector(replace)),\r\n            //         relation,globalThis.document?.\r\n            //         ops,\r\n            //         done,\r\n            //     })\r\n            // });\r\n        }\r\n    }\r\n}\r\n\r\n// //Clear dynamic elements\r\n// function clearDynamicElements(parent: HTMLElement, map: WeakMap<HTMLElement, any[]>, type: string) {\r\n//     let elements = map.get(parent) || [];\r\n//     elements.forEach(el => el.remove());\r\n//     map.set(parent, []);\r\n// }","export let ATTR_PREFIX = \"mf\";\r\n","import { ATTR_PREFIX } from \"./exports\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {string} trigger \r\n * @param {MfldOps} _ops\r\n * @param {string} [method] \r\n * @param {BodyInit | null} [input]\r\n * @param {string} [href]\r\n */\r\nexport function _handleFetch(el, trigger, _ops, method, input, href) {\r\n    /**\r\n     * @param {Event} [e]\r\n     */\r\n    let ev = async e=> {  \r\n        e?.preventDefault();\r\n        e?.stopPropagation();\r\n\r\n        let overrides = el.dataset[`${ATTR_PREFIX}overrides`] || \"{}\";\r\n        let overrideOps = _ops.profiles?.[overrides]?.fetch || JSON.parse(overrides);\r\n\r\n        /** @type {MfldOps} */\r\n        let fetchOps = overrideOps ? {\r\n            ..._ops,\r\n            ...overrideOps,\r\n        } : _ops;\r\n\r\n        // If no input data was provided, it's the href; use fetchOps.body if it exists (input overrides this)\r\n        if(!href) {\r\n            href = typeof input == \"string\" ? structuredClone(input) : null || /** @type {string} */(/** @type {any}*/(e?.target)?.href);\r\n            input = fetchOps?.fetch?.request?.body;\r\n        }\r\n\r\n        // Set from target element if relevant; fall back to \"get\"\r\n        if(!method) method = /** @type {any}*/(e?.target)?.method || \"get\";\r\n\r\n        // if([\"click\", \"submit\"].includes(trigger) || [\"A\", \"FORM\"].includes(target?.nodeName)) {\r\n        //     history.pushState(\r\n        //         {fetchData, elId: el.id}, \r\n        //         \"\", \r\n        //         target?.href || target?.action || \"\"\r\n        //     );\r\n        // }\r\n    \r\n        //Make sure we're allowed to fetch\r\n        let externalPermissions = fetchOps?.fetch?.externals?.find(allowed=> href?.startsWith(allowed.domain)) || \r\n            !href.match(/^https?:\\/\\//) || href.includes(location.origin) ? {\r\n                scripts: true,\r\n                styles: true,\r\n        } : undefined;\r\n\r\n        //Fetch data\r\n        let data = await fetch(href, {\r\n            ...(fetchOps?.fetch?.request || {}),\r\n            method,\r\n            body: typeof input == \"string\" ? input : JSON.stringify(input),\r\n        })\r\n        .catch(error=> {\r\n            fetchOps?.fetch?.err?.(error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fetchOps?.fetch?.onCode?.(code, data) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let resp = await data?.[fetchOps?.fetch?.type || \"text\"]();\r\n        fetchOps?.fetch?.cb?.(resp);\r\n\r\n        // Handle resolutions\r\n        for(let instruction of [\"append\", \"prepend\", \"swapinner\", \"swapouter\"]) {\r\n            let ds = el.dataset[`${ATTR_PREFIX}${instruction}`];\r\n            if(ds === undefined) continue;\r\n            let [selector, toReplace] = ds?.split(\"->\").map(s=> s.trim()) || [];\r\n\r\n            //Extract content and schedule a DOM update\r\n            let fullMarkup = (new DOMParser())?.parseFromString?.(resp, 'text/html');\r\n            if(fullMarkup) {\r\n                _scheduleUpdate({\r\n                    in: /** @type {HTMLElement} */ (fullMarkup.querySelector(selector || \"body\")),\r\n                    out: /** @type {HTMLElement} */ (toReplace ? document.querySelector(toReplace) : el),\r\n                    relation: /** @type {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"}*/(instruction),\r\n                    ops: fetchOps,\r\n                    done: ()=> true,\r\n                })\r\n            }\r\n        }\r\n\r\n        if(el.dataset?.[`${ATTR_PREFIX}resolve`]) {\r\n            alert(\"RESOLVING\")\r\n        }\r\n\r\n            // //Clear existing scripts/styles\r\n            // for(let s of [pageScripts, pageStyles]) {\r\n            //     let elements = s.get(fullMarkup) || [];\r\n            //     elements.forEach(el => el.remove());\r\n            //     s.set(fullMarkup, []);\r\n            // }\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n    }\r\n\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}","import { _store } from \"./store.js\";\nimport { _fetchHttp } from \"./http.js\";\nimport { _scheduleUpdate } from \"./updates.js\";\nimport { ATTR_PREFIX } from \"./exports.js\";\nimport { _handleFetch } from \"./fetch.js\";\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\n\n/** @type {Partial<MfldOps>} */\nlet _ops = {};\nlet _commaSepRx = /, {0,}/g;\nlet _elIdx = 0;\nlet _modes = [\"bind\", \"sync\", \"if\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\"].map(m=> `${ATTR_PREFIX}${m}`);\nlet pageScripts = new WeakMap();\nlet pageStyles = new WeakMap();\n\n// globalThis.addEventListener(\"popstate\", (e)=> {\n//     let el = document?.getElementById(e.state?.elId);\n//     if(e?.state?.fetchData) {\n//         _fetchHttp(\n//             \"get\", \n//             \"\",\n//             e.state.fetchData,\n//             el,\n//             el=> {if(el) _registerSubs(el)}\n//         );\n//     }\n// });\n\n/**!\n * @param {Partial<MfldOps>} newops \n * @param {string} [profileName] \n */\nexport function _setOptions(newops, profileName) {\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\n    else _ops = { ..._ops, ...newops };\n}\n\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\n/**\n * @param {HTMLElement | null} [parent] \n */\nexport function _registerSubs(parent) {   \n    /** @type {NodeListOf<HTMLElement> | []} */\n    let els = (parent || document.body).querySelectorAll(\n        `[data-${_modes.join(`],[data-`)}]${_ops.fetch?.auto != false ? \",a\" : \"\"}`\n    ) || [];\n\n    for(let el of els) {\n        /** @type {HTMLElement} */\n        if(!el.id) el.id = `${_elIdx++}`;\n\n        //Loop over all data attributes (modes)\n        for(let mode in el.dataset) {\n            if(!_modes.includes(mode)) continue;\n            let shouldHaveTriggers = ![`${ATTR_PREFIX}bind`, `${ATTR_PREFIX}if`, `${ATTR_PREFIX}each`].includes(mode);\n            let err_detail = `(#${el.id} on ${mode})`;\n\n            /**\n             * HANDLE CONDITIONALS AND LOOPS\n             */\n            if([`${ATTR_PREFIX}if`, `${ATTR_PREFIX}each`].includes(mode)) {\n                let [stores, func] = el?.dataset?.[mode]?.split(\"=>\").map(s=> s.trim()) || [\"\", \"\"];\n                if(!func) {\n                    func = stores.slice();\n                    stores = \"\";\n                }\n\n                // Set up function to evaluate store values\n                let storeList = stores.split(\",\").map(s=> s.replace(/[()]/g, \"\").trim());\n                // @ts-ignore\n                let execFunc = globalThis[func] || MfFn?.get(func) || new Function(...storeList, func);\n\n                // Register new store (to prevent excess evaluations)\n                let conditionStore = _store(el?.dataset?.[mode] || \"\", {\n                    upstream: storeList,\n                    updater: (list, value)=> {\n                        console.log(\"Calling updater with value\", execFunc(...list));\n                        return execFunc(...list);\n                    }\n                })\n                \n                if(mode == `${ATTR_PREFIX}if`) {\n                    conditionStore?.sub(val=> {\n                        return val\n                    });\n                }\n                else {\n                    alert(\"FOUND EACH!\")\n                }\n\n                return;\n            }\n\n            //Loop over provided settings\n            el.dataset?.[mode]?.split(\";\").forEach(setting=> {\n                //Break out settings\n                let _parts = setting?.split(/(?:(?:\\)|->) ?){1,}/g) || []; \n        \n                //Extract settings\n                let triggers = shouldHaveTriggers ? _paramsInParens(_parts.splice(0,1)[0]) : [];\n                let processFuncName = _parts[0]?.includes(\"(\") ? _parts[0]?.match(/^[^\\(]{1,}/)?.[0] || \"\" : \"\";\n                let output = _paramsInParens(_parts.splice(mode == `${ATTR_PREFIX}sync` ? 1 : 0, 1)[0]);\n                let input = _paramsInParens(_parts[0]);\n\n                //Handle errors\n                if(shouldHaveTriggers && !triggers?.length) throw(`No trigger: ${err_detail}.`)\n\n                /** @type {Function | undefined} */\n                let processFunc;\n                if(processFuncName) {\n                    // @ts-ignore\n                    processFunc = globalThis[processFuncName] || MfFn?.get(processFuncName);\n                    if(!processFunc) console.warn(`\"${processFuncName}\" not registered: ${err_detail}`);\n                    if(((!shouldHaveTriggers && output.length > 1) || (shouldHaveTriggers && input.length > 1))) throw(`Multiple sources: ${err_detail}`);\n                }\n\n                //Map output names and paths\n                let outputData = output.map((ext)=> {\n                    let [ name, ...sourcePathArr ] = ext.split(/[\\.\\[\\]\\?]{1,}/g);\n                    return {\n                        name,\n                        path: sourcePathArr.map(sp=> !isNaN(parseInt(sp)) \n                            ? parseInt(sp) \n                            : sp)\n                            .filter(sp=> sp) /** @type {(string | number)[]} */\n                    }\n                });\n\n                //Loop over triggers\n                if(!triggers?.length) triggers = [\"\"]\n                for(let trigger of triggers) {\n                    /**\n                     * HANDLE MF-FETCH\n                     */\n                    //No input loops for fetch\n                    if(mode.match(/bind|sync/)) {\n                        //Loop over input\n                        if(!input?.length) input = [ \"\" ];\n                        for(let i=0; i < input.length; i++) {\n                            /**\n                             * HANDLE MF-BIND\n                             */\n                            if(mode == `${ATTR_PREFIX}bind`) {\n                                let domSubscription = ()=> {\n                                    _scheduleUpdate(()=> {\n                                        let val = processFunc?.(\n                                            ...outputData.map(\n                                                s=> _nestedValue(_store(s.name)?.value, s.path)\n                                            ), el\n                                        ) ??\n                                        _nestedValue(\n                                            _store(outputData[0].name || \"\")?.value, outputData[0].path\n                                        );\n\n                                        if(val !== undefined) el[input[i]] = val;\n\n                                        //Make sure to update dependent stores on value update\n                                        el.dispatchEvent(new CustomEvent(trigger))\n                                    });\n                                }\n                            \n                                //Add subscription - run whenever store updates\n                                for(let store of outputData) _store(store.name)?.sub(domSubscription, el.id);\n                            }\n\n                            /**\n                             * HANDLE MF-SYNC\n                             */\n                            else if(mode == `${ATTR_PREFIX}sync`) {\n                                if(outputData.length > 1) throw(`Only one store supported: ${err_detail}`)\n                                let ev = ()=> {\n                                    let prop = input[i].trim();\n                                    let value = el[prop] ?? el.getAttribute(prop) ?? el.dataset[prop] ?? undefined;\n                                    \n                                    if(processFunc) value = processFunc?.(value, el);\n                                    let store = _store(outputData[0]?.name);\n                                    \n                                    if(value !== undefined) {\n                                        store?.update?.(curVal=> {\n                                            return outputData[0]?.path?.length ? _nestedValue(curVal, outputData[0]?.path, value) : value\n                                        });\n                                    }\n                                }\n                                if(trigger == \"$mount\") ev();\n                                else el.addEventListener(trigger, ev);\n                            }\n                        }   //End loop input\n                    }   //End loop triggers\n                    /**\n                     * HANDLE MF-FETCH\n                     */\n                    else {\n                        if(input.length > 1 || output.length > 1) throw(`Multiple sources: ${err_detail}`);\n                        _handleFetch(el, trigger, _ops, mode.replace(ATTR_PREFIX, \"\"), input[0], output[0]);\n                    }\n                }\n            }); //End loop settings\n        }   //End loop dataset modes\n    };  //End loop elements\n}\n\n//Get or set nested store values\n/**\n * \n * @param {any} obj \n * @param {(string | number)[]} path \n * @param {any} [newval] \n * @returns \n */\nfunction _nestedValue(obj, path, newval) {\n    let ptr = obj;\n\n    for(let key of path) {\n        //Dynamically letruct object if it doesn't exist\n        if(ptr == undefined) ptr = typeof key == \"number\" ? [] : {};\n\n        //Set or get value\n        if(newval == undefined || path[path.length - 1] !== key) ptr = ptr instanceof Map ? ptr?.get(key) : ptr?.[key];\n        else ptr instanceof Map ? ptr.set(key, newval) : ptr[key] = newval;\n    }\n\n    return ptr;\n}\n\n/**\n * @param {string} str \n * @returns \n */\nfunction _paramsInParens(str) {\n    if(str?.includes(\"(\")) {\n        let matches = str.match(/[^\\(\\)]{1,}/g);\n        str = matches?.[matches.length - 1] || \"\";\n    }\n    return str?.split(_commaSepRx)?.map(s=> s.trim()) || [];\n}","import { _store } from \"./store.js\";\nimport { _addToNextTickQueue } from \"./updates.js\";\nimport { _registerSubs, _setOptions } from \"./registrar.js\";\n\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\n\n/**!\n * @typedef {object} ExternalOptions\n * @property {string} domain - The domain name these settings apply to\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\n * @property {boolean} [styles] - Allow styles from this domain to apply\n */\n\n/**!\n * @typedef {object} FetchOptions\n * @property {RequestInit} [request] - Fetch request options\n * @property {\"json\"|\"text\"} [type] - Response type (default: \"text\")\n * @property {(val: any)=> void} [cb] - Callback function - run on successful fetch; *val* is the un-parsed response body\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\n * @property {(code: number, data: void | Response)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\n * @property {boolean} [auto] - Automatically fetch content on page load\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\n */\n\n/**!\n * @typedef {object} TransitionOptions\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\n * @property {boolean} [smartTransition] - Enable smart transitions (default: true)\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\n */\n\n/**!\n * Manifold options for `fetch`, `trans`, and `profiles`.\n * @typedef {Object} MfldOps\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\n */\n\n/**!\n * @template T\n * @callback UpdaterFunction\n * @param {Array<any>} upstreamValues\n * @param {T} value\n * @returns {T | Promise<T>}\n */\n\n/**!\n * @template T\n * @typedef {Object} StoreOptions\n * @property {T} [value]\n * @property {Array<string>} [upstream]\n * @property {UpdaterFunction<T>} [updater]\n */\n\n/**!\n * @template T\n * @typedef Store\n * @prop {T} value - The store's current value (read only)\n * @prop {function(T | function(T):T|Promise<T>|undefined):T|Promise<T>|undefined} update - Update the store's current value\n * @prop {function(function(T):void,string):void} sub - Add a subscription function to the store\n */\n\n/**!\n * @typedef {Function} MfldFunc\n * @param {any} val\n * @param {HTMLElement} [el]\n */\n\n/**!\n * The global Manifold interface.\n */\nexport let Mfld = {\nstore: \n/**!\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @template T\n* @param {string} store_name\n* @param {StoreOptions<T> | T} store_ops\n* @return {Store<T>}\n*/ (store_name, store_ops)=> {\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\n    }\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\n},\nustore: \n/**!\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @param {string} store_name\n* @param {StoreOptions<any> | any} store_ops\n* @return {Store<any>}\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\nget:\n/**!\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\n * @param {string} store_name\n * @return {Store<any>}\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\nfunc: \n/**!\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\n * @param {string} func_name\n * @return {MfldFunc}\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(\n// @ts-ignore\n MfFn?.get(func_name)),\nfuncs: \n/**!\n * - Add functions to the Manifold function registry in key-value pairs.\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\n * @param {{ [key: string]: MfldFunc }} funcs\n */ funcs=> {for(let key in funcs) \n// @ts-ignore\n MfFn.set(key, funcs[key])},\nconfig:\n/**!\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\n * @param {MfldOps} new_ops\n * @param {string} [profile_name]\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\n onTick:\n /**!\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\n  * @param {()=> void} cb\n  */ (cb)=> _addToNextTickQueue(cb),\nregister:\n/**!\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\n * @param {HTMLElement | string | null} [parent]\n */ (parent)=> {\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\n        _registerSubs(parent)\n    },\n};"],"names":["spacer","workArray","cancelAnimationFrame","_nextTickQueue","spacerHeight","tick","globalThis","requestAnimationFrame","fn","setTimeout","_scheduleUpdate","update","push","_runUpdates","_addSpacer","inEl","wrapper","wrapperHeight","document","createElement","paddingTop","paddingBottom","Element","window","getComputedStyle","style","height","Math","abs","clientHeight","after","_adjustSizing","remove","animate","order","out","includes","relation","container","child","Array","from","childNodes","appendChild","replaceChildren","_applyTransition","ops","in","prepend","done","forEach","el","dir","nodeType","Node","TEXT_NODE","text","textContent","newNode","replaceWith","dur","isArray","trans","transClass","class","classList","add","hooks","width","clientWidth","position","transitionDuration","swap","_hashAny","input","Map","entries","Set","hash","char","TextEncoder","encode","toString","MfSt","MfFn","Store","_updater","undefined","_subscriptions","_storedHash","_upstreamStores","_downstreamStores","constructor","name","this","_modify","set","upstream","map","s","_store","value","updater","sub","ref","immediate","String","Date","now","random","console","log","Promise","async","resolve","newValue","newHash","ds","_auto_update","newVal","S","found_store","get","DOMParser","ATTR_PREFIX","_handleFetch","trigger","_ops","method","href","ev","e","preventDefault","stopPropagation","overrides","dataset","overrideOps","profiles","fetch","JSON","parse","fetchOps","structuredClone","target","request","body","externals","find","allowed","startsWith","domain","match","location","origin","data","stringify","catch","error","err","code","status","onCode","resp","type","cb","instruction","selector","toReplace","split","trim","fullMarkup","parseFromString","querySelector","alert","addEventListener","_commaSepRx","_elIdx","_modes","m","_nestedValue","obj","path","newval","ptr","key","length","_paramsInParens","str","matches","Mfld","store","store_name","store_ops","hasOwnProperty","ustore","func","func_name","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register","parent","els","querySelectorAll","join","auto","id","mode","shouldHaveTriggers","err_detail","stores","slice","storeList","replace","execFunc","Function","conditionStore","list","val","setting","processFunc","_parts","triggers","splice","processFuncName","output","warn","outputData","ext","sourcePathArr","sp","isNaN","parseInt","filter","i","domSubscription","dispatchEvent","CustomEvent","prop","getAttribute","curVal","_registerSubs"],"mappings":"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"}