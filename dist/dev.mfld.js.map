{"version":3,"file":"dev.mfld.js","sources":["../src/store.js","../src/domUpdates.js","../src/http.js","../src/domRegistrar.js","../src/index.module.js"],"sourcesContent":["/** \n * @template T\n * @typedef {import(\"./index.module.js\").UpdaterFunction<T>} UpdaterFunction \n */\n/** \n * @template T\n * @typedef {import(\"./index.module.js\").StoreOptions<T>} StoreOptions \n */\n\n/**\n * @callback SubFunction\n * @param {any} value\n * @param {string} [ref]\n * @returns {void}\n */\n\n/**\n * @param {any} input \n * @returns {any}\n */\nfunction _hashAny(input) {\n    if (typeof input === 'number') return input;\n    if(input === true) return 1;\n\n    if(typeof input === 'object') {\n        if(input instanceof Map) return _hashAny(input.entries());\n        if(input instanceof Set) return _hashAny(Array.from(input));\n        return Date.now();\n    }\n\n    let hash = 0;\n    for(const char of new TextEncoder().encode(\n        typeof input === 'string' ? input : input?.toString() || \"\"\n    )) \n        hash = ((hash << 5) - hash) + char;\n    return hash;\n}\n\n// Next tick queue\n/**\n * @type {Function[]}\n */\nlet _nextTickQueue = [];\n\nexport function _addToNextTickQueue(fn) {\n    if(fn) _nextTickQueue.push(fn);\n}\n\n//Static\n/** @type {Map<string, Store<any>>} */ if(!globalThis.Mfld_stores) globalThis.Mfld_stores = new Map();\n/** @type {Map<string, Function>} */ if(globalThis.Mfld_funcs) globalThis.Mfld_funcs = new Map();\n/** @type {Map<string, (any | ((any)=> any))>} */ let _workOrder = new Map();\n/** @type {any} */ let _workCacheTimeout;\n\n/**\n * @template T\n */\nexport class Store {\n    /** @type {UpdaterFunction<T> | undefined} */ #updater = undefined;\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\n    /** @type {string | undefined} */ _storedHash = undefined;\n    /** @type {Array<string>} */ _downstreamStores = [];\n    /** @type {Array<string>} */ _upstreamStores = [];\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    constructor(name, ops) {\n        this.name = name;\n        globalThis.Mfld_stores.set(name, this);\n        \n        this._upstreamStores = ops?.upstream || [];\n        for(let storeName of this._upstreamStores) _store(storeName)?._downstreamStores?.push(this.name || \"\");\n        this.value = ops?.value;\n        console.log(\"Setting updater\", name, ops?.updater)\n        this.#updater = ops?.updater;\n\n        console.log(\"Constructed store\", this)\n        \n        return this;\n    }\n\n    /**\n     * @param {string} ref\n     * @param {() => void} sub\n     */\n    _addSub(ref, sub) {\n        this._subscriptions.set(ref, sub);\n        sub?.();\n    }\n\n    /**\n     * @param {(T)=> void} sub\n     */\n    sub(sub) {\n        let ref = \"x\".repeat(5).replace(/./g, c => \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"[Math.floor(Math.random() * 36) ] );\n        this._subscriptions.set(ref, sub);\n        sub?.(this.value);\n    }\n\n    //Update (manual or automated -- cascades downstream)\n    /**\n    * @template T\n    * @param {T | ((T)=> T | Promise<T>)} value\n    */\n    async update(value) {\n        return new Promise((resolve)=> {\n            _workOrder.set(this.name || \"\", value);\n            clearTimeout(_workCacheTimeout);\n            _workCacheTimeout = setTimeout(async ()=> {\n                //Sort this.#workOrder such that dependencies are updated first, duplicate work is filtered out\n                for(let [storeName, _] of _workOrder) {\n                    const store = _store(storeName);\n\n                    //Don't repeat work if an upstream store will cascade\n                    store._downstreamStores.forEach(d=> _workOrder.delete(d));   //Delete downstream stores from work order\n                    store._upstreamStores.forEach(u=> _workOrder.has(u) ? _workOrder.delete(storeName) : true);\n                }\n\n                //Apply changes to top-level workers, then cascade     \n                /** @type {string[]} */ let downstream = [];\n                for(let [storeName, value] of _workOrder) {\n                    let store = _store(storeName);\n                    let newValue = (typeof value == \"function\" ? /** @type {Function} */await (value)?.(store.value) : value);\n\n                    //Check complex object lengths (avoid lengthy hashes) -- if the lengths indicate the value HAS NOT CHANGED, double-check via hash\n                    let aLen = store.value?.length || store.value?.size || undefined;\n                    let bLen = newValue?.length || newValue?.size || undefined;\n                    let valueChanged = aLen !== bLen;\n\n                    let newHash = \"\";\n                    if(!valueChanged) {\n                        newHash = _hashAny(store.value);\n                        valueChanged = newHash !== store._storedHash;    //Double-check that the value has not changed via hash\n                    }\n\n                    //If the value HAS DEFINITELY CHANGED or is LIKELY TO HAVE CHANGED, update the stored hash and cascade\n                    if(valueChanged) {\n                        store.value = newValue;\n                        store._storedHash = newHash;\n                        for(let S of store._downstreamStores) downstream.push(S);\n                        for(let [ref, sub] of store._subscriptions) sub?.(store.value, ref);\n                    }\n                }\n\n                //Clear work order and cascade\n                _workOrder.clear();\n                for(let S of downstream) if(_store(S)) await _store(S)._autoUpdate();\n\n                //Handle queued nextTick functions\n                _nextTickQueue.forEach(fn=> fn());\n                _nextTickQueue = [];\n\n                //Resolve value\n                resolve(this.value);\n            }, 0);    //Hack to force running all updates at the end of the JS event loop\n        });\n    }\n\n    //Auto update\n    async _autoUpdate() {\n        await this.update(\n            await (this.#updater?.(\n                this._upstreamStores?.map(store => _store(store)?.value) || [], \n                /** @type {T} */(this?.value)\n            ) || this.value),\n        )\n    }\n}\n\n/**\n * STORE STATIC METHODS\n */\n/**\n * @template T\n * @param {string} name - The name of the store\n * @param {StoreOptions<T> | T} [ops] - Options to update the store\n * @returns {Store<T>}\n */\nexport function _store(name, ops) {\n    if(ops) return new Store(name, ops);\n    return globalThis.Mfld_stores.get(name) || new Store(name, /** @type {StoreOptions<T>}*/(ops));\n}","import { _store } from \"./store.js\";\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n/** @type {{ adjust?: Function, space?: Function, size?: Function } | undefined} */\r\nlet smartOutro = globalThis.smartOutro;\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {string} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = false;\r\n\r\n/** @export @param {(DomWorkOrder | Function)} update */\r\nexport function _scheduleDomUpdate(update) {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = true;\r\n        globalThis.requestAnimationFrame?.(_runDomUpdates);\r\n    }\r\n}\r\n\r\nfunction _runDomUpdates() {\r\n    cancelAnimationFrame = false;\r\n    \r\n    /**\r\n    * @type {DomWorkOrder[]}\r\n    */\r\n    for(let order of workArray) {\r\n        if(typeof order === \"function\") (/** @type {Function} */ order)();\r\n        else {\r\n            // Remove old children\r\n            if([\">\", \"+\"].includes(order.relation)) {\r\n                if(order.relation == \">\") {\r\n                    //Remove old children before appending\r\n                    let container = globalThis.document?.createElement(\"div\");\r\n                    for(let child of Array.from(order.out?.childNodes || [])) {\r\n                        container.appendChild(child);\r\n                    }\r\n                    order.out?.replaceChildren(container);\r\n                    _applyTransition(container, \"out\", order.ops);\r\n                }\r\n\r\n                smartOutro?.space?.(order.in, order.out);\r\n\r\n                //Append\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) order.out?.appendChild(order.in);\r\n                    smartOutro?.adjust?.(order.in, order.ops);\r\n                });\r\n            }\r\n            //Insert after old element before removing\r\n            else _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                order.out?.after(order.in);\r\n                smartOutro?.space?.(order.in, order.out);\r\n                smartOutro?.adjust?.(order.in, order.ops);\r\n\r\n                //Remove old element\r\n                if(order.relation === \"/\") _applyTransition(order.out, \"out\", order.ops);\r\n            });\r\n\r\n            order.done?.(order.in);\r\n        }\r\n    }\r\n\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @returns \r\n */\r\nfunction _applyTransition(el, dir, ops, fn) {\r\n    //Handle text nodes\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        let text = el.textContent;\r\n        let newNode = globalThis.document?.createElement(\"div\");\r\n        newNode.textContent = text;\r\n        el.replaceWith(newNode);\r\n        el = newNode;\r\n    }\r\n\r\n    if(el) {\r\n        let dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n\r\n        //Initiate transition\r\n        let transClass = ops?.trans?.class || \"cu-trans\";\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        //Wait to apply class\r\n        if(dir == \"out\") {\r\n            _scheduleDomUpdate(()=> {\r\n                smartOutro?.size?.(el);\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                el.classList?.add(dir);\r\n            })\r\n        }\r\n        //If dir == in\r\n        else {\r\n            setTimeout(()=> {\r\n                _scheduleDomUpdate(()=> {\r\n                    if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                    el?.classList?.add(dir);\r\n                    fn?.();\r\n\r\n                    //Remove transition class\r\n                    _scheduleDomUpdate(()=> {\r\n                        el?.classList?.remove(dir);\r\n                    });\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleDomUpdate(()=> {\r\n                //Wrapup\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                el?.classList?.remove(dir);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}","import { _scheduleDomUpdate } from \"./domUpdates.js\";\r\n\r\n//Track scripts and styles\r\nlet pageScripts = new WeakMap();\r\nlet pageStyles = new WeakMap();\r\nlet parser = globalThis.DOMParser ? new DOMParser() : undefined;\r\n\r\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\r\n\r\n//Fetch page and replace content\r\n/**\r\n * \r\n * @param {MfldOps} ops \r\n * @param {{method: string, href: string, el: HTMLElement}} target\r\n * @param {(el: HTMLElement | null)=> void} done \r\n * @returns \r\n */\r\nexport async function _fetchHttp(target, ops, done) {\r\n    if(!parser) return;\r\n    //Make sure we're allowed to fetch\r\n    if(!ops.fetch?.externals?.some(allowed=> target?.href?.startsWith(allowed.domain))) {\r\n        //Fetch data\r\n        let fOps = ops.fetch;\r\n        let data = await fetch(target?.href, {\r\n            ...(fOps?.request || {}),\r\n            method: target?.method,\r\n            body: fOps?.request?.body ? JSON.stringify(fOps?.request?.body || {}) : undefined,\r\n        })\r\n        .catch(error=> {\r\n            fOps?.err?.(error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fOps?.onCode?.(code) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let text = await data?.[ops.fetch?.type || \"text\"]();\r\n        ops.fetch?.cb?.(text);\r\n\r\n        if((ops?.fetch?.type) != \"json\") {\r\n            //Extract content\r\n            let fullMarkup = parser.parseFromString(text, 'text/html').body;\r\n        \r\n            // //Clear existing scripts/styles\r\n            // clearDynamicElements(parent, pageScripts, \"script\");\r\n            // clearDynamicElements(parent, pageStyles, \"style\");;\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n\r\n            // ops.replace.forEach(r => {\r\n            //     let [ extract, relation, replace ] = r.split(/\\s*(>|\\/|\\+)\\s*/);\r\n\r\n            //     // let outEl = [\"this\", \"self\"].includes(replace) ? parent : document.querySelector(replace);\r\n// globalThis.document?.\r\n            //     _scheduleDomUpdate({\r\n            //         in: /** @type {HTMLElement} */ (fullMarkup.querySelector(extract)),\r\n            //         out: /** @type {HTMLElement} */ ([\"this\", \"self\"].includes(replace) ? parent : document.querySelector(replace)),\r\n            //         relation,globalThis.document?.\r\n            //         ops,\r\n            //         done,\r\n            //     })\r\n            // });\r\n        }\r\n    }\r\n}\r\n\r\n// //Clear dynamic elements\r\n// function clearDynamicElements(parent: HTMLElement, map: WeakMap<HTMLElement, any[]>, type: string) {\r\n//     let elements = map.get(parent) || [];\r\n//     elements.forEach(el => el.remove());\r\n//     map.set(parent, []);\r\n// }","import { _store } from \"./store.js\";\nimport { _fetchHttp } from \"./http.js\";\nimport { _scheduleDomUpdate } from \"./domUpdates.js\";\n/** @typedef {import(\"./index.module.js\").MfldOps} MfldOps */\n\nlet commaSepRx = /, {0,}/g;\nlet elIdx = 0;\n\n// Initialize from script params\nfunction _intialize() {\n    let ds = globalThis.document?.currentScript?.dataset;\n\n    if(ds?.config) {\n        try {\n            let scriptParams = JSON.parse(ds?.config);\n            _setOptions(scriptParams);\n        } catch(e) {\n            console.warn(\"Invalid Mfld params\", e);\n        }\n    }\n\n    if(ds?.init) _registerSubs();\n}\n\n_intialize();\n\n// globalThis.addEventListener(\"popstate\", (e)=> {\n//     let el = document.getElementById(e.state?.elId);\n//     if(e?.state?.fetchData) {\n//         _fetchHttp(\n//             \"get\", \n//             \"\",\n//             e.state.fetchData,\n//             el,\n//             el=> {if(el) _registerSubs(el)}\n//         );\n//     }\n// });\n\n/** @type {Partial<MfldOps>} */\nlet ops = {};\nlet modes = [\"bind\", \"sync\", \"fetch\"];\n\n/**!\n * @param {Partial<MfldOps>} newops \n * @param {string} [profileName] \n */\nexport function _setOptions(newops, profileName) {\n    if(profileName) ops.profiles = { ...ops.profiles, [profileName]: newops };\n    else ops = { ...ops, ...newops };\n}\n\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\n/**\n * @param {HTMLElement | null} [parent] \n */\nexport function _registerSubs(parent) {\n    /** @type {NodeListOf<HTMLElement> | []} */\n    let els = parent?.querySelectorAll(`[data-${modes.join(\"],[data-\")}]${ops.fetch?.auto != false ? \",a\" : \"\"}`) || [];\n    for(let el of els) {\n        /** @type {HTMLElement} */\n        if(!el.id) el.id = `cu-${elIdx++}`;\n\n        //Loop over all data attributes (modes)\n        for(let mode in el.dataset) {\n            if(!modes.includes(mode)) continue;\n            let shouldHaveTriggers = mode != \"bind\";\n            let err_detail = `(#${el.id} on ${mode})`;\n\n            el?.dataset?.[mode]?.split(\";\").forEach(setting=> {\n                //Break out settings\n                let _parts = setting?.split(/(?:(?:\\)|->) ?){1,}/g) || []; \n        \n                //Extract settings\n                let triggers = shouldHaveTriggers ? _paramsInParens(_parts.splice(0,1)[0]) : [];\n                let processFuncName = _parts[0]?.includes(\"(\") ? _parts[0]?.match(/^[^\\(]{1,}/)?.[0] || \"\" : \"\";\n                let external = _paramsInParens(_parts.splice(mode == \"sync\" ? 1 : 0, 1)[0]);\n                let internal = _paramsInParens(_parts[0]);\n\n                //Handle errors\n                if(shouldHaveTriggers && !triggers?.length) throw(`No trigger: ${err_detail}.`)\n\n                /** @type {Function | undefined} */\n                let processFunc;\n                if(processFuncName) {\n                    processFunc = globalThis[processFuncName] || globalThis.Mfld_funcs.get(processFuncName);\n                    if(!processFunc) throw(`\"${processFuncName}\" not registered: ${err_detail}`);\n                    if(((!shouldHaveTriggers && external.length > 1) || (shouldHaveTriggers && internal.length > 1))) throw(`Multiple sources: ${err_detail}`);\n                }\n\n                //Map external names and paths\n                let externalData = external.map((ext)=> {\n                    let [ name, ...sourcePathArr ] = ext.split(/[\\.\\[\\]\\?]{1,}/g);\n                    return {\n                        name,\n                        path: sourcePathArr.map(sp=> !isNaN(parseInt(sp)) \n                            ? parseInt(sp) \n                            : sp)\n                            .filter(sp=> sp) /** @type {(string | number)[]} */\n                    }\n                });\n\n                //Loop over triggers\n                if(!triggers?.length) triggers = [\"\"]\n                for(let trigger of triggers) {\n                    //No internal loops for fetch\n                    if(mode == \"fetch\") {\n                        _handleFetch(el, trigger, external, internal, ops);\n                    }\n\n                    //Loop over internal\n                    if(!internal?.length) internal = [ \"\" ];\n                    for(let i=0; i < internal.length; i++) {\n                        //Handle bind\n                        if(mode == \"bind\") {\n                            let domSubscription = ()=> {\n                                _scheduleDomUpdate(()=> {\n                                    el[internal[i]] = processFunc?.(\n                                        ...externalData.map(\n                                            s=> _nestedValue(_store(s.name)?.value, s.path)\n                                        ), el\n                                    ) ??\n                                    _nestedValue(\n                                        _store(externalData[0].name || \"\")?.value, externalData[0].path\n                                    );\n\n                                    //Make sure to update dependent stores on value update\n                                    el.dispatchEvent(new CustomEvent(trigger))\n                                });\n                            }\n                        \n                            //Add subscription - run whenever store updates\n                            for(let store of externalData) _store(store.name)?._addSub(el.id, domSubscription);\n                        }\n\n                        //Handle sync\n                        else if(mode == \"sync\") {\n                            if(externalData.length > 1) throw(`Only one store supported: ${err_detail}`)\n                            let ev = ()=> {\n                                let value = el[internal[i].trim()];\n                                \n                                if(processFunc) value = processFunc?.(value, el);\n                                const store = _store(externalData[0]?.name);\n                                \n                                if(value !== undefined) {\n                                    store?.update?.(curVal=> {\n                                        return externalData[0]?.path?.length ? _nestedValue(curVal, externalData[0]?.path, value) : value\n                                    });\n                                }\n                            }\n                            el.addEventListener(trigger, ev);\n                        }\n                    }   //End loop internal\n                }   //End loop triggers\n            }); //End loop settings\n        }   //End loop dataset modes\n    };  //End loop elements\n}\n\n//Get or set nested store values\n/**\n * \n * @param {any} obj \n * @param {(string | number)[]} path \n * @param {any} [newval] \n * @returns \n */\nfunction _nestedValue(obj, path, newval) {\n    let ptr = obj;\n\n    for(let key of path) {\n        //Dynamically construct object if it doesn't exist\n        if(ptr == undefined) ptr = typeof key == \"number\" ? [] : {};\n\n        //Set or get value\n        if(newval == undefined || path[path.length - 1] !== key) ptr = ptr instanceof Map ? ptr?.get(key) : ptr?.[key];\n        else ptr instanceof Map ? ptr.set(key, newval) : ptr[key] = newval;\n    }\n\n    return ptr;\n}\n\n/**\n * @param {string} str \n * @returns \n */\nfunction _paramsInParens(str) {\n    if(str?.includes(\"(\")) {\n        let matches = str.match(/[^\\(\\)]{1,}/g);\n        str = matches?.[matches.length - 1] || \"\";\n    }\n    return str?.split(commaSepRx) || [];\n}\n\n/**\n * @param {HTMLElement} el \n * @param {string} trigger \n * @param {string[]} external \n * @param {string[]} internal \n * @param {Partial<MfldOps>} ops \n */\nfunction _handleFetch(el, trigger, external, internal, ops) {\n    /**\n     * @param {Event} [e]\n     */\n    let ev = e=> {  \n        e?.preventDefault();\n        e?.stopPropagation();  \n\n        let fetchData = {\n            ...ops,\n            ...ops.profiles?.[el.dataset[\"overrides\"] || \"\"] || JSON.parse(el.dataset[\"overrides\"] || \"{}\") || {},\n        };\n\n        /** @type {any} */ let target = e?.target;\n        if([\"click\", \"submit\"].includes(trigger) || [\"A\", \"FORM\"].includes(target?.nodeName)) {\n            history.pushState(\n                {fetchData, elId: el.id}, \n                \"\", \n                target?.href || target?.action || \"\"\n            );\n        }\n\n        _fetchHttp(\n            {\n                method: el.dataset[\"method\"]?.toLowerCase() || \"get\",\n                href: target?.href,\n                el\n            },\n            fetchData,\n            el=> {if(el) _registerSubs(el)}\n        );\n    }\n\n    if(trigger == \"mount\") {\n        ev();\n    }\n    else el.addEventListener(trigger, ev);\n}","import { _store, _addToNextTickQueue } from \"./store.js\";\nimport { _registerSubs, _setOptions } from \"./domRegistrar.js\";\nimport { _scheduleDomUpdate } from \"./domUpdates.js\";\n\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\n\n/**!\n * @typedef {object} ExternalOptions\n * @property {string} domain - The domain name these settings apply to\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\n * @property {boolean} [styles] - Allow styles from this domain to apply\n */\n\n/**!\n * @typedef {object} FetchOptions\n * @property {RequestInit} [request] - Fetch request options\n * @property {\"json\"|\"text\"} [type] - Response type (default: \"text\")\n * @property {(val: any)=> void} [cb] - Callback function - run on successful fetch; *val* is the un-parsed response body\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\n * @property {(code: number)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\n * @property {boolean} [auto] - Automatically fetch content on page load\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\n */\n\n/**!\n * @typedef {object} TransitionOptions\n * @property {string} [class] - CSS class applied to transitions (default: `cu-trans`)\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\n */\n\n/**!\n * Manifold options for `fetch`, `trans`, and `profiles`.\n * @typedef {Object} MfldOps\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\n */\n\n/**!\n * @template T\n * @callback UpdaterFunction\n * @param {Array<any>} upstreamValues\n * @param {T} value\n * @returns {Promise<T>}\n */\n\n/**!\n * @template T\n * @typedef {Object} StoreOptions\n * @property {T} [value]\n * @property {Array<string>} [upstream]\n * @property {UpdaterFunction<T>} [updater]\n */\n\n/**!\n * @template T\n * @typedef Store\n * @prop {T} value - The store's current value (read only)\n * @prop {function(T | function(T):T|Promise<T>|undefined):T|Promise<T>|undefined} update - Update the store's current value\n * @prop {function(function(T):void):void} sub - Add a subscription function to the store\n */\n\n/**!\n * @typedef {Function} MfldFunc\n * @param {any} val\n * @param {HTMLElement} [el]\n */\n\n/**!\n * The global Manifold interface.\n */\nexport const Mfld = {\nstore: \n/**!\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @template T\n* @param {string} store_name\n* @param {StoreOptions<T> | T} store_ops\n* @return {Store<T>}\n*/ (store_name, store_ops)=> {\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\n    }\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\n},\nustore: \n/**!\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @param {string} store_name\n* @param {StoreOptions<any> | any} store_ops\n* @return {Store<any>}\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\nget:\n/**!\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\n * @param {string} store_name\n * @return {Store<any>}\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\nfunc: \n/**!\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\n * @param {string} func_name\n * @return {MfldFunc}\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(globalThis.Mfld_funcs.get(func_name)),\nfuncs: \n/**!\n * - Add functions to the Manifold function registry in key-value pairs.\n * - Functions must be registered in order to be accessible to HTML elements via `bind`, `sync`, and `resolve`. \n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\n * @param {{ [key: string]: MfldFunc }} funcs\n */ funcs=> {for(let key in funcs) globalThis.Mfld_funcs.set(key, funcs[key])},\nconfig:\n/**!\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `cu-overrides`).\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\n * @param {MfldOps} new_ops\n * @param {string} [profile_name]\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\n onTick:\n /**!\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\n  * @param {()=> void} cb\n  */ (cb)=> _addToNextTickQueue(cb),\n};"],"names":["_hashAny","input","Map","entries","Set","Array","from","Date","now","hash","char","TextEncoder","encode","toString","_nextTickQueue","globalThis","Mfld_stores","Mfld_funcs","_workCacheTimeout","_workOrder","Store","updater","undefined","_subscriptions","_storedHash","_downstreamStores","_upstreamStores","constructor","name","ops","this","set","upstream","storeName","_store","push","value","console","log","_addSub","ref","sub","repeat","replace","c","Math","floor","random","update","Promise","resolve","clearTimeout","setTimeout","async","_","store","forEach","d","delete","u","has","downstream","newValue","valueChanged","length","size","newHash","S","clear","_autoUpdate","fn","map","get","smartOutro","workArray","cancelAnimationFrame","_scheduleDomUpdate","requestAnimationFrame","_runDomUpdates","order","includes","relation","container","document","createElement","child","out","childNodes","appendChild","replaceChildren","_applyTransition","space","in","adjust","after","done","el","dir","nodeType","Node","TEXT_NODE","text","textContent","newNode","replaceWith","dur","isArray","trans","transClass","class","classList","add","hooks","style","transitionDuration","remove","swap","parser","DOMParser","commaSepRx","elIdx","ds","currentScript","dataset","config","_setOptions","JSON","parse","e","warn","init","parent","els","querySelectorAll","modes","join","fetch","auto","id","mode","shouldHaveTriggers","err_detail","split","setting","processFunc","_parts","triggers","_paramsInParens","splice","processFuncName","match","external","internal","externalData","ext","sourcePathArr","path","sp","isNaN","parseInt","filter","trigger","_handleFetch","i","domSubscription","s","_nestedValue","dispatchEvent","CustomEvent","ev","trim","curVal","addEventListener","_registerSubs","_intialize","newops","profileName","profiles","obj","newval","ptr","key","str","matches","preventDefault","stopPropagation","fetchData","target","nodeName","history","pushState","elId","href","action","externals","some","allowed","startsWith","domain","fOps","data","request","method","body","stringify","catch","error","err","code","status","onCode","type","cb","parseFromString","_fetchHttp","toLowerCase","Mfld","store_name","store_ops","hasOwnProperty","ustore","func","func_name","funcs","new_ops","profile_name","onTick"],"mappings":"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"}