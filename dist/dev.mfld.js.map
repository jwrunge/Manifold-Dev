{"version":3,"file":"dev.mfld.js","sources":["../src/util.js","../src/updates.js","../src/store.js","../src/fetch.js","../src/domutil.js","../src/bindsync.js","../src/templates.js","../src/registrar.js","../src/index.js"],"sourcesContent":["export let ATTR_PREFIX = \"mf_\";\r\nexport let _inputNestSplitRx = /[\\.\\[\\]\\?]{1,}/g;\r\nexport let _commaSepRx = /, {0,}/g;\r\n\r\nexport function _randomEnoughId() {\r\n    return `${Date.now()}.${Math.floor(Math.random() * 100_000)}`;\r\n}\r\n\r\nfunction _getOverride(name, el, ops, parse = true, def = \"{}\", as) {\r\n    let override = el.dataset[`${ATTR_PREFIX}${name}`];\r\n    if(!override) return undefined;\r\n    if(name == \"overrides\") return ops.profiles?.[override || \"\"]?.fetch || JSON.parse(override || \"{}\");\r\n    if(parse) return JSON.parse(override || def);\r\n    if(as == \"num\") return parseInt(override) || undefined;\r\n    if(as == \"bool\") return override == \"true\" ? true : override == \"false\" ? false : undefined;\r\n    return override;\r\n}\r\n\r\n/**\r\n * Get or set nested store values\r\n * @param {import(\".\").MfldOps} ops\r\n * @param {HTMLElement} el\r\n * @returns {import(\".\").MfldOps}\r\n */\r\nexport function _getOpOverrides(ops, el) {\r\n    let overrides = _getOverride(\"overrides\", el, ops);\r\n\r\n    let newops = {\r\n        profiles: ops.profiles,\r\n        fetch: {\r\n            ...ops.fetch,\r\n            ...{\r\n                responseType: _getOverride(\"responsetype\", el, ops, false) || ops.fetch?.responseType\r\n            },\r\n            ...(overrides?.fetch || {}),\r\n            ...(_getOverride(\"fetch\", el, ops) || {}),\r\n        },\r\n        trans: {\r\n            ...ops.trans,\r\n            ...{\r\n                dur: _getOverride(\"transdur\", el, ops, true, \"[]\", \"num\") || ops.trans?.dur,\r\n                swap: _getOverride(\"transswap\", el, ops, false, \"\", \"num\") || ops.trans?.swap,\r\n                class: _getOverride(\"transclass\", el, ops, false) || ops.trans?.class,\r\n                smartTransition: _getOverride(\"transsmart\", el, ops, false, undefined, \"bool\") || ops.trans?.smartTransition,\r\n            },\r\n            ...(overrides?.trans || {}),\r\n            ...(_getOverride(\"trans\", el, ops) || {}),\r\n        },\r\n    }\r\n\r\n    return newops;\r\n}\r\n\r\nfunction _parseValues(values) {\r\n    if(typeof values == \"string\") values = values.split(/\\s{0,},\\s{0,}/);\r\n    return values.map(v=> v.split(_inputNestSplitRx)?.[0]) || [];\r\n}\r\n\r\n/**\r\n * @param {{el: HTMLElement, datakey: string} | string} condition \r\n * @returns {{ valueList?: string[], func?: Function, as?: string[] }}\r\n */\r\nexport function _parseFunction(condition) {\r\n    if(typeof condition != \"string\") {\r\n        condition = condition?.el?.dataset?.[condition?.datakey] || \"\";\r\n        if(!condition && /** @type {any}*/(condition)?.el?.dataset?.[`${ATTR_PREFIX}else`] != undefined) condition = \"return true\";\r\n    }\r\n\r\n    let [fstr, values] = condition?.split(\"=>\")?.map(s=> s.trim())?.reverse() || [\"\", \"\"];\r\n    let [fn, asStr] = fstr?.split(/\\s{1,}as\\s{1,}/) || [fstr, \"value\"];\r\n    let as = asStr?.split?.(_commaSepRx)?.map?.(s=> s.trim()) || [\"value\"];\r\n\r\n    // Set up function to evaluate store values\r\n    let valueList = values?.split(\",\")?.map(s=> s.replace(/[()]/g, \"\").trim()) || [];\r\n    // @ts-ignore\r\n    let func = globalThis[fn] || MfFn[fn];\r\n    if(!func) {\r\n        // If function is not found, try to create it; account for implicit returns\r\n        if(!valueList?.length && !fn.includes(\"=>\")) {\r\n            if(!fn.match(/\\(|\\)/)) {\r\n                valueList = [fn];\r\n                fn = `return ${fn}`;\r\n            }\r\n            else {\r\n                valueList = fn.match(/\\([^\\)]{1,}\\)/)?.[0]?.replace(/[\\(\\) ]/g, \"\").split(\",\").filter(s=> !s.match(/[\\\"\\'\\`]/)) || [];\r\n            }\r\n        }\r\n\r\n        valueList = _parseValues(valueList);\r\n        if(!fn.match(/^\\s{0,}\\{/) && !fn.includes(\"return\")) fn = fn.replace(/^\\s{0,}/, \"return \");\r\n        try {\r\n            func = new Function(...valueList, fn);\r\n        }\r\n        catch(e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n\r\n    return { valueList, func, as };\r\n}\r\n\r\n// @ts-ignore\r\nwindow.parse = _parseFunction;\r\n\r\nexport function _evalInputs(inputs) {\r\n    let values = [];\r\n    for(let input of inputs) {\r\n        // @ts-ignore\r\n        let S = MfSt.get(input);\r\n        values.push(S.value || globalThis.value);\r\n    }\r\n    return values;\r\n}","/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\nimport { ATTR_PREFIX } from \"./util.js\";\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = false;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n/** @type {HTMLElement | null} */\r\nlet spacer;\r\nlet spacerHeight = \"\";\r\n\r\n// Polyfill requestAnimationFrame\r\nlet tick = globalThis?.requestAnimationFrame || ((fn)=> setTimeout(fn, 0));\r\n\r\nexport function _addToNextTickQueue(fn) {\r\n    if(fn) _nextTickQueue.push(fn);\r\n}\r\n\r\n/** @export @param {(DomWorkOrder | Function)} update */\r\nexport function _scheduleUpdate(update) {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = true;\r\n        tick(_runUpdates);\r\n    }\r\n}\r\n\r\nfunction _addSpacer(inEl, wrapper, wrapperHeight, replaceWholeObject = false, ops) {\r\n    if(!ops.trans?.smartTransition ?? true) return;\r\n    //Conserve parent size\r\n    spacer = document.createElement(\"div\");\r\n    \r\n    let { paddingTop, paddingBottom } = wrapper instanceof Element ? window.getComputedStyle(wrapper) : { paddingTop: 0, paddingBottom: 0 };\r\n    spacerHeight = spacer.style.height = `calc(${(Math.abs(wrapperHeight - (inEl?.clientHeight || 0)))}px - ${paddingTop} - ${paddingBottom})`;\r\n\r\n    wrapper?.after(spacer);\r\n}\r\n\r\nfunction _adjustSizing(inEl, ops) {\r\n    if(!ops.trans?.smartTransition ?? true) return;\r\n    let dur = (ops?.trans?.dur?.[0] || ops?.trans?.dur || 600)/2\r\n\r\n    _scheduleUpdate(()=> {\r\n        spacer?.remove();\r\n        inEl?.animate?.([\r\n            { height: spacerHeight },\r\n            { height: `${inEl.clientHeight || 0}px` }\r\n        ], dur);\r\n    });\r\n}\r\n\r\nfunction _runUpdates() {\r\n    cancelAnimationFrame = false;\r\n    \r\n    /**\r\n    * @type {DomWorkOrder[]}\r\n    */\r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") (/** @type {Function} */ order)();\r\n        else {\r\n            let wrapperHeight = order.out ? order.out.clientHeight : 0;\r\n\r\n            // Prepend\r\n            if(order.relation == \"prepend\") {\r\n                _addSpacer?.(order.in, order.out, wrapperHeight, false, order.ops);\r\n\r\n                //Prepend\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) order.out?.prepend(order.in);\r\n                    _adjustSizing?.(order.in, order.ops);\r\n                });\r\n            }\r\n            // Remove old children\r\n            else {\r\n                if([\"swapinner\", \"swapouter\"].includes(order.relation)) {\r\n                    //Remove old children before appending (if swapping children)\r\n                    let container = /** @type {HTMLElement | null}*/(order.out?.cloneNode(true));\r\n\r\n                    if(container) {\r\n                        order.out?.after(container);\r\n                        let getDimensionsAfterUpdate = order.relation == \"swapinner\" ? true : false;\r\n\r\n                        if(order.relation == \"swapinner\") {\r\n                            container.style.border = \"none\";\r\n                            order.out.replaceChildren();\r\n                        }\r\n\r\n                        // Transition old children out\r\n                        _applyTransition(container, \"out\", order.ops, undefined, order.out, getDimensionsAfterUpdate);\r\n                    }\r\n                }\r\n\r\n                _addSpacer?.(order.in, order.out, wrapperHeight, false, order.ops);\r\n\r\n                // Transition incoming element and append\r\n                _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                    if(order.in) {\r\n                        if(order.relation == \"swapouter\") order.out?.replaceWith(order.in)\r\n                        else order.out?.appendChild(order.in);\r\n                    }\r\n                    _adjustSizing?.(order.in, order.ops);\r\n                });\r\n            }\r\n\r\n            order.done?.(order.in);\r\n        }\r\n    }\r\n\r\n    //Handle queued nextTick functions\r\n    for(let fn of _nextTickQueue) fn();\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @param {HTMLElement} [refElement]\r\n * @param {boolean} [getDimensionsAfterUpdate]\r\n * @returns \r\n */\r\nexport function _applyTransition(el, dir, ops, fn, refElement, getDimensionsAfterUpdate = false) {\r\n    //Handle text nodes\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        let text = el.textContent;\r\n        let newNode = document?.createElement(\"div\");\r\n        newNode.textContent = text;\r\n        el.replaceWith(newNode);\r\n        el = newNode;\r\n    }\r\n\r\n    if(el) {\r\n        let dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n\r\n        //Initiate transition\r\n        let transClass = ops?.trans?.class || `${ATTR_PREFIX}trans`;\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        //Wait to apply class\r\n        if(dir == \"out\") {\r\n            // Set dimensions\r\n            if(!refElement) refElement = el;\r\n            if(!refElement) return;\r\n            let dimensions = {};\r\n            if((ops.trans?.smartTransition ?? true) && getDimensionsAfterUpdate == false) {\r\n                let style = getComputedStyle(refElement);\r\n                dimensions.w = `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`;\r\n                dimensions.left = `calc(${refElement.getBoundingClientRect().left}px + ${window.scrollX}px)`;\r\n                dimensions.top = `calc(${refElement.getBoundingClientRect().top}px + ${window.scrollY}px)`;\r\n            }\r\n\r\n            _scheduleUpdate(()=> {\r\n                if(ops.trans?.smartTransition ?? true) {\r\n                    if(getDimensionsAfterUpdate && refElement) {\r\n                        let style = getComputedStyle(refElement);\r\n                        dimensions.w = `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`;\r\n                        dimensions.left = `calc(${refElement.getBoundingClientRect().left}px + ${window.scrollX}px)`;\r\n                        dimensions.top = `calc(${refElement.getBoundingClientRect().top}px + ${window.scrollY}px)`;\r\n                    }\r\n                    \r\n                    el.style.position = \"fixed\";\r\n                    el.style.width = dimensions.w;\r\n                    el.style.left = dimensions.left;\r\n                    el.style.top = dimensions.top;\r\n                    el.style.margin = \"0\";\r\n                }\r\n\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n                el.classList?.add(\"out\");\r\n            })\r\n        }\r\n        //If dir == in\r\n        else {\r\n            el?.classList?.add(\"in\");\r\n            if(dur) el.style.transitionDuration = `${dur}ms`;\r\n            fn?.();\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    setTimeout(()=> _scheduleUpdate(()=> el?.classList?.remove(dir)), 0);\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                //Wrapup\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}","/** \n * @template T\n * @typedef {import(\"./index.js\").UpdaterFunction<T>} UpdaterFunction \n */\n/** \n * @template T\n * @typedef {import(\"./index.js\").StoreOptions<T>} StoreOptions \n */\n\nimport { _scheduleUpdate } from \"./updates.js\";\nimport { _randomEnoughId } from \"./util.js\";\n\n/**\n * @callback SubFunction\n * @param {any} value\n * @param {string} [ref]\n * @returns {void}\n */\n\n/**\n * @param {any} input \n * @returns {any}\n */\nfunction _hashAny(input) {\n    if(!input) return 0;\n    if(typeof input == 'number') return input;\n    if(input === true) return 1;\n\n    if(input instanceof Map) return _hashAny(Array.from(input.entries()));\n    else if(input instanceof Set) return _hashAny(Array.from(input));\n\n    let hash = 0;\n    for(let char of new TextEncoder().encode(\n        typeof input == 'string' ? input : input?.toString() || \"\"\n    )) \n        hash = ((hash << 5) - hash) + char;\n    return hash;\n}\n\n//Static\n/** @type {Map<string, Store<any>>} */ if(!globalThis.MfSt) globalThis.MfSt = new Map();\n/** @type {{[key: string]: Function}} */ if(!globalThis.MfFn) globalThis.MfFn = {};\n/** @type {Map<Element, {toDestroy: Set<Store<any>>, observer: MutationObserver}>} */ if(!globalThis.MfMutOb) globalThis.MfMutOb = new Map();\n\n/**\n * @template T\n */\nexport class Store {\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\n    /** @type {string | undefined} */ _storedHash = undefined;\n    /** @type {Set<Store<any>>} */ _upstreamStores = new Set();\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\n    /** @type {HTMLElement | SVGScriptElement | string | \"global\"} */ _scope;\n    /** @type {any | undefined} */ _updateTimeout;\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    constructor(name, ops) {\n        return this._modify(name, ops);        \n    }\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    _modify(name, ops) {\n        this.name = name;\n        this._scope = ops?.scope || document.currentScript || \"global\";\n        // @ts-ignore\n        MfSt.set(name, this);\n\n        //Watch for scope destroy\n        // Watch for scope destroy\n        if(this._scope instanceof Element) {\n            // @ts-ignore\n            let mutOb = MfMutOb.get(this._scope);\n            if(!mutOb) {\n                mutOb = {};\n                mutOb.toRemove = new Set();\n                mutOb.observer = new MutationObserver((muts)=> {\n                    for(let mut of muts) {\n                        if(mut.type == \"childList\") {\n                            for(let node of mut.removedNodes) {\n                                if(node instanceof Element) {\n                                    for(let store of mutOb.toRemove) {\n                                        if(store._scope == node) {\n                                            let scope = this._scope;\n                                            _destroy(store);\n                                            mutOb.observer.disconnect();\n                                            mutOb.toRemove.delete(store);\n                                            // @ts-ignore\n                                            MfMutOb.delete(scope)\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n                /** @type {MutationObserver}*/(mutOb.observer).observe(/** @type {HTMLElement}*/(this._scope?.parentElement), { childList: true });\n            }\n            mutOb.toRemove.add(this);\n            // @ts-ignore\n            MfMutOb.set(this._scope, mutOb);\n        }\n        \n        (ops?.upstream?.map(s=> {\n            let S = _store(s);\n            this._upstreamStores.add(S);\n            S._downstreamStores.add(this);\n            return S;\n        }) || []);\n\n        this.value = ops?.value;\n        this._updater = ops?.updater;\n        this._auto_update();\n        return this;\n    }\n\n    /**\n     * @param {(T)=> void} sub\n     * @param {string | undefined} [ref]\n     * @param {boolean} [immediate]\n     */\n    sub(sub, ref, immediate = true) {\n        this._subscriptions.set(ref || _randomEnoughId(), sub);\n        if(immediate) sub?.(this.value);\n    }\n\n    //Update (manual or automated -- cascades downstream on batch updates)\n    /**\n    * @template T\n    * @param {T | ((T)=> T | Promise<T>)} value\n    */\n    async update(value) {\n        return new Promise(async (resolve)=> {\n            // Group updates\n            if(this._updateTimeout) clearTimeout(this._updateTimeout);\n            this._updateTimeout = setTimeout(()=> {\n\n                _scheduleUpdate(async ()=> {\n                    //Apply new value   \n                    let newValue = (typeof value == \"function\" ? /** @type {Function} */(await value)?.(this.value) : value);\n                    let newHash = _hashAny(newValue);\n                    \n                    if(newHash !== this._storedHash) {\n                        this.value = newValue;\n                        this._storedHash = newHash;\n\n                        // Add this store to the work order\n                        for(let ds of this._downstreamStores) await ds._auto_update();\n\n                        // Wait for next animation frame to return the value\n                        for(let [ref, sub] of this?._subscriptions || []) sub?.(this.value, ref);\n                        resolve(this.value);\n                    }\n                    else {\n                        resolve(this.value);\n                    }\n                });\n            }, 0);\n        });\n    }\n\n    async clearHash() {\n        this._storedHash = undefined;\n    }\n\n    async _auto_update() {\n        let newVal = await this._updater?.(\n            Array.from(this._upstreamStores)?.map(S => S?.value) || [], \n            /** @type {T} */(this?.value)\n        );\n\n        await this.update(newVal === undefined ? this.value : newVal);\n    }\n}\n\n/**\n * STORE STATIC METHODS\n */\n/**\n * @template T\n * @param {string} name - The name of the store\n * @param {StoreOptions<T> | T} [ops] - Options to update the store\n * @returns {Store<T>}\n */\nexport function _store(name, ops) {\n    // @ts-ignore\n    let found_store = MfSt.get(name);\n    if(ops) {\n        if(found_store) {\n            return found_store._modify(name, ops);\n        }\n        return new Store(name, ops);\n    }\n    return found_store || new Store(name, /** @type {StoreOptions<T>}*/(ops));\n}\n\n/**\n * @param {HTMLElement | string} scope \n */\nexport function _clearScope(scope) {\n    // @ts-ignore\n    for(let store of MfSt.values()) {\n        if(store._scope == scope) _destroy(store);\n    }\n}\n\n/**\n * @param {Store<any>} store \n */\nexport function _destroy(store) {\n    store._subscriptions.clear();\n    store._upstreamStores.clear();\n    store._downstreamStores.clear();\n    // @ts-ignore\n    MfSt.delete(store.name);\n    // @ts-ignore\n    store = undefined;\n}","import { _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _registerSubs } from \"./registrar.js\";\r\nimport { _store } from \"./store.js\";\r\n\r\n/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {string} trigger \r\n * @param {MfldOps} fetchOps\r\n * @param {string} href\r\n * @param {string} [method] \r\n * @param {any[] | \"$form\"} [valueList]\r\n * @param {Function} [processFunc]\r\n */\r\nexport function _handleFetch(el, trigger, fetchOps, href, method, valueList, processFunc) {\r\n    /**\r\n     * @param {Event} [e]\r\n     */\r\n    let ev = async e=> {  \r\n        e?.preventDefault();\r\n        e?.stopPropagation();\r\n\r\n        // Set from target element if relevant; fall back to \"get\"\r\n        if(!method) method = /** @type {any}*/(e?.target)?.method || \"get\";\r\n    \r\n        //Make sure we're allowed to fetch\r\n        let externalPermissions = fetchOps?.fetch?.externals?.find(allowed=> href?.startsWith(allowed.domain)) || \r\n            !href.match(/^https?:\\/\\//) || href.includes(location.origin) ? {\r\n                scripts: true,\r\n                styles: true,\r\n        } : undefined;\r\n\r\n        // Parse input\r\n        let input = processFunc?.(...(valueList || [])) || valueList;\r\n        let body = Array.isArray(input) ? input[0] : input == \"$form\" ? new FormData(/** @type {HTMLFormElement}*/(el)) : input;\r\n        if(processFunc) {\r\n            let toFunc = Array.isArray(input) ? (input?.map(s=> _store(s).value) || []) : [body];\r\n            body = processFunc?.(...toFunc)\r\n        }\r\n\r\n        //Fetch data\r\n        let data = await fetch(href, {\r\n            ...(fetchOps?.fetch?.request || {}),\r\n            headers: {\r\n                ...fetchOps?.fetch?.request?.headers,\r\n                \"Manifold-App-Fetch\": \"true\",\r\n            },\r\n            method,\r\n            body: input == \"$form\" || typeof body == \"string\" ? body : JSON.stringify(body),\r\n        })\r\n        .catch(error=> {\r\n            fetchOps?.fetch?.err?.(error) || console.error(\"FETCH ERROR\", error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fetchOps?.fetch?.onCode?.(code, data) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let resp = await data?.[fetchOps?.fetch?.responseType || \"text\"]();\r\n\r\n        // Handle resolutions\r\n        for(let instruction of [\"append\", \"prepend\", \"swapinner\", \"swapouter\"]) {\r\n            let ds = el.dataset[`${ATTR_PREFIX}${instruction}`];\r\n            if(ds === undefined) continue;\r\n            let [selector, toReplace] = ds?.split(\"->\").map(s=> s.trim()) || [];\r\n\r\n            //Extract content and schedule a DOM update\r\n            let fullMarkup = (new DOMParser())?.parseFromString?.(resp, 'text/html');\r\n            if(fullMarkup) {\r\n                _scheduleUpdate({\r\n                    in: /** @type {HTMLElement} */ (fullMarkup.querySelector(selector || \"body\")),\r\n                    out: /** @type {HTMLElement} */ (toReplace ? document.querySelector(toReplace) : el),\r\n                    relation: /** @type {\"append\" | \"prepend\" | \"swapinner\" | \"swapouter\"}*/(instruction),\r\n                    ops: fetchOps,\r\n                    done: (el)=> {\r\n                        _registerSubs(el)\r\n                    },\r\n                });\r\n            }\r\n        }\r\n\r\n        //Push to history if requested\r\n        if(el.dataset?.[`${ATTR_PREFIX}pushstate`] !== undefined) {\r\n            history.pushState({}, \"\", href);\r\n        }\r\n\r\n        let resolveTxt = el.dataset?.[`${ATTR_PREFIX}resolve`];\r\n        let resolveFunc = _parseFunction(resolveTxt || \"\")?.func;\r\n        resolveFunc?.(resp);\r\n\r\n            // //Clear existing scripts/styles\r\n            // for(let s of [pageScripts, pageStyles]) {\r\n            //     let elements = s.get(fullMarkup) || [];\r\n            //     elements.forEach(el => el.remove());\r\n            //     s.set(fullMarkup, []);\r\n            // }\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n    }\r\n\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}","import { _store } from \"./store\";\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n * @returns {HTMLElement}\r\n */\r\nexport function _ensureNodeName(el, nodeName, skipAttributes = [], removeClasses = []) {\r\n    // Make sure this is a template\r\n    if(el.tagName != nodeName) {\r\n        let newEl = document.createElement(nodeName);\r\n        newEl.innerHTML = el.innerHTML;       \r\n        for(let attr of el.attributes) {\r\n            if(!skipAttributes.includes(attr.name)) newEl.setAttribute(attr.name, attr.value);\r\n        }\r\n        for(let cls of removeClasses) {\r\n            newEl.classList.remove(cls);\r\n        }\r\n        el.replaceWith(newEl);\r\n\r\n        // If not, it's default content\r\n        return newEl;\r\n    }\r\n    return el;\r\n}\r\n\r\n/**\r\n * @param {any} obj \r\n * @param {(value: any, index: any, array?: any)=> void} cb \r\n */\r\nexport function _iterable(obj, cb) {\r\n    if(obj instanceof Map) for(const [key, value] of obj.entries()) cb(key, value);\r\n    else {\r\n        try { \r\n            let arr = Array.from(obj);\r\n            if(arr?.length) arr.forEach(cb);\r\n            else for(let key in obj) cb(key, obj[key]);\r\n        }\r\n        catch(e) { console.error(`${obj} is not iterable`); }\r\n    }\r\n}\r\n\r\n// Returns the sibling that fails the condition\r\n/**\r\n * @param {Element | null} [sib] \r\n * @param {Function} [breakFn] \r\n * @param {Function} [cb] \r\n * @returns {Element | null | undefined}\r\n */\r\nexport function _iterateSiblings(sib, breakFn, cb) {\r\n    if(breakFn?.(sib)) return sib;\r\n    sib = cb?.(sib) || sib;\r\n    return _iterateSiblings(sib?.nextElementSibling, breakFn, cb);\r\n}\r\n\r\n/**\r\n * @typedef InternalStoreOptions\r\n * @property {Function} [func]\r\n * @property {HTMLElement} [observeEl]\r\n * @property {boolean} [allowFalse]\r\n */\r\n\r\n/**\r\n * @param {string} [storeName] \r\n * @param {string[]} [storeList] \r\n * @param {InternalStoreOptions} [options]\r\n * @returns \r\n */\r\nexport function _registerInternalStore(storeName, storeList, options) {\r\n    // Register new store (to prevent excess evaluations)\r\n    return _store(storeName || \"\", {\r\n        upstream: [...storeList || []],\r\n        updater: (list)=> {\r\n            try {\r\n                return options?.func?.(...list) || list[0];\r\n            }\r\n            catch(_) {\r\n                return;\r\n            }\r\n        },\r\n        scope: options?.observeEl,\r\n    });\r\n}\r\n","import { _registerInternalStore } from \"./domutil\";\r\nimport { _store } from \"./store\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _evalInputs, _inputNestSplitRx, _randomEnoughId } from \"./util\";\r\n\r\nexport function _handleBindSync(el, inputs, output, trigger, mode, processFunc) {\r\n    /**\r\n     * HANDLE MF-BIND - inputs are stores, output is element property\r\n     */\r\n    if(mode.match(\"bind\")) {\r\n        _registerInternalStore(\r\n            _randomEnoughId(),\r\n            inputs,\r\n            {\r\n                observeEl: el,\r\n                func: ()=> {\r\n                    let val = processFunc?.(..._evalInputs(inputs), el);\r\n\r\n                    if(output && val != undefined) {\r\n                        let parts = output.split(\":\");\r\n                        switch(parts[0]) {\r\n                            case \"style\": el.style[parts[1]] = val; break;\r\n                            case \"attr\": el.setAttribute(parts[1], val); break;\r\n                            default: el[output] = val;\r\n                        }\r\n                    }\r\n\r\n                    //Make sure to update dependent stores on value update\r\n                    el.dispatchEvent(new CustomEvent(trigger));\r\n                    return val;\r\n                }\r\n            } \r\n        )\r\n    }\r\n\r\n    else {\r\n        /**\r\n         * HANDLE MF-SYNC - inputs are element properties, output is a store\r\n         */\r\n        let ev = ()=> {\r\n            if(inputs.length > 1) console.warn(\"Multiple sync props\", el);\r\n\r\n            // Get prop value\r\n            let parts = inputs?.[0].trim().split(\":\");\r\n            let val;\r\n            switch(parts[0]) {\r\n                case \"style\": val = el.style[parts[1]]; break;\r\n                case \"attr\": val = el.getAttribute(parts[1]); break;\r\n                default: val = el[parts[0]];\r\n            }\r\n\r\n            let numVal = parseFloat(val);\r\n            if(!isNaN(numVal)) val = numVal;\r\n\r\n            let value = processFunc?.(val, el);\r\n            if(output && value !== undefined) _store(output)?.update?.(value);\r\n        }\r\n        \r\n        if(trigger == \"$mount\") ev();\r\n        else el.addEventListener(trigger, ev);\r\n    }\r\n}","import { _ensureNodeName, _iterable, _iterateSiblings, _registerInternalStore } from \"./domutil\";\nimport { _registerSubs } from \"./registrar\";\nimport { _store } from \"./store\";\nimport { _applyTransition, _scheduleUpdate } from \"./updates\";\nimport { _parseFunction, _randomEnoughId, ATTR_PREFIX } from \"./util\";\n\n/**\n * Handle conditional and loop elements\n * @param {HTMLElement} el \n * @param {string} mode \n * @param {string[]} as \n * @param {Function | undefined} func\n * @param {any[]} valueList\n * @param {import(\".\").MfldOps} ops \n */\nexport function _handleTemplates(el, mode, as, func, valueList, ops) {\n    let startElement = document.createElement(\"template\");\n    let templ = /** @type {HTMLTemplateElement}*/(_ensureNodeName(/** @type {HTMLElement}*/(el.cloneNode(true)), \"TEMPLATE\"));\n    startElement.classList.add(`${mode}-start`);\n    templ.classList.add(`${mode}-end`);\n\n    templ.dataset.nodeName = el.nodeName;\n    el.before(startElement);\n    el.after(templ);\n    el.remove();\n\n    let templStore = _registerInternalStore(\n        _randomEnoughId(), \n        valueList, \n        { func, observeEl: templ }\n    );\n\n    // Clear old elements\n    templStore.sub(val=> {\n        _scheduleUpdate(()=> {\n            _iterateSiblings(\n                startElement?.nextElementSibling, \n                (sib)=> sib?.classList?.contains(`${mode}-end`),\n                (sib)=> _applyTransition(/** @type {HTMLElement}*/(sib), \"out\", ops, ()=> sib?.remove()), \n            );\n\n            let it = mode.match(/each/) ? _iterable : (object, cb)=> cb(object);\n\n            it(val, (val, key)=> {\n                if(val == undefined) return;\n                let html = templ?.innerHTML || templ?.textContent?.replace(/^\\n{0,}|\\n{0,}$/, \"\") || \"\";\n\n                // Get all logical bindings and replace values\n                let replacements = html.match(/\\${[^}]*}/g) || [];\n                for(let rep of replacements) {\n                    try {\n                        let fn = _parseFunction(`(${as.join(\",\")})=> ${rep.slice(2, rep.length-1)}`)?.func;\n                        html = html.replace(rep, fn?.(val, key) || \"\");\n                    }\n                    catch(e) {\n                        throw(e);\n                    }\n                }\n\n                let elms;\n                if(mode.match(/each/)) {\n                    let item = /** @type {HTMLTemplateElement}*/(templ.cloneNode(true));\n                    item.innerHTML = html || val;\n                    elms = item.content.children;\n                }\n                else {\n                    let item = /** @type {HTMLTemplateElement}*/(_ensureNodeName(/** @type {HTMLElement}*/(templ.cloneNode(true)), templ.dataset.nodeName, [\"data-node-name\", `data-${ATTR_PREFIX}`], [`${mode}-end`]));\n                    item.innerHTML = html || val;\n                    elms = [item];\n                }\n\n                // Replace values\n                for(let element of elms) {\n                    templ.before(element);\n                    _applyTransition(/** @type {HTMLElement}*/(element), \"in\", ops, ()=> _registerSubs(/** @type {HTMLElement}*/(element)));\n                }\n            });\n        });\n    });\n}","import { _store } from \"./store.js\";\nimport { _scheduleUpdate } from \"./updates.js\";\nimport { _commaSepRx, _getOpOverrides, _parseFunction, ATTR_PREFIX } from \"./util.js\";\nimport { _handleFetch } from \"./fetch.js\";\nimport { _handleBindSync } from \"./bindsync.js\";\nimport { _handleTemplates } from \"./templates.js\";\n/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\n\n/** @type {Partial<MfldOps>} */\nlet _ops = {};\nlet _modes = [\"bind\", \"sync\", \"templ\", \"if\", \"each\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\"].map(m=> `${ATTR_PREFIX}${m}`);\n\n/**!\n * @param {Partial<MfldOps>} newops \n * @param {string} [profileName] \n */\nexport function _setOptions(newops, profileName) {\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\n    else _ops = { ..._ops, ...newops };\n}\n\n// Handle location state changes\nglobalThis.addEventListener(\"popstate\", (e)=> {\n    // for(let update of e.state) {\n    //     _scheduleUpdate(update);\n    // }\n});\n\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\n/**\n * @param {HTMLElement | null} [parent] \n */\nexport function _registerSubs(parent) {\n    if(parent && parent.nodeType == Node.TEXT_NODE) return;\n\n    /** @type {NodeListOf<HTMLElement> | []} */\n    let els = (parent || document.body).querySelectorAll(\n        `[data-${_modes.join(`],[data-`)}],a,form`\n    ) || [];\n\n    for(let el of els) {\n        let _op_overrides = _getOpOverrides(_ops, el);\n\n        //Check for <a> and <form> elements\n        if(el.dataset?.[`${ATTR_PREFIX}promote`] !== undefined) {\n            let [mode, href, input, trigger] = el.tagName == \"A\" ?\n                [\"get\", /** @type {HTMLAnchorElement}*/(el).href, [], \"click\"] : \n                [/** @type {HTMLFormElement}*/(el).method.toLowerCase(), /** @type {HTMLFormElement}*/(el).action, \"$form\", \"submit\"];\n\n            if(href) {\n                _handleFetch(el, trigger, _op_overrides, href, mode, /** @type {any[] | \"$form\"}*/(input));\n                continue;\n            }\n        }\n\n        //Loop over all data attributes (modes)\n        for(let mode in el.dataset) {\n            if(!_modes.includes(mode)) continue;\n            let shouldHaveTriggers = !mode.match(/bind|templ|if|each/);\n\n            //Loop over provided settings\n            for(let setting of el.dataset?.[mode]?.split(\";;\") || []) {\n                //Break out settings\n                let [sourceParts, output] = setting?.split(\"->\")?.map(s=> s.trim()) || [];\n                let triggers = shouldHaveTriggers ? _paramsInParens(sourceParts.slice(0, sourceParts.indexOf(\")\"))) : [];\n                if(!output && mode.match(/get|head|post|put|delete|patch/)) {\n                    output = sourceParts.slice(sourceParts.indexOf(\")\") + 1);\n                    sourceParts = \"\";\n                }\n                let processFuncStr = shouldHaveTriggers ? sourceParts?.slice(sourceParts.indexOf(\")\") + 1) : sourceParts;\n\n                //Handle errors\n                if(shouldHaveTriggers && !triggers?.length) { console.error(\"No trigger\", el); break; }\n\n                let { func, valueList, as } = _parseFunction(processFuncStr);\n                if(processFuncStr && !func) console.warn(`\"${processFuncStr}\" not registered`, el);\n\n                //Handle conditionals and loops\n                if(mode.match(/if|each|templ/)) _handleTemplates(el, mode, as || [], func, valueList || [], _op_overrides);\n                else {\n                    //Loop over triggers\n                    if(!triggers?.length) triggers = [\"\"]\n                    for(let trigger of triggers) {\n                        if(mode.match(/bind|sync/)) _handleBindSync(el, valueList, output, trigger, mode, func);\n                        else {\n                            _handleFetch(el, trigger, _op_overrides, output, mode.replace(ATTR_PREFIX, \"\"), valueList, func);\n                        }\n                    }\n                }\n            }; //End loop settings\n        }; //End loop dataset\n    };  //End loop elements\n}\n\n/**\n * @param {string} str \n * @returns \n */\nfunction _paramsInParens(str) {\n    if(str?.includes(\"(\")) {\n        let matches = str.match(/[^\\(\\)]{1,}/g);\n        str = matches?.[matches.length - 1] || \"\";\n    }\n    return str?.split(_commaSepRx)?.map(s=> s.trim()) || [];\n}","import { _store } from \"./store.js\";\nimport { _addToNextTickQueue } from \"./updates.js\";\nimport { _registerSubs, _setOptions } from \"./registrar.js\";\n\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\n\n/**!\n * @typedef {object} ExternalOptions\n * @property {string} domain - The domain name these settings apply to\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\n * @property {boolean} [styles] - Allow styles from this domain to apply\n */\n\n/**!\n * @typedef {object} FetchOptions\n * @property {RequestInit} [request] - Fetch request options\n * @property {\"json\"|\"text\"} [responseType] - Response type (default: \"text\")\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\n * @property {(code: number, data: void | Response)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\n */\n\n/**!\n * @typedef {object} TransitionOptions\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\n * @property {boolean} [smartTransition] - Enable smart transitions (default: true)\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\n */\n\n/**!\n * Manifold options for `fetch`, `trans`, and `profiles`.\n * @typedef {Object} MfldOps\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\n */\n\n/**!\n * @template T\n * @callback UpdaterFunction\n * @param {Array<any>} upstreamValues\n * @param {T} value\n * @returns {T | Promise<T>}\n */\n\n/**!\n * @template T\n * @callback ValueDeterminer\n * @param {T} [currentValue]\n * @returns {T | Promise<T> | undefined}\n */\n\n/**!\n * @template T\n * @callback UpdateFunction\n * @param {T | ValueDeterminer<T>} value\n * @returns {T | Promise<T> | undefined}\n */\n\n/**!\n * @template T\n * @callback SubDeterminer\n * @param {T} value\n * @returns {void}\n */\n\n/**!\n * @template T\n * @callback SubFunction\n * @param {SubDeterminer<T>} value The store's current value\n * @returns void\n */\n\n/**!\n * @template T\n * @typedef {Object} StoreOptions\n * @property {T} [value]\n * @property {Array<string>} [upstream]\n * @property {UpdaterFunction<T>} [updater]\n * @property {HTMLElement | SVGScriptElement | \"global\"} [scope]\n */\n\n/**!\n * @template T\n * @typedef Store\n * @prop {T} value - The store's current value (read only)\n * @prop {UpdateFunction<T>} update - Update the store's current value\n * @prop {SubFunction<T>} sub - Add a subscription function to the store\n */\n\n/**!\n * @typedef {Function} MfldFunc\n * @param {any} val\n * @param {HTMLElement} [el]\n */\n\n/**!\n * The global Manifold interface.\n */\nexport let Mfld = {\nstore: \n/**!\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @template T\n* @param {string} store_name\n* @param {StoreOptions<T> | T} store_ops\n* @return {Store<T>}\n*/ (store_name, store_ops)=> {\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\n    }\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\n},\nustore: \n/**!\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @param {string} store_name\n* @param {StoreOptions<any> | any} store_ops\n* @return {Store<any>}\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\nget:\n/**!\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\n * @param {string} store_name\n * @return {Store<any>}\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\nfunc: \n/**!\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\n * @param {string} func_name\n * @return {MfldFunc}\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(\n// @ts-ignore\n MfFn[func_name]),\nfuncs: \n/**!\n * - Add functions to the Manifold function registry in key-value pairs.\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\n * @param {{ [key: string]: MfldFunc }} funcs\n */ funcs=> {\n    for(let key in funcs) {\n    // @ts-ignore\n    MfFn[key] = funcs[key];\n }},\nconfig:\n/**!\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\n * @param {MfldOps} new_ops\n * @param {string} [profile_name]\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\n onTick:\n /**!\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\n  * @param {()=> void} cb\n  */ (cb)=> _addToNextTickQueue(cb),\nregister:\n/**!\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\n * @param {HTMLElement | string | null} [parent]\n */ (parent)=> {\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\n        _registerSubs(parent)\n    },\n};"],"names":["ATTR_PREFIX","_inputNestSplitRx","_commaSepRx","_randomEnoughId","Date","now","Math","floor","random","_getOverride","name","el","ops","parse","def","as","override","dataset","profiles","fetch","JSON","parseInt","undefined","_getOpOverrides","overrides","responseType","trans","dur","swap","class","smartTransition","_parseFunction","condition","datakey","fstr","values","split","map","s","trim","reverse","fn","asStr","valueList","replace","func","globalThis","MfFn","length","includes","match","filter","v","_parseValues","Function","e","console","error","window","spacer","workArray","cancelAnimationFrame","_nextTickQueue","spacerHeight","tick","requestAnimationFrame","setTimeout","_scheduleUpdate","update","push","_runUpdates","_addSpacer","inEl","wrapper","wrapperHeight","replaceWholeObject","document","createElement","paddingTop","paddingBottom","Element","getComputedStyle","style","height","abs","clientHeight","after","_adjustSizing","remove","animate","order","out","relation","in","_applyTransition","prepend","container","cloneNode","getDimensionsAfterUpdate","border","replaceChildren","replaceWith","appendChild","done","dir","refElement","nodeType","Node","TEXT_NODE","text","textContent","newNode","Array","isArray","transClass","classList","add","hooks","dimensions","w","clientWidth","paddingLeft","paddingRight","left","getBoundingClientRect","scrollX","top","scrollY","position","width","margin","transitionDuration","_hashAny","input","Map","from","entries","Set","hash","char","TextEncoder","encode","toString","MfSt","MfMutOb","Store","_updater","_subscriptions","_storedHash","_upstreamStores","_downstreamStores","_scope","_updateTimeout","constructor","this","_modify","scope","currentScript","set","mutOb","get","toRemove","observer","MutationObserver","muts","mut","type","node","removedNodes","store","_destroy","disconnect","delete","observe","parentElement","childList","upstream","S","_store","value","updater","_auto_update","sub","ref","immediate","Promise","async","resolve","clearTimeout","newValue","newHash","ds","clearHash","newVal","found_store","clear","_handleFetch","trigger","fetchOps","href","method","processFunc","ev","preventDefault","stopPropagation","target","externals","find","allowed","startsWith","domain","location","origin","body","FormData","toFunc","data","request","headers","stringify","catch","err","code","status","onCode","resp","instruction","selector","toReplace","fullMarkup","DOMParser","parseFromString","querySelector","_registerSubs","history","pushState","resolveTxt","resolveFunc","addEventListener","_ensureNodeName","nodeName","skipAttributes","removeClasses","tagName","newEl","innerHTML","attr","attributes","setAttribute","cls","_iterable","obj","cb","key","arr","forEach","_iterateSiblings","sib","breakFn","nextElementSibling","_registerInternalStore","storeName","storeList","options","list","_","observeEl","_handleBindSync","inputs","output","mode","val","_evalInputs","parts","dispatchEvent","CustomEvent","warn","getAttribute","numVal","parseFloat","isNaN","_handleTemplates","startElement","templ","before","contains","object","elms","html","replacements","rep","join","slice","item","content","children","element","_ops","_modes","m","parent","els","querySelectorAll","_op_overrides","toLowerCase","action","shouldHaveTriggers","setting","sourceParts","triggers","_paramsInParens","indexOf","processFuncStr","str","matches","Mfld","store_name","store_ops","hasOwnProperty","ustore","func_name","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register"],"mappings":"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"}