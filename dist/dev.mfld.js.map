{"version":3,"file":"dev.mfld.js","sources":["../src/util.js","../src/updates.js","../src/store.js","../src/domutil.js","../src/bindsync.js","../src/templates.js","../src/registrar.js","../src/index.js"],"sourcesContent":["export let ATTR_PREFIX = \"mf_\";\r\nexport let _inputNestSplitRx = /[\\.\\[\\]\\?]{1,}/g;\r\nexport let _commaSepRx = /, {0,}/g;\r\n\r\nexport let _id = ()=> {\r\n    return `${Date.now()}.${Math.floor(Math.random() * 100_000)}`;\r\n}\r\n\r\n/** \r\n * @template T\r\n * @typedef {import(\"./store.js\").Store<T>} Store \r\n */\r\n\r\n/**!\r\n * @typedef {object} MFLDGlobal\r\n * @property {{[key: string]: Store<any>}} st\r\n * @property {{[key: string]: Function}} fn\r\n * @property {Map<HTMLElement, { toRemove: Set<Store<any>>, observer: MutationObserver }>} mut\r\n * @property {any} [iface]\r\n */\r\n\r\n/**!\r\n * @typedef {Window & { MFLD: MFLDGlobal }} MFLDWindowObj\r\n * @property {MFLDGlobal} MFLD\r\n */\r\n// @ts-ignore\r\nexport let _glob = /** @type {MFLDWindowObj}*/(window);\r\n\r\n/**\r\n * Get or set nested store values\r\n * @param {import(\".\").MfldOps} ops\r\n * @param {HTMLElement} el\r\n * @returns {import(\".\").MfldOps}\r\n */\r\nexport let _getOpOverrides = (ops, el)=> {\r\n    let overrides = ops.profiles?.[el.dataset?.override || \"\"];\r\n    let res = { ...ops, ...overrides };\r\n    \r\n    // ad hoc overrides\r\n    for(let set in el.dataset) {\r\n        console.log(\"SET\", set)\r\n        for(let key of [\"fetch\", \"trans\"]) {\r\n            if(set.startsWith(`${ATTR_PREFIX}${key}_`)) {\r\n                console.log(\"MATCH\", `${ATTR_PREFIX}${key}_`)\r\n                try {\r\n                    let prop = set.split(\"_\")[1];\r\n                    /** @type {any} */\r\n                    let val = el.dataset[set];\r\n                    if(val?.match(/\\{\\[/)) val = JSON.parse(val);\r\n                    if(parseInt(val)) val = parseInt(val);\r\n                    res[key][prop] = val;\r\n                    console.log(\"Got \", key, prop, val)\r\n                }\r\n                catch(e) {\r\n                    console.error(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    console.log(res)\r\n    return res;\r\n}\r\n\r\n/**\r\n * @param {string} condition \r\n * @returns {{ func?: Function, as?: string[] }}\r\n */\r\nexport let _parseFunction = (condition)=> {\r\n    let [fn, asStr] = condition?.split(/\\s{1,}as\\s{1,}/) || [condition, \"value\"],\r\n        fnText = `let $fn = globalThis.MFLD.fn; let $st = globalThis.MFLD.st; console.log($el, $fn, $st); console.log($el.value); console.log($fn); return ${fn}`,    // Take $el as a reference to the element; assign global refs to $fn and $st\r\n        as = asStr?.split?.(_commaSepRx)?.map?.(s=> s.trim()) || [\"value\"] || [],\r\n        func = new Function(\"$el\", fnText);\r\n\r\n    return { func, as };\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {Event} [ev]\r\n * @param {string} [href]\r\n */\r\nexport function _handlePushState(el, ev, href) {\r\n    ev?.preventDefault();\r\n\r\n    let pushState = el.dataset?.[`${ATTR_PREFIX}pushstate`];\r\n    /** @type {string | undefined} */\r\n    let push = href;\r\n    switch(pushState) {\r\n        case \"\": break;\r\n        case undefined: return;\r\n        default: push = `#${pushState}`\r\n    }\r\n\r\n    history.pushState(null, \"\", push);\r\n}","/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\nimport { _glob, ATTR_PREFIX } from \"./util.js\";\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"append\" | \"prepend\" | \"inner\" | \"outer\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = 0;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n/** @type {HTMLElement | null} */\r\nlet spacer;\r\nlet spacerHeight = \"\";\r\n\r\nexport let _addToNextTickQueue = (fn)=> {\r\n    fn && _nextTickQueue.push(fn);\r\n}\r\n\r\nexport let _scheduleUpdate = (update)=> {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = requestAnimationFrame(_runUpdates);\r\n    }\r\n}\r\n\r\nlet _addSpacer = (inEl, wrapper, wrapperHeight, ops)=> {\r\n    if(!(ops.trans?.smart ?? true)) return;\r\n    let { paddingTop, paddingBottom } = wrapper instanceof Element ? getComputedStyle(wrapper) : { paddingTop: 0, paddingBottom: 0 };\r\n    let spacer = document.createElement(\"div\");\r\n    spacer.style.height = `calc(${Math.abs(wrapperHeight - (inEl?.clientHeight || 0))}px - ${paddingTop} - ${paddingBottom})`;\r\n    wrapper?.after(spacer);\r\n}\r\n\r\nlet _adjustSizing = (inEl, ops)=> {\r\n    if(!ops.trans?.smart ?? true) return;\r\n    let dur = (ops?.trans?.dur?.[0] || ops?.trans?.dur || 600)/2\r\n    _scheduleUpdate(()=> {\r\n        spacer?.remove();\r\n        inEl?.animate?.([\r\n            { height: spacerHeight },\r\n            { height: `${inEl.clientHeight || 0}px` }\r\n        ], dur);\r\n    });\r\n}\r\n\r\nlet _runUpdates = ()=> {\r\n    cancelAnimationFrame = 0;\r\n    \r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") {\r\n            order();\r\n            continue;\r\n        }\r\n\r\n        let wrapperHeight = order.out ? order.out.clientHeight : 0;\r\n        let _getDimensionsAfterUpdate = order.relation == \"inner\";\r\n\r\n        if(order.relation == \"prepend\") {\r\n            _addSpacer?.(order.in, order.out, wrapperHeight, order.ops);\r\n            _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                order.out?.prepend(order.in);\r\n                _adjustSizing?.(order.in, order.ops);\r\n            });\r\n        }\r\n        else {\r\n            if([\"inner\", \"outer\"].includes(order.relation)) {\r\n                let container = /** @type {HTMLElement}*/(order.out?.cloneNode(true));\r\n                if(container) {\r\n                    order.out?.after(container);\r\n                    if(_getDimensionsAfterUpdate) {\r\n                        container.style.border = \"none\";\r\n                        order.out.replaceChildren();\r\n                    }\r\n                    _applyTransition(container, \"out\", order.ops, undefined, order.out, _getDimensionsAfterUpdate);\r\n                }\r\n            }\r\n\r\n            _addSpacer?.(order.in, order.out, wrapperHeight, order.ops);\r\n            _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                if(order.relation == \"outer\") order.out?.replaceWith(order.in)\r\n                else order.out?.appendChild(order.in);\r\n                _adjustSizing?.(order.in, order.ops);\r\n            });\r\n        }\r\n\r\n        order.done?.(order.in);\r\n    }\r\n\r\n    _nextTickQueue.forEach(fn => fn());\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @param {HTMLElement} [refElement]\r\n * @param {boolean} [_getDimensionsAfterUpdate]\r\n * @param {Function} [after]\r\n * @returns \r\n */\r\nexport let _applyTransition = (el, dir, ops, fn, refElement, _getDimensionsAfterUpdate = false, after)=> {\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        el.replaceWith(document?.createElement(\"div\"));\r\n        el.textContent = el.textContent;\r\n    }\r\n\r\n    if(el) {\r\n        const dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n        const transClass = ops?.trans?.class || `${ATTR_PREFIX}trans`;\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        if(dir == \"out\") {\r\n            refElement = refElement || el;\r\n            if(!refElement) return;\r\n            let dimensions = {};\r\n            if((ops.trans?.smart ?? true) && !_getDimensionsAfterUpdate) {\r\n                dimensions = _getDimensions(refElement);\r\n            }\r\n\r\n            _scheduleUpdate(()=> {\r\n                if((ops.trans?.smart ?? true) && _getDimensionsAfterUpdate && refElement) {\r\n                    dimensions = _getDimensions(refElement);\r\n                }\r\n\r\n                if(ops.trans?.smart ?? true) {\r\n                    el.style.position = \"fixed\";\r\n                    el.style.width = dimensions.w;\r\n                    el.style.left = dimensions.left;\r\n                    el.style.top = dimensions.top;\r\n                    el.style.margin = \"0\";\r\n                }\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n\r\n                el.classList?.add(\"out\");\r\n            })\r\n        }\r\n        else {\r\n            el?.classList?.add(\"in\");\r\n            if(dur) el.style.transitionDuration = `${dur}ms`;\r\n            fn?.();\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    setTimeout(()=> _scheduleUpdate(()=> el?.classList?.remove(dir)), 0);\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n                el.style.transitionDuration = \"\";\r\n                console.log(\"RUNNING AFTER\")\r\n                if(dir == \"in\") after?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}\r\n\r\nlet _getDimensions = (refElement)=> {\r\n    let style = getComputedStyle(refElement);\r\n    let rect = refElement.getBoundingClientRect();\r\n    return {\r\n        w: `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`,\r\n        left: `calc(${rect.left}px + ${_glob.scrollX}px)`,\r\n        top: `calc(${rect.top}px + ${_glob.scrollY}px)`\r\n    };\r\n}","/** \r\n * @template T\r\n * @typedef {import(\"./index.js\").UpdaterFunction<T>} UpdaterFunction \r\n */\r\n/** \r\n * @template T\r\n * @typedef {import(\"./index.js\").StoreOptions<T>} StoreOptions \r\n */\r\n\r\nimport { _scheduleUpdate } from \"./updates.js\";\r\nimport { _glob, _id } from \"./util.js\";\r\n\r\n/**\r\n * @callback SubFunction\r\n * @param {any} value\r\n * @param {string} [ref]\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * @param {any} input \r\n * @returns {any}\r\n */\r\nlet _hashAny = (input)=> {\r\n    if(!input) return 0;\r\n    if(typeof input == 'number' || input === true) return input;\r\n    if(input instanceof Map || input instanceof Set) return _hashAny(Array.from(input.entries() || input));\r\n\r\n    let hash = 0;\r\n    for(let char of new TextEncoder().encode(input?.toString() || \"\")) \r\n        hash = ((hash << 5) - hash) + char;\r\n    return hash;\r\n}\r\n\r\n//Static\r\nif(!_glob.MFLD) _glob.MFLD = {\r\n    st: {},\r\n    fn: {},\r\n    mut: new Map(),\r\n}\r\n\r\n/**\r\n * @template T\r\n */\r\nexport class Store {\r\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\r\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\r\n    /** @type {string | undefined} */ _storedHash = undefined;\r\n    /** @type {Set<Store<any>>} */ _upstreamStores = new Set();\r\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\r\n    /** @type {HTMLElement | SVGScriptElement | string | \"global\"} */ _scope;\r\n    /** @type {any | undefined} */ _updateTimeout;\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    constructor(name, ops) {\r\n        return this._modify(name, ops);        \r\n    }\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    _modify(name, ops) {\r\n        this.name = name;\r\n        this._scope = ops?.scope || document.currentScript || \"global\";\r\n        _glob.MFLD.st[name] = this;\r\n\r\n        //Watch for scope destroy\r\n        if(this._scope instanceof Element) {\r\n            let mutOb = _glob.MFLD.mut.get(/** @type {HTMLElement}*/(this._scope)) || { toRemove: new Set(), observer: /** @type {MutationObserver | null}*/(null) };\r\n            if(!mutOb.observer) {\r\n                mutOb.observer = new MutationObserver((muts)=> {\r\n                    for(let mut of muts) {\r\n                        if(mut.type == \"childList\") {\r\n                            for(let node of mut.removedNodes) {\r\n                                if(node instanceof Element) {\r\n                                    for(let store of mutOb.toRemove) {\r\n                                        if(store._scope == /** @type {HTMLElement}*/(node)) {\r\n                                            let scope = this._scope;\r\n                                            _destroy(store);\r\n                                            mutOb.observer?.disconnect();\r\n                                            mutOb.toRemove.delete(store);\r\n                                            // @ts-ignore\r\n                                            MFLD.mut.delete(scope)\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                /** @type {MutationObserver}*/(mutOb.observer).observe(/** @type {HTMLElement}*/(this._scope?.parentElement), { childList: true });\r\n            }\r\n            mutOb.toRemove.add(this);\r\n            // @ts-ignore\r\n            MFLD.mut.set(this._scope, mutOb);\r\n        }\r\n        \r\n        (ops?.upstream?.map(s=> {\r\n            let S = _store(s);\r\n            this._upstreamStores.add(S);\r\n            S._downstreamStores.add(this);\r\n            return S;\r\n        }) || []);\r\n\r\n        this.value = ops?.value;\r\n        this._updater = ops?.updater;\r\n        this._auto_update();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {(T)=> void} sub\r\n     * @param {string | undefined} [ref]\r\n     * @param {boolean} [immediate]\r\n     */\r\n    sub(sub, ref, immediate = true) {\r\n        this._subscriptions.set(ref || _id(), sub);\r\n        if(immediate) sub?.(this.value);\r\n    }\r\n\r\n    //Update (manual or automated -- cascades downstream on batch updates)\r\n    /**\r\n    * @template T\r\n    * @param {T | ((T)=> T | Promise<T>)} value\r\n    */\r\n    async update(value) {\r\n        return new Promise(async (resolve)=> {\r\n            // Group updates\r\n            if(this._updateTimeout) clearTimeout(this._updateTimeout);\r\n            this._updateTimeout = setTimeout(()=> {\r\n                _scheduleUpdate(async ()=> {\r\n                    //Apply new value   \r\n                    let newValue = (typeof value == \"function\" ? /** @type {Function} */(await value)?.(this.value) : value);\r\n                    let newHash = _hashAny(newValue);\r\n                    \r\n                    if(newHash !== this._storedHash) {\r\n                        this.value = newValue;\r\n                        this._storedHash = newHash;\r\n\r\n                        // Add this store to the work order\r\n                        for(let ds of this._downstreamStores) await ds._auto_update();\r\n\r\n                        // Wait for next animation frame to return the value\r\n                        for(let [ref, sub] of this?._subscriptions || []) sub?.(this.value, ref);\r\n                        resolve(this.value);\r\n                    }\r\n                    else {\r\n                        resolve(this.value);\r\n                    }\r\n                });\r\n            }, 0);\r\n        });\r\n    }\r\n\r\n    async _auto_update() {\r\n        let newVal = await this._updater?.(\r\n            Array.from(this._upstreamStores)?.map(S => S?.value) || [], \r\n            /** @type {T} */(this?.value)\r\n        );\r\n\r\n        await this.update(newVal === undefined ? this.value : newVal);\r\n    }\r\n}\r\n\r\n/**\r\n * STORE STATIC METHODS\r\n */\r\n/**\r\n * @template T\r\n * @param {string} name - The name of the store\r\n * @param {StoreOptions<T>} [ops] - Options to update the store\r\n * @returns {Store<T>}\r\n */\r\nexport let _store = (name, ops)=> {\r\n    let found_store = /** @type {Store<any>}*/(_glob.MFLD.st[name]);\r\n    return ops ? (found_store ? found_store._modify(name, ops) : new Store(name, ops)) : (found_store || new Store(name, ops));\r\n}\r\n/**\r\n * @param {HTMLElement | string} scope \r\n */\r\nexport let _clearScope = (scope)=> {\r\n    for(let store of Object.values(_glob.MFLD.st)) {\r\n        if(store._scope == scope) _destroy(store); \r\n    };\r\n}\r\n\r\n/**\r\n * @param {Store<any>} store \r\n */\r\nexport let _destroy = (store)=> {\r\n    // @ts-ignore\r\n    _glob.MFLD.st[store?.name || \"\"] = undefined;\r\n}","import { _store } from \"./store\";\r\nimport { _id } from \"./util\";\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n * @returns {HTMLTemplateElement}\r\n */\r\nexport let _ensureTemplate = (el)=> {\r\n    let nodeName = \"TEMPLATE\";\r\n    if(el.tagName == nodeName) return /** @type {HTMLTemplateElement}*/(el);\r\n\r\n    let newEl = /** @type {HTMLTemplateElement}*/(document.createElement(nodeName));\r\n    newEl.content.appendChild(el.cloneNode(true));\r\n    el.replaceWith(newEl);\r\n\r\n    return newEl;\r\n}\r\n\r\n/**\r\n * @param {any} obj \r\n * @param {(value: any, index: any)=> void} cb \r\n */\r\nexport let _iterable = (obj, cb)=> {\r\n    if(obj instanceof Map) for(const [key, value] of obj.entries()) cb(key, value);\r\n    else {\r\n        try { \r\n            let arr = Array.from(obj || []);\r\n            if(arr?.length) arr.forEach(cb);\r\n            else for(let key in obj) cb(key, obj[key]);\r\n        }\r\n        catch(e) { console.error(`${obj} is not iterable`); }\r\n    }\r\n}\r\n\r\n// Returns the sibling that fails the condition\r\n/**\r\n * @param {Element | null} [sib] \r\n * @param {Function} [breakFn] \r\n * @param {Function | null} [cb] \r\n * @returns {Element | null | undefined}\r\n */\r\nexport function _iterateSiblings(sib, breakFn, cb, reverse = false) {\r\n    let dir = reverse ? \"previousElementSibling\" : \"nextElementSibling\";\r\n    return breakFn?.(sib) ? sib : _iterateSiblings((cb?.(sib) || sib)?.[dir], breakFn, cb, reverse);\r\n}\r\n\r\n/**\r\n * @typedef InternalStoreOptions\r\n * @property {Function} [func]\r\n * @property {HTMLElement} [observeEl]\r\n */\r\n\r\n/**\r\n * @param {string[]} storeList\r\n * @param {InternalStoreOptions} options\r\n * @returns \r\n */\r\nexport let _registerInternalStore = (storeList, options)=> {\r\n    // Register new store (to prevent excess evaluations)\r\n    return _store(_id(), {\r\n        upstream: [...(storeList || [])],\r\n        updater: ()=> options?.func?.(options.observeEl),\r\n        scope: options?.observeEl,\r\n    });\r\n}","import { _registerInternalStore } from \"./domutil\";\r\nimport { _store } from \"./store\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _glob, _handlePushState, _inputNestSplitRx } from \"./util\";\r\n\r\nexport let _handleBindSync = (el, output, trigger, mode, processFunc, dependencyList)=> {\r\n    if(mode.match(\"bind\")) {\r\n        output = output?.replace(/\\$el\\./, \"\") || \"\";\r\n        _registerInternalStore(dependencyList, {\r\n            observeEl: el,\r\n            func: ()=> {\r\n                let val = processFunc?.(el);\r\n                if(output && val != undefined) {\r\n                    let [type, attr] = output.split(\":\");\r\n                    if(type == \"style\") el.style[attr] = val;\r\n                    else if(type == \"attr\") el.setAttribute(attr, val);\r\n                    else el[output] = val;\r\n                }\r\n                el.dispatchEvent(new CustomEvent(trigger));\r\n                return val;\r\n            }\r\n        });\r\n    } else {\r\n        let ev = (e)=> {\r\n            console.log(\"EV\", processFunc.toString(), el, processFunc?.(el));\r\n            let value = processFunc?.(el);\r\n            if(output && value !== undefined) _store(output)?.update?.(value);\r\n            _handlePushState(el, e);\r\n        }\r\n        if(trigger == \"$mount\") ev();\r\n        else el.addEventListener(trigger, ev);\r\n    }\r\n}","import { _ensureTemplate, _iterable, _iterateSiblings, _registerInternalStore } from \"./domutil\";\r\nimport { _register } from \"./registrar\";\r\nimport { _store } from \"./store\";\r\nimport { _applyTransition, _scheduleUpdate } from \"./updates\";\r\nimport { _id, _parseFunction, ATTR_PREFIX } from \"./util\";\r\n\r\n/**\r\n * Handle conditional and loop elements\r\n * @param {HTMLElement} el \r\n * @param {string} mode \r\n * @param {string[]} as \r\n * @param {Function | undefined} func\r\n * @param {string[]} dependencyList\r\n * @param {import(\".\").MfldOps} ops \r\n */\r\nexport let _handleTemplates = (el, mode, as, func, dependencyList, ops)=> {\r\n    let startElement = document.createElement(\"template\"),\r\n        templ = /** @type {HTMLTemplateElement}*/(_ensureTemplate(/** @type {HTMLElement}*/(el.cloneNode(true)))),\r\n        templStore,\r\n        conditional = mode.match(/if|else/), \r\n        conditionalSub = mode.match(/(else|elseif)(\\s|$)/), // Whole word match to allow for exact checks later on (otherwise else is greedy)\r\n        newFunc = undefined,\r\n        prevConditions = [];\r\n\r\n    startElement.classList.add(`${mode}-start`);\r\n    templ.classList.add(`${mode}-end`);\r\n\r\n    el.before(startElement);\r\n    el.after(templ);\r\n    el.remove();\r\n\r\n    // Handle conditional elements\r\n    if(conditional) {\r\n        // Get upstream conditions\r\n        if(conditionalSub) {\r\n            let first = _iterateSiblings(startElement, (sib)=> sib?.classList?.contains(`${ATTR_PREFIX}if-end`), null, true);\r\n            _iterateSiblings(\r\n                first, \r\n                sib=> sib == templ, \r\n                sib=> { if(sib?.dataset?.[`${ATTR_PREFIX}cstore`]) prevConditions.push(sib?.dataset?.[`${ATTR_PREFIX}cstore`]) }\r\n            );\r\n        }\r\n\r\n        // Create function\r\n        newFunc = (...list)=> {\r\n            if(conditionalSub) for(let res of list.slice(-prevConditions.length)) if(res == true) return false;\r\n            return conditionalSub?.[0] == \"else\" ? true : func?.(...list) == true;\r\n        }\r\n    }\r\n\r\n    templStore = _registerInternalStore(dependencyList, { func: conditional ? newFunc : func, observeEl: templ });\r\n    \r\n    if(conditional) templ.dataset[`${ATTR_PREFIX}cstore`] = templStore.name;\r\n\r\n    // Clear old elements\r\n    templStore.sub(val=> {\r\n        if(val === undefined) return;\r\n        _scheduleUpdate(()=> {\r\n            _iterateSiblings(\r\n                startElement?.nextElementSibling, \r\n                (sib)=> sib?.classList?.contains(`${mode}-end`),\r\n                (sib)=> _applyTransition(/** @type {HTMLElement}*/(sib), \"out\", ops, ()=> sib?.remove()), \r\n            );\r\n\r\n            if(conditional && !val) return;\r\n\r\n            _iterable(mode.match(/each/) ? val : [val], (val, key)=> {\r\n                // Get all logical bindings and replace values\r\n                let item = /** @type {HTMLTemplateElement}*/ (templ.cloneNode(true));\r\n                if(!conditional) {\r\n                    let rx = new RegExp(\"\\\\$:{([^}]*)}\", \"g\");\r\n                    let html = templ?.innerHTML?.replace(rx, (_, cap)=> _parseFunction(`(${as.join(\",\")})=> ${cap}`)?.func?.(val, key) || \"\") || \"\";\r\n                    if(item?.innerHTML) item.innerHTML = html;\r\n                }\r\n\r\n                // Replace values\r\n                for(let element of item.content.children) {\r\n                    if(!element?.innerHTML) element.innerHTML = val;\r\n                    templ.before(element);\r\n                    _applyTransition(/** @type {HTMLElement}*/(element), \"in\", ops);\r\n                }\r\n            });\r\n        });\r\n    });\r\n}","import { _store } from \"./store.js\";\r\nimport { _scheduleUpdate } from \"./updates.js\";\r\nimport { _commaSepRx, _getOpOverrides, _glob, _id, _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _handleFetch } from \"./fetch.js\";\r\nimport { _handleBindSync } from \"./bindsync.js\";\r\nimport { _handleTemplates } from \"./templates.js\";\r\n/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\n/** @type {Partial<MfldOps>} */\r\nlet _ops = {};\r\nlet _modes = [\"bind\", \"sync\", \"templ\", \"if\", \"elseif\", \"else\", \"each\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\"].map(m=> `${ATTR_PREFIX}${m}`);\r\n\r\n/**!\r\n * @param {Partial<MfldOps>} newops \r\n * @param {string} [profileName] \r\n */\r\nexport let _setOptions = (newops, profileName)=> {\r\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\r\n    else _ops = { ..._ops, ...newops };\r\n}\r\n\r\n// Handle location state changes\r\n_glob.addEventListener(\"popstate\", ()=> {\r\n    location.reload();\r\n});\r\n\r\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\r\n/**\r\n * @param {HTMLElement | null} [parent] \r\n */\r\nexport let _register = (parent)=> {\r\n    if(parent?.nodeType == Node.TEXT_NODE) return;\r\n\r\n    /** @type {NodeListOf<HTMLElement> | []} */\r\n    let els = (parent || document.body).querySelectorAll(\r\n        `[data-${_modes.join(`],[data-`)}],a,form`\r\n    ) || [];\r\n\r\n    for(let el of els) {\r\n        let _op_overrides = _getOpOverrides(_ops, el);\r\n        if(!el.id) el.id = _id();\r\n\r\n        //Check for <a> and <form> elements\r\n        if(el.dataset?.[`${ATTR_PREFIX}promote`] !== undefined) {\r\n            let [mode, href, input, trigger] = el.tagName == \"A\" ?\r\n                [\"get\", /** @type {HTMLAnchorElement}*/(el).href, [], \"click\"] : \r\n                [/** @type {HTMLFormElement}*/(el).method.toLowerCase(), /** @type {HTMLFormElement}*/(el).action, \"$form\", \"submit\"];\r\n\r\n            if(href) {\r\n                // _handleFetch(el, trigger, _op_overrides, href, mode, /** @type {any[] | \"$form\"}*/(input));\r\n                continue;\r\n            }\r\n        }\r\n\r\n        //Loop over all data attributes (modes)\r\n        for(let mode of _modes) {\r\n            if(el.dataset?.[mode] === undefined) continue;\r\n            let shouldHaveTriggers = !mode.match(/bind|templ|if|else|each/);\r\n\r\n            //Loop over provided settings\r\n            for(let setting of el.dataset?.[mode]?.split(\";;\") || []) {\r\n                //Break out settings\r\n                let parts = setting?.split(/\\s*->\\s*/g),\r\n                    triggers = (shouldHaveTriggers ? parts?.shift()?.match(/[^\\(\\)]{1,}/g)?.pop()?.split(_commaSepRx)?.map(s=> s.trim()) : []) || [],\r\n                    [funcStr, output] = parts,\r\n                    dependencyList = funcStr?.match(/\\$st\\.(\\w{1,})/g) || [];\r\n\r\n                if(!output && mode.match(/get|head|put|post|delete|patch/)) {\r\n                    output = funcStr;\r\n                    funcStr = \"\";\r\n                }\r\n                let {func, as} = _parseFunction(funcStr);\r\n\r\n                console.log(\"MODE\", mode, \"FUNC\", func, \"AS\", as, \"OUTPUT\", output, \"DEPS\", dependencyList)\r\n\r\n                //Handle templs and loops\r\n                if(mode.match(/each|templ|if|else/)) _handleTemplates(el, mode, as || [], func, dependencyList, _op_overrides);\r\n                else {\r\n                    //Loop over triggers\r\n                    if(!triggers?.length) triggers = [\"\"]\r\n                    for(let trigger of triggers) {\r\n                        if(mode.match(/bind|sync/)) _handleBindSync(el, output, trigger, mode, func);\r\n                        else {\r\n                            // _handleFetch(el, trigger, _op_overrides, output, mode.replace(ATTR_PREFIX, \"\"), func);\r\n                        }\r\n                    }\r\n                }\r\n            }; //End loop settings\r\n        }; //End loop dataset\r\n    };  //End loop elements\r\n}","import { _store } from \"./store.js\";\r\nimport { _addToNextTickQueue } from \"./updates.js\";\r\nimport { _register, _setOptions } from \"./registrar.js\";\r\nimport { _glob } from \"./util.js\";\r\n\r\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\r\n\r\n/**!\r\n * @typedef {object} ExternalOptions\r\n * @property {string} domain - The domain name these settings apply to\r\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\r\n * @property {boolean} [styles] - Allow styles from this domain to apply\r\n */\r\n\r\n/**!\r\n * @typedef {object} FetchOptions\r\n * @property {RequestInit} [request] - Fetch request options\r\n * @property {\"json\"|\"text\"} [resType] - Response type (default: \"text\")\r\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\r\n * @property {(code: number, data: void | Response)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\r\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\r\n */\r\n\r\n/**!\r\n * @typedef {object} TransitionOptions\r\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\r\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\r\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\r\n * @property {boolean} [smart] - Enable smart transitions (default: true)\r\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\r\n */\r\n\r\n/**!\r\n * Manifold options for `fetch`, `trans`, and `profiles`.\r\n * @typedef {Object} MfldOps\r\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\r\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\r\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback UpdaterFunction\r\n * @param {Array<any>} upstreamValues\r\n * @param {T} value\r\n * @returns {T | Promise<T>}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback ValueDeterminer\r\n * @param {T} [currentValue]\r\n * @returns {T | Promise<T> | undefined}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback UpdateFunction\r\n * @param {T | ValueDeterminer<T>} value\r\n * @returns {T | Promise<T> | undefined}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback SubDeterminer\r\n * @param {T} value\r\n * @returns {void}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback SubFunction\r\n * @param {SubDeterminer<T>} value The store's current value\r\n * @returns void\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef {Object} StoreOptions\r\n * @property {T} [value]\r\n * @property {Array<string>} [upstream]\r\n * @property {UpdaterFunction<T>} [updater]\r\n * @property {HTMLElement | SVGScriptElement | \"global\"} [scope]\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef Store\r\n * @prop {T} value - The store's current value (read only)\r\n * @prop {UpdateFunction<T>} update - Update the store's current value\r\n * @prop {SubFunction<T>} sub - Add a subscription function to the store\r\n */\r\n\r\n/**!\r\n * @typedef {Function} MfldFunc\r\n * @param {any} val\r\n * @param {HTMLElement} [el]\r\n */\r\n\r\n/**!\r\n * The global Manifold interface.\r\n */\r\nexport let Mfld = {\r\nstore: \r\n/**!\r\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @template T\r\n* @param {string} store_name\r\n* @param {StoreOptions<T> | T} store_ops\r\n* @return {Store<T>}\r\n*/ (store_name, store_ops)=> {\r\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\r\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\r\n    }\r\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\r\n},\r\nustore: \r\n/**!\r\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @param {string} store_name\r\n* @param {StoreOptions<any> | any} store_ops\r\n* @return {Store<any>}\r\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\r\nget:\r\n/**!\r\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\r\n * @param {string} store_name\r\n * @return {Store<any>}\r\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\r\nfunc: \r\n/**!\r\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\r\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\r\n * @param {string} func_name\r\n * @return {MfldFunc}\r\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(\r\n    _glob.MFLD.fn[func_name]),\r\nfuncs: \r\n/**!\r\n * - Add functions to the Manifold function registry in key-value pairs.\r\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \r\n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\r\n * @param {{ [key: string]: MfldFunc }} funcs\r\n */ funcs=> {\r\n    for(let key in funcs) {\r\n    _glob.MFLD.fn[key] = funcs[key];\r\n }},\r\nconfig:\r\n/**!\r\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\r\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\r\n * @param {MfldOps} new_ops\r\n * @param {string} [profile_name]\r\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\r\n onTick:\r\n /**!\r\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\r\n  * @param {()=> void} cb\r\n  */ (cb)=> _addToNextTickQueue(cb),\r\nregister:\r\n/**!\r\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\r\n * @param {HTMLElement | string | null} [parent]\r\n */ (parent)=> {\r\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\r\n        _register(parent)\r\n    },\r\n};"],"names":["ATTR_PREFIX","_commaSepRx","_id","Date","now","Math","floor","random","_glob","_getOpOverrides","ops","el","overrides","profiles","dataset","override","res","set","console","log","key","startsWith","prop","split","val","match","JSON","parse","parseInt","e","error","_parseFunction","condition","fn","asStr","fnText","as","map","s","trim","func","Function","workArray","cancelAnimationFrame","_nextTickQueue","_scheduleUpdate","update","push","requestAnimationFrame","_runUpdates","_addSpacer","inEl","wrapper","wrapperHeight","trans","smart","paddingTop","paddingBottom","Element","getComputedStyle","spacer","document","createElement","style","height","abs","clientHeight","after","_adjustSizing","dur","animate","order","out","_getDimensionsAfterUpdate","relation","in","_applyTransition","prepend","includes","container","cloneNode","border","replaceChildren","undefined","replaceWith","appendChild","done","forEach","dir","refElement","nodeType","Node","TEXT_NODE","textContent","Array","isArray","transClass","class","classList","add","hooks","dimensions","_getDimensions","position","width","w","left","top","margin","transitionDuration","setTimeout","remove","swap","rect","getBoundingClientRect","clientWidth","paddingLeft","paddingRight","scrollX","scrollY","_hashAny","input","Map","Set","from","entries","hash","char","TextEncoder","encode","toString","MFLD","st","mut","Store","_updater","_subscriptions","_storedHash","_upstreamStores","_downstreamStores","_scope","_updateTimeout","constructor","name","this","_modify","scope","currentScript","mutOb","get","toRemove","observer","MutationObserver","muts","type","node","removedNodes","store","_destroy","disconnect","delete","observe","parentElement","childList","upstream","S","_store","value","updater","_auto_update","sub","ref","immediate","Promise","async","resolve","clearTimeout","newValue","newHash","ds","newVal","found_store","_iterateSiblings","sib","breakFn","cb","reverse","_registerInternalStore","storeList","options","observeEl","_handleBindSync","output","trigger","mode","processFunc","dependencyList","replace","attr","setAttribute","dispatchEvent","CustomEvent","ev","href","preventDefault","pushState","history","_handlePushState","addEventListener","_handleTemplates","templStore","newFunc","startElement","templ","nodeName","tagName","newEl","content","conditional","conditionalSub","prevConditions","before","first","contains","list","slice","length","nextElementSibling","obj","arr","_iterable","item","rx","RegExp","html","innerHTML","_","cap","join","element","children","_ops","_modes","m","location","reload","Mfld","store_name","store_ops","hasOwnProperty","ustore","func_name","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register","parent","querySelector","els","body","querySelectorAll","_op_overrides","id","method","toLowerCase","action","shouldHaveTriggers","setting","parts","triggers","shift","pop","funcStr","_register"],"mappings":"AAAO,IAAIA,EAAc,MAEdC,EAAc,UAEdC,EAAM,IACN,GAAGC,KAAKC,SAASC,KAAKC,MAAsB,IAAhBD,KAAKE,YAqBjCC,EAAK,OAQLC,EAAkB,CAACC,EAAKC,KAC/B,IAAIC,EAAYF,EAAIG,WAAWF,EAAGG,SAASC,UAAY,IACnDC,EAAM,IAAKN,KAAQE;AAGvB,IAAI,IAAIK,KAAON,EAAGG,QAAS,CACvBI,QAAQC,IAAI,MAAOF;AACnB,IAAI,IAAIG,IAAO,CAAC,QAAS,SACrB,GAAGH,EAAII,WAAW,GAAGrB,IAAcoB,MAAS,CACxCF,QAAQC,IAAI,QAAS,GAAGnB,IAAcoB;AACtC,IACI,IAAIE,EAAOL,EAAIM,MAAM,KAAK,GAEtBC,EAAMb,EAAGG,QAAQG;AAClBO,GAAKC,MAAM,UAASD,EAAME,KAAKC,MAAMH,IACrCI,SAASJ,KAAMA,EAAMI,SAASJ,IACjCR,EAAII,GAAKE,GAAQE,EACjBN,QAAQC,IAAI,OAAQC,EAAKE,EAAME,EAClC,CACD,MAAMK,GACFX,QAAQY,MAAMD,EACjB,CACJ,CAER,CAGD,OADAX,QAAQC,IAAIH,GACLA,CAAG,EAOHe,EAAkBC,IACzB,IAAKC,EAAIC,GAASF,GAAWT,MAAM,mBAAqB,CAACS,EAAW,SAChEG,EAAS,4IAA4IF,IACrJG,EAAKF,GAAOX,QAAQtB,IAAcoC,OAAMC,GAAIA,EAAEC,UAAW,CAAC,UAAY;AAG1E,MAAO,CAAEC,KAFE,IAAIC,SAAS,MAAON,GAEhBC,KAAI;AC7DoB,IAAIM,EAAY,GACvDC,EAAuB,EAOvBC,EAAiB,GAUVC,EAAmBC,IAC1BJ,EAAUK,KAAKD,GACXH,IACAA,EAAuBK,sBAAsBC,GAChD,EAGDC,EAAa,CAACC,EAAMC,EAASC,EAAe3C,KAC5C,KAAKA,EAAI4C,OAAOC,OAAS,GAAO;AAChC,IAAIC,WAAEA,EAAUC,cAAEA,GAAkBL,aAAmBM,QAAUC,iBAAiBP,GAAW,CAAEI,WAAY,EAAGC,cAAe,GACzHG,EAASC,SAASC,cAAc;AACpCF,EAAOG,MAAMC,OAAS,QAAQ3D,KAAK4D,IAAIZ,GAAiBF,GAAMe,cAAgB,WAAWV,OAAgBC,KACzGL,GAASe,MAAMP,EAAO,EAGtBQ,EAAgB,CAACjB,EAAMzC,KACvB,IAAIA,EAAI4C,OAAOC,OAAS,EAAM;AAC9B,IAAIc,GAAO3D,GAAK4C,OAAOe,MAAM,IAAM3D,GAAK4C,OAAOe,KAAO,KAAK;AAC3DxB,GAAgB,KAEZM,GAAMmB,UAAU,CACZ,CAAEN,OA3BK,IA4BP,CAAEA,OAAQ,GAAGb,EAAKe,cAAgB,QACnCG,EAAI,GACT,EAGFpB,EAAc,KACdN,EAAuB;AAEvB,IAAI,IAAI4B,KAAS7B,EAAW,CACxB,GAAmB,mBAAT6B,EAAqB,CAC3BA;AACA,QACH,CAED,IAAIlB,EAAgBkB,EAAMC,IAAMD,EAAMC,IAAIN,aAAe,EACrDO,EAA8C,SAAlBF,EAAMG;AAEtC,GAAqB,WAAlBH,EAAMG,SACLxB,IAAaqB,EAAMI,GAAIJ,EAAMC,IAAKnB,EAAekB,EAAM7D,KACvDkE,EAAiBL,EAAMI,GAAI,KAAMJ,EAAM7D,KAAK,KACxC6D,EAAMC,KAAKK,QAAQN,EAAMI,IACzBP,IAAgBG,EAAMI,GAAIJ,EAAM7D,IAAI;IAGvC,CACD,GAAG,CAAC,QAAS,SAASoE,SAASP,EAAMG,UAAW,CAC5C,IAAIK,EAAsCR,EAAMC,KAAKQ,WAAU;AAC5DD,IACCR,EAAMC,KAAKL,MAAMY,GACdN,IACCM,EAAUhB,MAAMkB,OAAS,OACzBV,EAAMC,IAAIU,mBAEdN,EAAiBG,EAAW,MAAOR,EAAM7D,SAAKyE,EAAWZ,EAAMC,IAAKC,GAE3E,CAEDvB,IAAaqB,EAAMI,GAAIJ,EAAMC,IAAKnB,EAAekB,EAAM7D,KACvDkE,EAAiBL,EAAMI,GAAI,KAAMJ,EAAM7D,KAAK,KACnB,SAAlB6D,EAAMG,SAAqBH,EAAMC,KAAKY,YAAYb,EAAMI,IACtDJ,EAAMC,KAAKa,YAAYd,EAAMI,IAClCP,IAAgBG,EAAMI,GAAIJ,EAAM7D,IAAI,GAE3C,CAED6D,EAAMe,OAAOf,EAAMI,GACtB,CAED/B,EAAe2C,SAAQtD,GAAMA,MAC7BW,EAAiB,GACjBF,EAAY,EAAE,EAaPkC,EAAmB,CAACjE,EAAI6E,EAAK9E,EAAKuB,EAAIwD,EAAYhB,GAA4B,EAAON,KAM5F,GALGxD,GAAI+E,UAAYC,KAAKC,YACpBjF,EAAGyE,YAAYvB,UAAUC,cAAc,QACvCnD,EAAGkF,YAAclF,EAAGkF,aAGrBlF,EAAI,CACH,MAAM0D,EAAMyB,MAAMC,QAAQrF,EAAI4C,OAAOe,KAAO3D,EAAI4C,OAAOe,IAAW,MAAPmB,EAAc,EAAI,IAAM9E,EAAI4C,OAAOe,IAAI,GAAK3D,EAAI4C,OAAOe,KAAO,EACnH2B,EAAatF,GAAK4C,OAAO2C,OAAS,GAAGjG;AAI3C,GAHAW,GAAIuF,WAAWC,IAAIH,GACnBtF,EAAI4C,OAAO8C,QAAQ,GAAGZ,aAAe7E,GAE3B,OAAP6E,EAAc,CAEb,KADAC,EAAaA,GAAc9E,GACX;AAChB,IAAI0F,EAAa,CAAA,GACb3F,EAAI4C,OAAOC,OAAS,KAAUkB,IAC9B4B,EAAaC,EAAeb,IAGhC5C,GAAgB,MACRnC,EAAI4C,OAAOC,OAAS,IAASkB,GAA6BgB,IAC1DY,EAAaC,EAAeb,KAG7B/E,EAAI4C,OAAOC,OAAS,KACnB5C,EAAGoD,MAAMwC,SAAW,QACpB5F,EAAGoD,MAAMyC,MAAQH,EAAWI,EAC5B9F,EAAGoD,MAAM2C,KAAOL,EAAWK,KAC3B/F,EAAGoD,MAAM4C,IAAMN,EAAWM,IAC1BhG,EAAGoD,MAAM6C,OAAS,KAEnBvC,IAAK1D,EAAGoD,MAAM8C,mBAAqB,GAAGxC,OAEzC1D,EAAGuF,WAAWC,IAAI,MAAM,GAE/B,MAEGxF,GAAIuF,WAAWC,IAAI,MAChB9B,IAAK1D,EAAGoD,MAAM8C,mBAAqB,GAAGxC,OACzCpC,MACA6E,YAAW,KACPjE,GAAgB,KACZiE,YAAW,IAAKjE,GAAgB,IAAKlC,GAAIuF,WAAWa,OAAOvB,MAAO,EAAE,GACtE,GACH9E,EAAI4C,OAAO0D,MAAQ;AAG1BF,YAAW,KACPjE,GAAgB,KACF,OAAP2C,GAAc7E,GAAIoG,SACrBpG,GAAIuF,WAAWa,OAAOf,GACtBtF,EAAI4C,OAAO8C,QAAQ,GAAGZ,WAAa7E,GACnCA,EAAGoD,MAAM8C,mBAAqB,GAC9B3F,QAAQC,IAAI,iBACF,MAAPqE,GAAarB,IAAQxD,EAAG,GAC7B,GAEN0D,GAAc,MAAPmB,GAAc9E,EAAI4C,OAAO0D,MAAY,GAC/C,GAGDV,EAAkBb,IAClB,IAAI1B,EAAQJ,iBAAiB8B,GACzBwB,EAAOxB,EAAWyB;AACtB,MAAO,CACHT,EAAG,QAAQ,EAAaU,mBAAmBpD,EAAMqD,iBAAiBrD,EAAMsD,gBACxEX,KAAM,QAAQO,EAAKP,YAAYlG,EAAM8G,aACrCX,IAAK,QAAQM,EAAKN,WAAWnG,EAAM+G,aACtC,EClKDC,EAAYC,IACZ,IAAIA,EAAO,OAAO;AAClB,GAAmB,iBAATA,IAA+B,IAAVA,EAAgB,OAAOA;AACtD,GAAGA,aAAiBC,KAAOD,aAAiBE,IAAK,OAAOH,EAAS1B,MAAM8B,KAAKH,EAAMI,WAAaJ;AAE/F,IAAIK,EAAO;AACX,IAAI,IAAIC,KAAQ,IAAIC,aAAcC,OAAOR,GAAOS,YAAc,IAC1DJ,GAASA,GAAQ,GAAKA,EAAQC;AAClC,OAAOD,CAAI;AAIXtH,EAAM2H,OAAM3H,EAAM2H,KAAO,CACzBC,GAAI,CAAE,EACNnG,GAAI,CAAE,EACNoG,IAAK,IAAIX;AAMN,MAAMY,EACqCC,OAAWpD;AACjBqD,EAAiB,IAAId;AAC3Be,OAActD;AACjBuD,EAAkB,IAAIf;AACtBgB,EAAoB,IAAIhB;AACWiB;AACnCC;AAM/B,WAAAC,CAAYC,EAAMrI,GACd,OAAOsI,KAAKC,EAAQF,EAAMrI,EAC7B,CAMD,CAAAuI,CAAQF,EAAMrI,GAMV,GALAsI,KAAKD,KAAOA,EACZC,KAAKJ,EAASlI,GAAKwI,OAASrF,SAASsF,eAAiB,SACtD3I,EAAM2H,KAAKC,GAAGW,GAAQC,KAGnBA,KAAKJ,aAAkBlF,QAAS,CAC/B,IAAI0F,EAAQ5I,EAAM2H,KAAKE,IAAIgB,IAA8BL,KAAW,IAAM,CAAEM,SAAU,IAAI3B,IAAO4B,SAAgD;AAC7IH,EAAMG,WACNH,EAAMG,SAAW,IAAIC,kBAAkBC,IACnC,IAAI,IAAIpB,KAAOoB,EACX,GAAe,aAAZpB,EAAIqB,KACH,IAAI,IAAIC,KAAQtB,EAAIuB,aAChB,GAAGD,aAAgBjG,QACf,IAAI,IAAImG,KAAST,EAAME,SACnB,GAAGO,EAAMjB,GAAoC,EAAO,CAChD,IAAIM,EAAQF,KAAKJ;AACjBkB,EAASD,GACTT,EAAMG,UAAUQ,aAChBX,EAAME,SAASU,OAAOH,GAEtB1B,KAAKE,IAAI2B,OAAOd,EACnB,CAKpB,IAE0BE,EAAc,SAAEa,QAAkCjB,KAAKJ,GAAQsB,cAAgB,CAAEC,WAAW,KAE/Hf,EAAME,SAASnD,IAAI6C,MAEnBb,KAAKE,IAAIpH,IAAI+H,KAAKJ,EAAQQ,EAC7B,CAYD,OAVC1I,GAAK0J,UAAU/H,KAAIC,IAChB,IAAI+H,EAAIC,EAAOhI;AAGf,OAFA0G,KAAKN,EAAgBvC,IAAIkE,GACzBA,EAAE1B,EAAkBxC,IAAI6C,MACjBqB,CAAC,IAGZrB,KAAKuB,MAAQ7J,GAAK6J,MAClBvB,KAAKT,EAAW7H,GAAK8J,QACrBxB,KAAKyB,IACEzB,IACV,CAOD,GAAA0B,CAAIA,EAAKC,EAAKC,GAAY,GACtB5B,KAAKR,EAAevH,IAAI0J,GAAOzK,IAAOwK,GACnCE,GAAWF,IAAM1B,KAAKuB,MAC5B,CAOD,YAAMzH,CAAOyH,GACT,OAAO,IAAIM,SAAQC,MAAOC,IAEnB/B,KAAKH,GAAgBmC,aAAahC,KAAKH,GAC1CG,KAAKH,EAAiB/B,YAAW,KAC7BjE,GAAgBiI,UAEZ,IAAIG,EAA4B,mBAATV,SAAoDA,KAASvB,KAAKuB,OAASA,EAC9FW,EAAU1D,EAASyD;AAEvB,GAAGC,IAAYlC,KAAKP,EAAa,CAC7BO,KAAKuB,MAAQU,EACbjC,KAAKP,EAAcyC;AAGnB,IAAI,IAAIC,KAAMnC,KAAKL,QAAyBwC,EAAGV;AAG/C,IAAI,IAAKE,EAAKD,KAAQ1B,MAAMR,GAAkB,GAAIkC,IAAM1B,KAAKuB,MAAOI;AACpEI,EAAQ/B,KAAKuB,MAChB,MAEGQ,EAAQ/B,KAAKuB,MAChB,GACH,GACH,EAAE,GAEZ,CAED,OAAME,GACF,IAAIW,QAAepC,KAAKT,IACpBzC,MAAM8B,KAAKoB,KAAKN,IAAkBrG,KAAIgI,GAAKA,GAAGE,SAAU,GACvCvB,MAAMuB;MAGrBvB,KAAKlG,YAAkBqC,IAAXiG,EAAuBpC,KAAKuB,MAAQa,EACzD,EAYE,IAAId,EAAS,CAACvB,EAAMrI,KACvB,IAAI2K,EAAuC7K,EAAM2H,KAAKC,GAAGW;AACzD,OAAOrI,EAAO2K,EAAcA,EAAYpC,EAAQF,EAAMrI,GAAO,IAAI4H,EAAMS,EAAMrI,GAAS2K,GAAe,IAAI/C,EAAMS,EAAMrI,EAAK,EAcnHoJ,EAAYD,IAEnBrJ,EAAM2H,KAAKC,GAAGyB,GAAOd,MAAQ,SAAM5D,CAAS;AC1JzC,SAASmG,EAAiBC,EAAKC,EAASC,EAAIC,GAAU,GACzD,IAAIlG,EAAMkG,EAAU,yBAA2B;AAC/C,OAAOF,IAAUD,GAAOA,EAAMD,GAAkBG,IAAKF,IAAQA,KAAO/F,GAAMgG,EAASC,EAAIC,EAC3F,CAaO,IAAIC,EAAyB,CAACC,EAAWC,IAErCvB,EAAOpK,IAAO,CACjBkK,SAAU,IAAKwB,GAAa,IAC5BpB,QAAS,IAAKqB,GAASrJ,OAAOqJ,EAAQC,WACtC5C,MAAO2C,GAASC,YCzDbC,EAAkB,CAACpL,EAAIqL,EAAQC,EAASC,EAAMC,EAAaC,KAClE,GAAGF,EAAKzK,MAAM,QACVuK,EAASA,GAAQK,QAAQ,SAAU,KAAO,GAC1CV,EAAuBS,EAAgB,CACnCN,UAAWnL,EACX6B,KAAM,KACF,IAAIhB,EAAM2K,IAAcxL;AACxB,GAAGqL,GAAiB7G,MAAP3D,EAAkB,CAC3B,IAAKkI,EAAM4C,GAAQN,EAAOzK,MAAM;AACrB,SAARmI,EAAiB/I,EAAGoD,MAAMuI,GAAQ9K,EACrB,QAARkI,EAAgB/I,EAAG4L,aAAaD,EAAM9K,GACzCb,EAAGqL,GAAUxK,CACrB,CAED,OADAb,EAAG6L,cAAc,IAAIC,YAAYR,IAC1BzK,CAAG;IAGf,CACH,IAAIkL,EAAM7K,IACNX,QAAQC,IAAI,KAAMgL,EAAYjE,WAAYvH,EAAIwL,IAAcxL;AAC5D,IAAI4J,EAAQ4B,IAAcxL;AACvBqL,QAAoB7G,IAAVoF,GAAqBD,EAAO0B,IAASlJ,SAASyH,GJwDhE,SAA0B5J,EAAI+L,EAAIC,GACrCD,GAAIE;AAEJ,IAAIC,EAAYlM,EAAGG,UAAU,GAAGd,cAE5B+C,EAAO4J;AACX,OAAOE,GACH,IAAK,GAAI;AACT,UAAK1H,EAAW;AAChB,QAASpC,EAAO,IAAI8J,IAGxBC,QAAQD,UAAU,KAAM,GAAI9J,EAChC,CIpEYgK,CAAiBpM,EAAIkB,EAAE;AAEb,UAAXoK,EAAqBS,IACnB/L,EAAGqM,iBAAiBf,EAASS,EACrC,GChBMO,EAAmB,CAACtM,EAAIuL,EAAM9J,EAAII,EAAM4J,EAAgB1L,KAC/D,IAEIwM,EAGAC,EALAC,EAAevJ,SAASC,cAAc,YACtCuJ,EFVqB,CAAC1M,IAC1B,IAAI2M,EAAW;AACf,GAAG3M,EAAG4M,SAAWD,EAAU,OAAyC;AAEpE,IAAIE,EAA0C3J,SAASC,cAAcwJ;AAIrE,OAHAE,EAAMC,QAAQpI,YAAY1E,EAAGqE,WAAU,IACvCrE,EAAGyE,YAAYoI,GAERA,CAAK,EEEkC,CAA0C7M,EAAGqE,WAAU,IAEjG0I,EAAcxB,EAAKzK,MAAM,WACzBkM,EAAiBzB,EAAKzK,MAAM,uBAE5BmM,EAAiB;AAUrB,GARAR,EAAalH,UAAUC,IAAI,GAAG+F,WAC9BmB,EAAMnH,UAAUC,IAAI,GAAG+F,SAEvBvL,EAAGkN,OAAOT,GACVzM,EAAGwD,MAAMkJ,GACT1M,EAAGoG,SAGA2G,EAAa,CAEZ,GAAGC,EAAgB,CACf,IAAIG,EAAQxC,EAAiB8B,GAAe7B,GAAOA,GAAKrF,WAAW6H,SAAS,GAAG/N,YAAsB,MAAM;AAC3GsL,EACIwC,GACAvC,GAAMA,GAAO8B,IACb9B,IAAWA,GAAKzK,UAAU,GAAGd,YAAsB4N,EAAe7K,KAAKwI,GAAKzK,UAAU,GAAGd,cAEhG,CAGDmN,EAAU,IAAIa,KACV,GAAGL,EAAgB,IAAI,IAAI3M,KAAOgN,EAAKC,OAAOL,EAAeM,QAAS,GAAU,GAAPlN,EAAa,OAAO;AAC7F,MAA8B,QAAvB2M,IAAiB,IAAyC,GAAnBnL,OAAUwL,EAAa,CAE5E,CAEDd,EAAavB,EAAuBS,EAAgB,CAAE5J,KAAMkL,EAAcP,EAAU3K,EAAMsJ,UAAWuB,IAElGK,IAAaL,EAAMvM,QAAQ,GAAGd,WAAuBkN,EAAWnE,MAGnEmE,EAAWxC,KAAIlJ,SACA2D,IAAR3D,GACHqB,GAAgB,KACZyI,EACI8B,GAAce,oBACb5C,GAAOA,GAAKrF,WAAW6H,SAAS,GAAG7B,WACnCX,GAAO3G,EAAgB,EAAiC,MAAOlE,GAAK,IAAK6K,GAAKxE,aAGhF2G,IAAgBlM,GF1CR,EAAC4M,EAAK3C,KACzB,GAAG2C,aAAe1G,IAAK,IAAI,MAAOtG,EAAKmJ,KAAU6D,EAAIvG,UAAW4D,EAAGrK,EAAKmJ;KAEpE,IACI,IAAI8D,EAAMvI,MAAM8B,KAAKwG,GAAO;AAC5B,GAAGC,GAAKH,OAAQG,EAAI9I,QAAQkG;KACvB,IAAI,IAAIrK,KAAOgN,EAAK3C,EAAGrK,EAAKgN,EAAIhN,GACxC,CACD,MAAMS,GAAKX,QAAQY,MAAM,GAAGsM,oBAAyB,CACxD,EEmCOE,CAAUpC,EAAKzK,MAAM,QAAUD,EAAM,CAACA,IAAM,CAACA,EAAKJ,KAE9C,IAAImN,EAA0ClB,EAAMrI,WAAU;AAC9D,IAAI0I,EAAa,CACb,IAAIc,EAAK,IAAIC,OAAO,gBAAiB,KACjCC,EAAOrB,GAAOsB,WAAWtC,QAAQmC,GAAI,CAACI,EAAGC,IAAO9M,EAAe,IAAIK,EAAG0M,KAAK,WAAWD,MAAQrM,OAAOhB,EAAKJ,IAAQ,MAAO;AAC1HmN,GAAMI,YAAWJ,EAAKI,UAAYD,EACxC,CAGD,IAAI,IAAIK,KAAWR,EAAKd,QAAQuB,SACxBD,GAASJ,YAAWI,EAAQJ,UAAYnN,GAC5C6L,EAAMQ,OAAOkB,GACbnK,IAAqD,KAAMlE,EAC9D,GACH,GACJ,GACJ,EC1EFuO,EAAO,CAAA,EACPC,EAAS,CAAC,OAAQ,OAAQ,QAAS,KAAM,SAAU,OAAQ,OAAQ,MAAO,OAAQ,OAAQ,MAAO,SAAU,SAAS7M,KAAI8M,GAAI,GAAGnP,IAAcmP;AAYjJ3O,EAAMwM,iBAAiB,YAAY,KAC/BoC,SAASC,QAAQ;AAOd,ICwEIC,EAAO,CAClBzF;;;;;;;;;AAQG,CAAC0F,WAAYC,aACRA,WAAWC,eAAe,UAAaD,WAAWC,eAAe,aACjED,WAA4CjF,MAAsBiF,YAEzClF,EAAOiF,WAAwCC,YAEhFE;;;;;;;;AAOG,CAACH,WAAYC,YAAqClF,EAAOiF,WAAYC,WACxEnG;;;;;;AAKKkG,YAAsCjF,EAAOiF,YAClD/M;;;;;;;AAMKmN,WACDnP,EAAM2H,KAAKlG,GAAG0N,WAClBC;;;;;;;AAMIA,QACA,IAAI,IAAIxO,KAAOwO,MACfpP,EAAM2H,KAAKlG,GAAGb,GAAOwO,MAAMxO,EAC/B,EACAyO;;;;;;;AAMI,CAACC,QAASC,gBAAgBC,OD3IJC,EC2IgBH,cD3IRI,EC2IiBH,cD1I/Bd,EAAKpO,SAAW,IAAKoO,EAAKpO,SAAUqP,CAACA,GAAcD,GAC9DhB,EAAO,IAAKA,KAASgB;AAFL,IAACA,EAAQC,CC2I8B,EAC/DC;;;;;AAIK1E,INrI2B,IAACxJ,KMqIFwJ,INpItB7I,EAAeG,KAAKd,EMoIK,EACnCmO;;;;;AAIKC,IACmB,iBAAVA,IAAoBA,EAA0CxM,SAASyM,cAAcD,IDxI5E,CAACA,IACpB,GAAGA,GAAQ3K,UAAYC,KAAKC,UAAW;AAGvC,IAAI2K,GAAOF,GAAUxM,SAAS2M,MAAMC,iBAChC,SAASvB,EAAOJ,KAAK,wBACpB;AAEL,IAAI,IAAInO,KAAM4P,EAAK,CACf,IAAIG,EAAgBjQ,EAAgBwO,EAAMtO;AAI1C,GAHIA,EAAGgQ,KAAIhQ,EAAGgQ,GAAKzQ,UAG0BiF,IAA1CxE,EAAGG,UAAU,GAAGd,YAAqC,CACpD,IAAKkM,EAAMS,EAAMlF,EAAOwE,GAAyB,KAAdtL,EAAG4M,QAClC,CAAC,MAAsC,EAAKZ,KAAM,GAAI,SACtD,CAA8B,EAAKiE,OAAOC,cAA4C,EAAKC,OAAQ,QAAS;AAEhH,GAAGnE,EAEC,QAEP,CAGD,IAAI,IAAIT,KAAQgD,EAAQ,CACpB,QAA0B/J,IAAvBxE,EAAGG,UAAUoL,GAAqB;AACrC,IAAI6E,GAAsB7E,EAAKzK,MAAM;AAGrC,IAAI,IAAIuP,KAAWrQ,EAAGG,UAAUoL,IAAO3K,MAAM,OAAS,GAAI,CAEtD,IAAI0P,EAAQD,GAASzP,MAAM,aACvB2P,GAAYH,EAAqBE,GAAOE,SAAS1P,MAAM,iBAAiB2P,OAAO7P,MAAMtB,IAAcoC,KAAIC,GAAIA,EAAEC,SAAU,KAAO,IAC7H8O,EAASrF,GAAUiF,EACpB7E,EAAiBiF,GAAS5P,MAAM,oBAAsB;CAEtDuK,GAAUE,EAAKzK,MAAM,oCACrBuK,EAASqF,EACTA,EAAU;AAEd,IAAI7O,KAACA,EAAIJ,GAAEA,GAAML,EAAesP;AAKhC,GAHAnQ,QAAQC,IAAI,OAAQ+K,EAAM,OAAQ1J,EAAM,KAAMJ,EAAI,SAAU4J,EAAQ,OAAQI,GAGzEF,EAAKzK,MAAM,sBAAuBwL,EAAiBtM,EAAIuL,EAAM9J,GAAM,GAAII,EAAM4J,EAAgBsE;IAC3F,CAEGQ,GAAUhD,SAAQgD,EAAW,CAAC;AAClC,IAAI,IAAIjF,KAAWiF,EACZhF,EAAKzK,MAAM,cAAcsK,EAAgBpL,EAAIqL,EAAQC,EAASC,EAAM1J,EAK9E,CACjB,EAGA,GC6EQ8O,CAAUjB,EAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}