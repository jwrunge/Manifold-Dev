{"version":3,"file":"dev.mfld.js","sources":["../src/util.js","../src/updates.js","../src/store.js","../src/fetch.js","../src/domutil.js","../src/bindsync.js","../src/templates.js","../src/registrar.js","../src/index.js"],"sourcesContent":["export let ATTR_PREFIX = \"mf_\";\r\nexport let _inputNestSplitRx = /[\\.\\[\\]\\?]{1,}/g;\r\nexport let _commaSepRx = /, {0,}/g;\r\n\r\nexport let _id = ()=> {\r\n    return `${Date.now()}.${Math.floor(Math.random() * 100_000)}`;\r\n}\r\n\r\n/**\r\n * Get or set nested store values\r\n * @param {import(\".\").MfldOps} ops\r\n * @param {HTMLElement} el\r\n * @returns {import(\".\").MfldOps}\r\n */\r\nexport let _getOpOverrides = (ops, el)=> {\r\n    let override = el.dataset?.override || \"\";\r\n    let overrides = ops.profiles?.[override] || {}// || JSON.parse(override || {});\r\n    \r\n    let res = { ...ops, ...overrides };\r\n    // Get per-value overrides\r\n\r\n    return res;\r\n}\r\n\r\n/**\r\n * @param {{el: HTMLElement, datakey: string} | string} condition \r\n * @returns {{ valueList?: string[], func?: Function, as?: string[] }}\r\n */\r\nexport let _parseFunction = (condition)=> {\r\n    if(typeof condition != \"string\") {\r\n        condition = condition?.el?.dataset?.[condition?.datakey] || \"\";\r\n        if(!condition && /** @type {any}*/(condition)?.el?.dataset?.[`${ATTR_PREFIX}else`] != undefined) condition = \"return true\";\r\n    }\r\n\r\n    let [fstr, values] = condition?.split(\"=>\")?.map(s=> s.trim())?.reverse() || [\"\", \"\"];\r\n    let [fn, asStr] = fstr?.split(/\\s{1,}as\\s{1,}/) || [fstr, \"value\"];\r\n    let as = asStr?.split?.(_commaSepRx)?.map?.(s=> s.trim()) || [\"value\"];\r\n\r\n    // Set up function to evaluate store values\r\n    let valueList = values?.split(\",\")?.map(s=> s.replace(/[()]/g, \"\").trim()) || [];\r\n    // @ts-ignore\r\n    let func = window[fn] || MFLD.fn[fn];\r\n    if(!func) {\r\n        // If function is not found, try to create it; account for implicit returns\r\n        if(!valueList?.length && !fn.includes(\"=>\")) {\r\n            if(!fn.match(/\\(|\\)/)) {\r\n                valueList = [fn];\r\n                fn = `return ${fn}`;\r\n            }\r\n            else {\r\n                valueList = fn.match(/\\([^\\)]{1,}\\)/)?.[0]?.replace(/[\\(\\) ]/g, \"\").split(\",\").filter(s=> !s.match(/[\\\"\\'\\`]/)) || [];\r\n            }\r\n        }\r\n\r\n        valueList = (typeof valueList == \"string\" ? valueList.split(/\\s*,\\s*/) : valueList).map(v => v.split(_inputNestSplitRx)[0]);\r\n        if(!fn.match(/^\\s{0,}\\{/) && !fn.includes(\"return\")) fn = fn.replace(/^\\s{0,}/, \"return \");\r\n        try {\r\n            func = new Function(...valueList, fn);\r\n        }\r\n        catch(e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n\r\n    return { valueList, func, as };\r\n}","/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\nimport { ATTR_PREFIX } from \"./util.js\";\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"append\" | \"prepend\" | \"inner\" | \"outer\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = false;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n/** @type {HTMLElement | null} */\r\nlet spacer;\r\nlet spacerHeight = \"\";\r\n\r\nexport let _addToNextTickQueue = (fn)=> {\r\n    fn && _nextTickQueue.push(fn);\r\n}\r\n\r\nexport let _scheduleUpdate = (update)=> {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = requestAnimationFrame(_runUpdates);\r\n    }\r\n}\r\n\r\nlet _addSpacer = (inEl, wrapper, wrapperHeight, ops)=> {\r\n    if(!(ops.trans?.smart ?? true)) return;\r\n    let { paddingTop, paddingBottom } = wrapper instanceof Element ? getComputedStyle(wrapper) : { paddingTop: 0, paddingBottom: 0 };\r\n    let spacer = document.createElement(\"div\");\r\n    spacer.style.height = `calc(${Math.abs(wrapperHeight - (inEl?.clientHeight || 0))}px - ${paddingTop} - ${paddingBottom})`;\r\n    wrapper?.after(spacer);\r\n}\r\n\r\nlet _adjustSizing = (inEl, ops)=> {\r\n    if(!ops.trans?.smart ?? true) return;\r\n    let dur = (ops?.trans?.dur?.[0] || ops?.trans?.dur || 600)/2\r\n    _scheduleUpdate(()=> {\r\n        spacer?.remove();\r\n        inEl?.animate?.([\r\n            { height: spacerHeight },\r\n            { height: `${inEl.clientHeight || 0}px` }\r\n        ], dur);\r\n    });\r\n}\r\n\r\nlet _runUpdates = ()=> {\r\n    cancelAnimationFrame = false;\r\n    \r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") {\r\n            order();\r\n            continue;\r\n        }\r\n\r\n        let wrapperHeight = order.out ? order.out.clientHeight : 0;\r\n        let _getDimensionsAfterUpdate = order.relation == \"inner\";\r\n\r\n        if(order.relation == \"prepend\") {\r\n            _addSpacer?.(order.in, order.out, wrapperHeight, order.ops);\r\n            _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                order.out?.prepend(order.in);\r\n                _adjustSizing?.(order.in, order.ops);\r\n            });\r\n        }\r\n        else {\r\n            if([\"inner\", \"outer\"].includes(order.relation)) {\r\n                let container = order.out?.cloneNode(true);\r\n                if(container) {\r\n                    order.out?.after(container);\r\n                    if(_getDimensionsAfterUpdate) {\r\n                        container.style.border = \"none\";\r\n                        order.out.replaceChildren();\r\n                    }\r\n                    _applyTransition(container, \"out\", order.ops, undefined, order.out, _getDimensionsAfterUpdate);\r\n                }\r\n            }\r\n\r\n            _addSpacer?.(order.in, order.out, wrapperHeight, order.ops);\r\n            _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                if(order.relation == \"outer\") order.out?.replaceWith(order.in)\r\n                else order.out?.appendChild(order.in);\r\n                _adjustSizing?.(order.in, order.ops);\r\n            });\r\n        }\r\n\r\n        order.done?.(order.in);\r\n    }\r\n\r\n    _nextTickQueue.forEach(fn => fn());\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @param {HTMLElement} [refElement]\r\n * @param {boolean} [_getDimensionsAfterUpdate]\r\n * @returns \r\n */\r\nexport let _applyTransition = (el, dir, ops, fn, refElement, _getDimensionsAfterUpdate = false)=> {\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        el = el.replaceWith(document?.createElement(\"div\")).textContent = el.textContent;\r\n    }\r\n\r\n    if(el) {\r\n        const dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n        const transClass = ops?.trans?.class || `${ATTR_PREFIX}trans`;\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        if(dir == \"out\") {\r\n            refElement = refElement || el;\r\n            if(!refElement) return;\r\n            let dimensions = {};\r\n            if((ops.trans?.smart ?? true) && !_getDimensionsAfterUpdate) {\r\n                dimensions = _getDimensions(refElement);\r\n            }\r\n\r\n            _scheduleUpdate(()=> {\r\n                if((ops.trans?.smart ?? true) && _getDimensionsAfterUpdate && refElement) {\r\n                    dimensions = _getDimensions(refElement);\r\n                }\r\n\r\n                if(ops.trans?.smart ?? true) {\r\n                    el.style.position = \"fixed\";\r\n                    el.style.width = dimensions.w;\r\n                    el.style.left = dimensions.left;\r\n                    el.style.top = dimensions.top;\r\n                    el.style.margin = \"0\";\r\n                }\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n\r\n                el.classList?.add(\"out\");\r\n            })\r\n        }\r\n        else {\r\n            el?.classList?.add(\"in\");\r\n            if(dur) el.style.transitionDuration = `${dur}ms`;\r\n            fn?.();\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    setTimeout(()=> _scheduleUpdate(()=> el?.classList?.remove(dir)), 0);\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}\r\n\r\nlet _getDimensions = (refElement)=> {\r\n    let style = getComputedStyle(refElement);\r\n    let rect = refElement.getBoundingClientRect();\r\n    return {\r\n        w: `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`,\r\n        left: `calc(${rect.left}px + ${window.scrollX}px)`,\r\n        top: `calc(${rect.top}px + ${window.scrollY}px)`\r\n    };\r\n}","/** \r\n * @template T\r\n * @typedef {import(\"./index.js\").UpdaterFunction<T>} UpdaterFunction \r\n */\r\n/** \r\n * @template T\r\n * @typedef {import(\"./index.js\").StoreOptions<T>} StoreOptions \r\n */\r\n\r\nimport { _scheduleUpdate } from \"./updates.js\";\r\nimport { _id } from \"./util.js\";\r\n\r\n/**\r\n * @callback SubFunction\r\n * @param {any} value\r\n * @param {string} [ref]\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * @param {any} input \r\n * @returns {any}\r\n */\r\nlet _hashAny = (input)=> {\r\n    if(!input) return 0;\r\n    if(typeof input == 'number' || input === true) return input;\r\n    if(input instanceof Map || input instanceof Set) return _hashAny(Array.from(input.entries() || input));\r\n\r\n    let hash = 0;\r\n    for(let char of new TextEncoder().encode(input?.toString() || \"\")) \r\n        hash = ((hash << 5) - hash) + char;\r\n    return hash;\r\n}\r\n\r\n//Static\r\nif(!window.MFLD) window.MFLD = {\r\n    st: new Map(),\r\n    fn: {},\r\n    mut: new Map(),\r\n}\r\n\r\n/**\r\n * @template T\r\n */\r\nexport class Store {\r\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\r\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\r\n    /** @type {string | undefined} */ _storedHash = undefined;\r\n    /** @type {Set<Store<any>>} */ _upstreamStores = new Set();\r\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\r\n    /** @type {HTMLElement | SVGScriptElement | string | \"global\"} */ _scope;\r\n    /** @type {any | undefined} */ _updateTimeout;\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    constructor(name, ops) {\r\n        return this._modify(name, ops);        \r\n    }\r\n\r\n    /**\r\n     * @param {string} name\r\n     * @param {StoreOptions<T>} [ops]\r\n     */\r\n    _modify(name, ops) {\r\n        this.name = name;\r\n        this._scope = ops?.scope || document.currentScript || \"global\";\r\n        // @ts-ignore\r\n        MFLD.st.set(name, this);\r\n\r\n        //Watch for scope destroy\r\n        // Watch for scope destroy\r\n        if(this._scope instanceof Element) {\r\n            // @ts-ignore\r\n            let mutOb = MFLD.mut.get(this._scope) || { toRemove: new Set() };\r\n            if(!mutOb.observer) {\r\n                mutOb.observer = new MutationObserver((muts)=> {\r\n                    for(let mut of muts) {\r\n                        if(mut.type == \"childList\") {\r\n                            for(let node of mut.removedNodes) {\r\n                                if(node instanceof Element) {\r\n                                    for(let store of mutOb.toRemove) {\r\n                                        if(store._scope == node) {\r\n                                            let scope = this._scope;\r\n                                            _destroy(store);\r\n                                            mutOb.observer.disconnect();\r\n                                            mutOb.toRemove.delete(store);\r\n                                            // @ts-ignore\r\n                                            MFLD.mut.delete(scope)\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                /** @type {MutationObserver}*/(mutOb.observer).observe(/** @type {HTMLElement}*/(this._scope?.parentElement), { childList: true });\r\n            }\r\n            mutOb.toRemove.add(this);\r\n            // @ts-ignore\r\n            MFLD.mut.set(this._scope, mutOb);\r\n        }\r\n        \r\n        (ops?.upstream?.map(s=> {\r\n            let S = _store(s);\r\n            this._upstreamStores.add(S);\r\n            S._downstreamStores.add(this);\r\n            return S;\r\n        }) || []);\r\n\r\n        this.value = ops?.value;\r\n        this._updater = ops?.updater;\r\n        this._auto_update();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {(T)=> void} sub\r\n     * @param {string | undefined} [ref]\r\n     * @param {boolean} [immediate]\r\n     */\r\n    sub(sub, ref, immediate = true) {\r\n        this._subscriptions.set(ref || _id(), sub);\r\n        if(immediate) sub?.(this.value);\r\n    }\r\n\r\n    //Update (manual or automated -- cascades downstream on batch updates)\r\n    /**\r\n    * @template T\r\n    * @param {T | ((T)=> T | Promise<T>)} value\r\n    */\r\n    async update(value) {\r\n        return new Promise(async (resolve)=> {\r\n            // Group updates\r\n            if(this._updateTimeout) clearTimeout(this._updateTimeout);\r\n            this._updateTimeout = setTimeout(()=> {\r\n\r\n                _scheduleUpdate(async ()=> {\r\n                    //Apply new value   \r\n                    let newValue = (typeof value == \"function\" ? /** @type {Function} */(await value)?.(this.value) : value);\r\n                    let newHash = _hashAny(newValue);\r\n                    \r\n                    if(newHash !== this._storedHash) {\r\n                        this.value = newValue;\r\n                        this._storedHash = newHash;\r\n\r\n                        // Add this store to the work order\r\n                        for(let ds of this._downstreamStores) await ds._auto_update();\r\n\r\n                        // Wait for next animation frame to return the value\r\n                        for(let [ref, sub] of this?._subscriptions || []) sub?.(this.value, ref);\r\n                        resolve(this.value);\r\n                    }\r\n                    else {\r\n                        resolve(this.value);\r\n                    }\r\n                });\r\n            }, 0);\r\n        });\r\n    }\r\n\r\n    async _auto_update() {\r\n        let newVal = await this._updater?.(\r\n            Array.from(this._upstreamStores)?.map(S => S?.value) || [], \r\n            /** @type {T} */(this?.value)\r\n        );\r\n\r\n        await this.update(newVal === undefined ? this.value : newVal);\r\n    }\r\n}\r\n\r\n/**\r\n * STORE STATIC METHODS\r\n */\r\n/**\r\n * @template T\r\n * @param {string} name - The name of the store\r\n * @param {StoreOptions<T> | T} [ops] - Options to update the store\r\n * @returns {Store<T>}\r\n */\r\nexport let _store = (name, ops)=> {\r\n    let found_store = MFLD.st.get(name);\r\n    return ops ? (found_store ? found_store._modify(name, ops) : new Store(name, ops)) : (found_store || new Store(name, ops));\r\n}\r\n/**\r\n * @param {HTMLElement | string} scope \r\n */\r\nexport let _clearScope = (scope)=> {\r\n    // @ts-ignore\r\n    MsFt.forEach(store=> {\r\n        if(store._scope == scope) _destroy(store); \r\n    });\r\n}\r\n\r\n/**\r\n * @param {Store<any>} store \r\n */\r\nexport let _destroy = (store)=> {\r\n    // @ts-ignore\r\n    MFLD.st.delete(store.name);\r\n    // @ts-ignore\r\n    store = undefined;\r\n}","import { _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _register } from \"./registrar.js\";\r\nimport { _store } from \"./store.js\";\r\n\r\n/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {string} trigger \r\n * @param {MfldOps} fetchOps\r\n * @param {string} href\r\n * @param {string} [method] \r\n * @param {any[] | \"$form\"} [valueList]\r\n * @param {Function} [processFunc]\r\n */\r\nexport let _handleFetch = (el, trigger, fetchOps, href, method, valueList, processFunc)=> {\r\n    /**\r\n     * @param {Event} [e]\r\n     */\r\n    let ev = async e=> {  \r\n        e?.preventDefault();\r\n        e?.stopPropagation();\r\n\r\n        // Set from target element if relevant; fall back to \"get\"\r\n        if(!method) method = /** @type {any}*/(e?.target)?.method || \"get\";\r\n    \r\n        //Make sure we're allowed to fetch\r\n        let externalPermissions = fetchOps?.fetch?.externals?.find(allowed=> href?.startsWith(allowed.domain)) || \r\n            !href.match(/^https?:\\/\\//) || href.includes(location.origin) ? {\r\n                scripts: true,\r\n                styles: true,\r\n        } : undefined;\r\n\r\n        // Parse input\r\n        let input = processFunc?.(...(valueList || [])) || valueList;\r\n        let body = Array.isArray(input) ? input[0] : input == \"$form\" ? new FormData(/** @type {HTMLFormElement}*/(el)) : input;\r\n        if(processFunc) {\r\n            let toFunc = Array.isArray(input) ? (input?.map(s=> _store(s).value) || []) : [body];\r\n            body = processFunc?.(...toFunc)\r\n        }\r\n\r\n        //Fetch data\r\n        let data = await fetch(href, {\r\n            ...(fetchOps?.fetch?.request || {}),\r\n            headers: {\r\n                ...fetchOps?.fetch?.request?.headers,\r\n                \"MFLD\": \"true\",\r\n            },\r\n            method,\r\n            body: input == \"$form\" || typeof body == \"string\" ? body : JSON.stringify(body),\r\n        })\r\n        .catch(error=> {\r\n            fetchOps?.fetch?.err?.(error);\r\n        });\r\n\r\n        //Handle onCode callback\r\n        let code = data?.status;\r\n        if(code && fetchOps?.fetch?.onCode?.(code, data) == false) return;\r\n\r\n        //Return JSON or text in callback\r\n        let resp = await data?.[fetchOps?.fetch?.resType || \"text\"]();\r\n\r\n        // Handle resolutions\r\n        for(let instruction of [\"append\", \"prepend\", \"inner\", \"outer\"]) {\r\n            let ds = el.dataset[`${ATTR_PREFIX}${instruction}`];\r\n            if(ds === undefined) continue;\r\n            let [selector, toReplace] = ds?.split(\"->\").map(s=> s.trim()) || [];\r\n\r\n            //Extract content and schedule a DOM update\r\n            let fullMarkup = (new DOMParser())?.parseFromString?.(resp, 'text/html');\r\n            if(fullMarkup) {\r\n                _scheduleUpdate({\r\n                    in: /** @type {HTMLElement} */ (fullMarkup.querySelector(selector || \"body\")),\r\n                    out: /** @type {HTMLElement} */ (toReplace ? document.querySelector(toReplace) : el),\r\n                    relation: /** @type {\"append\" | \"prepend\" | \"inner\" | \"outer\"}*/(instruction),\r\n                    ops: fetchOps,\r\n                    done: (el)=> {\r\n                        _register(el)\r\n                    },\r\n                });\r\n            }\r\n        }\r\n\r\n        //Push to history if requested\r\n        if(el.dataset?.[`${ATTR_PREFIX}pushstate`] !== undefined) {\r\n            history.pushState({}, \"\", href);\r\n        }\r\n\r\n        let resolveTxt = el.dataset?.[`${ATTR_PREFIX}resolve`];\r\n        let resolveFunc = _parseFunction(resolveTxt || \"\")?.func;\r\n        resolveFunc?.(resp);\r\n\r\n            // //Clear existing scripts/styles\r\n            // for(let s of [pageScripts, pageStyles]) {\r\n            //     let elements = s.get(fullMarkup) || [];\r\n            //     elements.forEach(el => el.remove());\r\n            //     s.set(fullMarkup, []);\r\n            // }\r\n\r\n            // //Get scripts and styles\r\n            // let seek: string[] = ops.allowScripts ? [\"scripts\"] : [];\r\n            // if(ops.allowStyles) seek.push(\"style\");\r\n            // if(seek.length) {\r\n            //     let globls: NodeListOf<HTMLScriptElement | HTMLStyleElement> = fullMarkup.querySelectorAll(seek.join(\",\"));\r\n            //     for(let el of globls) {\r\n            //         let isScript = el instanceof HTMLScriptElement;\r\n            //         let source = isScript ? pageScripts : pageStyles;\r\n\r\n            //         if(isScript ? ops.allowScripts : ops.allowStyles){\r\n            //             if(!source.has(parent)) source.set(parent, []);\r\n            //             source.get(parent)?.push(el as any);\r\n            //         }\r\n            //         else if(isScript) el.parentNode?.removeChild(el);\r\n            //     }\r\n            // }\r\n    }\r\n\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}","import { _store } from \"./store\";\r\nimport { _id } from \"./util\";\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n * @returns {HTMLElement}\r\n */\r\nexport let _ensureNodeName = (el, nodeName, skipAttributes = [], removeClasses = [])=> {\r\n    if(el.tagName == nodeName) return el;\r\n\r\n    let newEl = document.createElement(nodeName);\r\n    newEl.innerHTML = el.innerHTML;       \r\n    [...el.attributes].filter(attr => !skipAttributes.includes(attr.name)).forEach(attr => newEl.setAttribute(attr.name, attr.value));\r\n    removeClasses.forEach(cls => newEl.classList.remove(cls));\r\n    el.replaceWith(newEl);\r\n\r\n    return newEl;\r\n}\r\n\r\n/**\r\n * @param {any} obj \r\n * @param {(value: any, index: any, array?: any)=> void} cb \r\n */\r\nexport let _iterable = (obj, cb)=> {\r\n    if(obj instanceof Map) for(const [key, value] of obj.entries()) cb(key, value);\r\n    else {\r\n        try { \r\n            let arr = Array.from(obj || []);\r\n            if(arr?.length) arr.forEach(cb);\r\n            else for(let key in obj) cb(key, obj[key]);\r\n        }\r\n        catch(e) { console.error(`${obj} is not iterable`); }\r\n    }\r\n}\r\n\r\n// Returns the sibling that fails the condition\r\n/**\r\n * @param {Element | null} [sib] \r\n * @param {Function} [breakFn] \r\n * @param {Function} [cb] \r\n * @returns {Element | null | undefined}\r\n */\r\nexport let _iterateSiblings = (sib, breakFn, cb)=> {\r\n    return breakFn?.(sib) ? sib : _iterateSiblings(cb?.(sib) || sib?.nextElementSibling, breakFn, cb);\r\n}\r\n\r\n/**\r\n * @typedef InternalStoreOptions\r\n * @property {Function} [func]\r\n * @property {HTMLElement} [observeEl]\r\n * @property {boolean} [allowFalse]\r\n */\r\n\r\n/**\r\n * @param {string[]} [storeList] \r\n * @param {InternalStoreOptions} [options]\r\n * @returns \r\n */\r\nexport let _registerInternalStore = (storeList = [], options)=> {\r\n    // Register new store (to prevent excess evaluations)\r\n    return _store(_id(), {\r\n        upstream: [...storeList],\r\n        updater: (list)=> {\r\n            try {\r\n                return options?.func?.(...list) || list[0];\r\n            }\r\n            catch(_) {\r\n                return;\r\n            }\r\n        },\r\n        scope: options?.observeEl,\r\n    });\r\n}","import { _registerInternalStore } from \"./domutil\";\r\nimport { _store } from \"./store\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _inputNestSplitRx } from \"./util\";\r\n\r\nexport let _handleBindSync = (el, inputs, output, trigger, mode, processFunc)=> {\r\n    if(mode.match(\"bind\")) {\r\n        _registerInternalStore(inputs, {\r\n            observeEl: el,\r\n            func: ()=> {\r\n                let val = processFunc?.(...inputs.map(input => MFLD.st.get(input).value || window.value), el);\r\n                if(output && val != undefined) {\r\n                    let [type, attr] = output.split(\":\");\r\n                    if(type == \"style\") el.style[attr] = val;\r\n                    else if(type == \"attr\") el.setAttribute(attr, val);\r\n                    else el[output] = val;\r\n                }\r\n                el.dispatchEvent(new CustomEvent(trigger));\r\n                return val;\r\n            }\r\n        });\r\n    } else {\r\n        let ev = ()=> {\r\n            if(inputs.length > 1) console.warn(\"Multiple sync props\", el);\r\n            let [type, attr] = inputs?.[0].trim().split(\":\");\r\n            let val = type == \"style\" ? el.style[attr] : type == \"attr\" ? el.getAttribute(attr) : el[type];\r\n            let numVal = parseFloat(val);\r\n            if(!isNaN(numVal)) val = numVal;\r\n            let value = processFunc?.(val, el);\r\n            if(output && value !== undefined) _store(output)?.update?.(value);\r\n        }\r\n        if(trigger == \"$mount\") ev();\r\n        else el.addEventListener(trigger, ev);\r\n    }\r\n}","import { _ensureNodeName, _iterable, _iterateSiblings, _registerInternalStore } from \"./domutil\";\r\nimport { _register } from \"./registrar\";\r\nimport { _store } from \"./store\";\r\nimport { _applyTransition, _scheduleUpdate } from \"./updates\";\r\nimport { _parseFunction, ATTR_PREFIX } from \"./util\";\r\n\r\n/**\r\n * Handle conditional and loop elements\r\n * @param {HTMLElement} el \r\n * @param {string} mode \r\n * @param {string[]} as \r\n * @param {Function | undefined} func\r\n * @param {any[]} valueList\r\n * @param {import(\".\").MfldOps} ops \r\n */\r\nexport let _handleTemplates = (el, mode, as, func, valueList, ops)=> {\r\n    let startElement = document.createElement(\"template\");\r\n    let templ = /** @type {HTMLTemplateElement}*/(_ensureNodeName(/** @type {HTMLElement}*/(el.cloneNode(true)), \"TEMPLATE\"));\r\n    startElement.classList.add(`${mode}-start`);\r\n    templ.classList.add(`${mode}-end`);\r\n\r\n    templ.dataset.nodeName = el.nodeName;\r\n    el.before(startElement);\r\n    el.after(templ);\r\n    el.remove();\r\n\r\n    let templStore = _registerInternalStore(\r\n        valueList, \r\n        { func, observeEl: templ }\r\n    );\r\n\r\n    // Clear old elements\r\n    templStore.sub(val=> {\r\n        _scheduleUpdate(()=> {\r\n            _iterateSiblings(\r\n                startElement?.nextElementSibling, \r\n                (sib)=> sib?.classList?.contains(`${mode}-end`),\r\n                (sib)=> _applyTransition(/** @type {HTMLElement}*/(sib), \"out\", ops, ()=> sib?.remove()), \r\n            );\r\n\r\n            let it = mode.match(/each/) ? _iterable : (object, cb)=> cb(object || \"\");\r\n\r\n            it(val, (val, key)=> {\r\n                if(val == undefined) return;\r\n                let html = templ?.innerHTML || templ?.textContent?.replace(/^\\n{0,}|\\n{0,}$/, \"\") || \"\";\r\n\r\n                // Get all logical bindings and replace values\r\n                let replacements = html.match(/\\${[^}]*}/g) || [];\r\n                for(let rep of replacements) {\r\n                    try {\r\n                        let fn = _parseFunction(`(${as.join(\",\")})=> ${rep.slice(2, rep.length-1)}`)?.func;\r\n                        html = html.replace(rep, fn?.(val, key) || \"\");\r\n                    }\r\n                    catch(e) {\r\n                        html = \"Error in template. Check console for details.\"\r\n                        console.error(e);\r\n                    }\r\n                }\r\n\r\n                let elms;\r\n                if(mode.match(/each/)) {\r\n                    let item = /** @type {HTMLTemplateElement}*/(templ.cloneNode(true));\r\n                    item.innerHTML = html || val;\r\n                    elms = item.content.children;\r\n                }\r\n                else {\r\n                    let item = /** @type {HTMLTemplateElement}*/(_ensureNodeName(/** @type {HTMLElement}*/(templ.cloneNode(true)), templ.dataset.nodeName, [\"data-node-name\", `data-${ATTR_PREFIX}`], [`${mode}-end`]));\r\n                    item.innerHTML = html || val;\r\n                    elms = [item];\r\n                }\r\n\r\n                // Replace values\r\n                for(let element of elms) {\r\n                    templ.before(element);\r\n                    _applyTransition(/** @type {HTMLElement}*/(element), \"in\", ops, ()=> _register(/** @type {HTMLElement}*/(element)));\r\n                }\r\n            });\r\n        });\r\n    });\r\n}","import { _store } from \"./store.js\";\r\nimport { _scheduleUpdate } from \"./updates.js\";\r\nimport { _commaSepRx, _getOpOverrides, _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _handleFetch } from \"./fetch.js\";\r\nimport { _handleBindSync } from \"./bindsync.js\";\r\nimport { _handleTemplates } from \"./templates.js\";\r\n/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\n/** @type {Partial<MfldOps>} */\r\nlet _ops = {};\r\nlet _modes = [\"bind\", \"sync\", \"templ\", \"if\", \"each\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\"].map(m=> `${ATTR_PREFIX}${m}`);\r\n\r\n/**!\r\n * @param {Partial<MfldOps>} newops \r\n * @param {string} [profileName] \r\n */\r\nexport let _setOptions = (newops, profileName)=> {\r\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\r\n    else _ops = { ..._ops, ...newops };\r\n}\r\n\r\n// Handle location state changes\r\nwindow.addEventListener(\"popstate\", (e)=> {\r\n    // for(let update of e.state) {\r\n    //     _scheduleUpdate(update);\r\n    // }\r\n});\r\n\r\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\r\n/**\r\n * @param {HTMLElement | null} [parent] \r\n */\r\nexport let _register = (parent)=> {\r\n    if(parent && parent.nodeType == Node.TEXT_NODE) return;\r\n\r\n    /** @type {NodeListOf<HTMLElement> | []} */\r\n    let els = (parent || document.body).querySelectorAll(\r\n        `[data-${_modes.join(`],[data-`)}],a,form`\r\n    ) || [];\r\n\r\n    for(let el of els) {\r\n        let _op_overrides = _getOpOverrides(_ops, el);\r\n\r\n        //Check for <a> and <form> elements\r\n        if(el.dataset?.[`${ATTR_PREFIX}promote`] !== undefined) {\r\n            let [mode, href, input, trigger] = el.tagName == \"A\" ?\r\n                [\"get\", /** @type {HTMLAnchorElement}*/(el).href, [], \"click\"] : \r\n                [/** @type {HTMLFormElement}*/(el).method.toLowerCase(), /** @type {HTMLFormElement}*/(el).action, \"$form\", \"submit\"];\r\n\r\n            if(href) {\r\n                _handleFetch(el, trigger, _op_overrides, href, mode, /** @type {any[] | \"$form\"}*/(input));\r\n                continue;\r\n            }\r\n        }\r\n\r\n        //Loop over all data attributes (modes)\r\n        for(let mode in el.dataset) {\r\n            if(!_modes.includes(mode)) continue;\r\n            let shouldHaveTriggers = !mode.match(/bind|templ|if|each/);\r\n\r\n            //Loop over provided settings\r\n            for(let setting of el.dataset?.[mode]?.split(\";;\") || []) {\r\n                //Break out settings\r\n                let [sourceParts, output] = setting?.split(\"->\")?.map(s=> s.trim()) || [];\r\n                let triggers = shouldHaveTriggers ?sourceParts.slice(0, sourceParts.indexOf(\")\"))?.match(/[^\\(\\)]{1,}/g)?.pop()?.split(_commaSepRx)?.map(s=> s.trim()) || [] : [];\r\n                if(!output && mode.match(/get|head|post|put|delete|patch/)) {\r\n                    output = sourceParts.slice(sourceParts.indexOf(\")\") + 1);\r\n                    sourceParts = \"\";\r\n                }\r\n                let processFuncStr = shouldHaveTriggers ? sourceParts?.slice(sourceParts.indexOf(\")\") + 1) : sourceParts;\r\n\r\n                //Handle errors\r\n                if(shouldHaveTriggers && !triggers?.length) { console.error(\"No trigger\", el); break; }\r\n\r\n                let { func, valueList, as } = _parseFunction(processFuncStr);\r\n                if(processFuncStr && !func) console.warn(`\"${processFuncStr}\" not registered`, el);\r\n\r\n                //Handle conditionals and loops\r\n                if(mode.match(/if|each|templ/)) _handleTemplates(el, mode, as || [], func, valueList || [], _op_overrides);\r\n                else {\r\n                    //Loop over triggers\r\n                    if(!triggers?.length) triggers = [\"\"]\r\n                    for(let trigger of triggers) {\r\n                        if(mode.match(/bind|sync/)) _handleBindSync(el, valueList, output, trigger, mode, func);\r\n                        else {\r\n                            _handleFetch(el, trigger, _op_overrides, output, mode.replace(ATTR_PREFIX, \"\"), valueList, func);\r\n                        }\r\n                    }\r\n                }\r\n            }; //End loop settings\r\n        }; //End loop dataset\r\n    };  //End loop elements\r\n}","import { _store } from \"./store.js\";\r\nimport { _addToNextTickQueue } from \"./updates.js\";\r\nimport { _register, _setOptions } from \"./registrar.js\";\r\n\r\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\r\n\r\n/**!\r\n * @typedef {object} ExternalOptions\r\n * @property {string} domain - The domain name these settings apply to\r\n * @property {boolean} [scripts] - Allow scripts from this domain to execute\r\n * @property {boolean} [styles] - Allow styles from this domain to apply\r\n */\r\n\r\n/**!\r\n * @typedef {object} FetchOptions\r\n * @property {RequestInit} [request] - Fetch request options\r\n * @property {\"json\"|\"text\"} [resType] - Response type (default: \"text\")\r\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\r\n * @property {(code: number, data: void | Response)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\r\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\r\n */\r\n\r\n/**!\r\n * @typedef {object} TransitionOptions\r\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\r\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\r\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\r\n * @property {boolean} [smart] - Enable smart transitions (default: true)\r\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\r\n */\r\n\r\n/**!\r\n * Manifold options for `fetch`, `trans`, and `profiles`.\r\n * @typedef {Object} MfldOps\r\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\r\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\r\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback UpdaterFunction\r\n * @param {Array<any>} upstreamValues\r\n * @param {T} value\r\n * @returns {T | Promise<T>}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback ValueDeterminer\r\n * @param {T} [currentValue]\r\n * @returns {T | Promise<T> | undefined}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback UpdateFunction\r\n * @param {T | ValueDeterminer<T>} value\r\n * @returns {T | Promise<T> | undefined}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback SubDeterminer\r\n * @param {T} value\r\n * @returns {void}\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @callback SubFunction\r\n * @param {SubDeterminer<T>} value The store's current value\r\n * @returns void\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef {Object} StoreOptions\r\n * @property {T} [value]\r\n * @property {Array<string>} [upstream]\r\n * @property {UpdaterFunction<T>} [updater]\r\n * @property {HTMLElement | SVGScriptElement | \"global\"} [scope]\r\n */\r\n\r\n/**!\r\n * @template T\r\n * @typedef Store\r\n * @prop {T} value - The store's current value (read only)\r\n * @prop {UpdateFunction<T>} update - Update the store's current value\r\n * @prop {SubFunction<T>} sub - Add a subscription function to the store\r\n */\r\n\r\n/**!\r\n * @typedef {Function} MfldFunc\r\n * @param {any} val\r\n * @param {HTMLElement} [el]\r\n */\r\n\r\n/**!\r\n * The global Manifold interface.\r\n */\r\nexport let Mfld = {\r\nstore: \r\n/**!\r\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @template T\r\n* @param {string} store_name\r\n* @param {StoreOptions<T> | T} store_ops\r\n* @return {Store<T>}\r\n*/ (store_name, store_ops)=> {\r\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\r\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\r\n    }\r\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\r\n},\r\nustore: \r\n/**!\r\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \r\n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\r\n* @param {string} store_name\r\n* @param {StoreOptions<any> | any} store_ops\r\n* @return {Store<any>}\r\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\r\nget:\r\n/**!\r\n * - Retrieve a Manifold store by name. *returns `Store\\<any\\>`*\r\n * @param {string} store_name\r\n * @return {Store<any>}\r\n */ (store_name)=> /**@type {Store<any>}*/(_store(store_name)),\r\nfunc: \r\n/**!\r\n * - Retrieve a Manifold function by name. *val* refers to the store's current value; *el* refers to the element that triggered the update (if applicable). *returns `MfldFunc`*\r\n * - *Note:* Functions retrived using this method cannot infer the type of the store's value and is therefore **not** type-checked. It is preferable to keep a reference to the function if you need to preserve type information.\r\n * @param {string} func_name\r\n * @return {MfldFunc}\r\n */ (func_name)=> /** @type {(val: any, el?: HTMLElement)=> void}*/(\r\n// @ts-ignore\r\n MFLD.fn[func_name]),\r\nfuncs: \r\n/**!\r\n * - Add functions to the Manifold function registry in key-value pairs.\r\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \r\n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\r\n * @param {{ [key: string]: MfldFunc }} funcs\r\n */ funcs=> {\r\n    for(let key in funcs) {\r\n    // @ts-ignore\r\n    MFLD.fn[key] = funcs[key];\r\n }},\r\nconfig:\r\n/**!\r\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\r\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\r\n * @param {MfldOps} new_ops\r\n * @param {string} [profile_name]\r\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\r\n onTick:\r\n /**!\r\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\r\n  * @param {()=> void} cb\r\n  */ (cb)=> _addToNextTickQueue(cb),\r\nregister:\r\n/**!\r\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\r\n * @param {HTMLElement | string | null} [parent]\r\n */ (parent)=> {\r\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\r\n        _register(parent)\r\n    },\r\n};"],"names":["ATTR_PREFIX","_inputNestSplitRx","_commaSepRx","_id","Date","now","Math","floor","random","_getOpOverrides","ops","el","override","dataset","overrides","profiles","_parseFunction","condition","datakey","undefined","fstr","values","split","map","s","trim","reverse","fn","asStr","as","valueList","replace","func","window","MFLD","length","includes","match","filter","v","Function","e","console","error","workArray","cancelAnimationFrame","_nextTickQueue","_scheduleUpdate","update","push","requestAnimationFrame","_runUpdates","_addSpacer","inEl","wrapper","wrapperHeight","trans","smart","paddingTop","paddingBottom","Element","getComputedStyle","spacer","document","createElement","style","height","abs","clientHeight","after","_adjustSizing","dur","animate","order","out","_getDimensionsAfterUpdate","relation","in","_applyTransition","prepend","container","cloneNode","border","replaceChildren","replaceWith","appendChild","done","forEach","dir","refElement","nodeType","Node","TEXT_NODE","textContent","Array","isArray","transClass","class","classList","add","hooks","dimensions","_getDimensions","position","width","w","left","top","margin","transitionDuration","setTimeout","remove","swap","rect","getBoundingClientRect","clientWidth","paddingLeft","paddingRight","scrollX","scrollY","_hashAny","input","Map","Set","from","entries","hash","char","TextEncoder","encode","toString","st","mut","Store","_updater","_subscriptions","_storedHash","_upstreamStores","_downstreamStores","_scope","_updateTimeout","constructor","name","this","_modify","scope","currentScript","set","mutOb","get","toRemove","observer","MutationObserver","muts","type","node","removedNodes","store","_destroy","disconnect","delete","observe","parentElement","childList","upstream","S","_store","value","updater","_auto_update","sub","ref","immediate","Promise","async","resolve","clearTimeout","newValue","newHash","ds","newVal","found_store","_handleFetch","trigger","fetchOps","href","method","processFunc","ev","preventDefault","stopPropagation","target","fetch","externals","find","allowed","startsWith","domain","location","origin","body","FormData","toFunc","data","request","headers","JSON","stringify","catch","err","code","status","onCode","resp","resType","instruction","selector","toReplace","fullMarkup","DOMParser","parseFromString","querySelector","_register","history","pushState","resolveTxt","resolveFunc","addEventListener","_ensureNodeName","nodeName","skipAttributes","removeClasses","tagName","newEl","innerHTML","attributes","attr","setAttribute","cls","_iterable","obj","cb","key","arr","_iterateSiblings","sib","breakFn","nextElementSibling","_registerInternalStore","storeList","options","list","_","observeEl","_handleBindSync","inputs","output","mode","val","dispatchEvent","CustomEvent","warn","getAttribute","numVal","parseFloat","isNaN","_handleTemplates","startElement","templ","before","contains","object","elms","html","replacements","rep","join","slice","item","content","children","element","_ops","_modes","m","parent","els","querySelectorAll","_op_overrides","toLowerCase","action","shouldHaveTriggers","setting","sourceParts","triggers","indexOf","pop","processFuncStr","Mfld","store_name","store_ops","hasOwnProperty","ustore","func_name","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register"],"mappings":"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"}