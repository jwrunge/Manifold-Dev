{"version":3,"file":"dev.global.mfld.js","sources":["../src/util.js","../src/updates.js","../src/store.js","../src/fetch.js","../src/domutil.js","../src/bindsync.js","../src/templates.js","../src/registrar.js","../src/index.js","../src/component.js","../src/index.global.js"],"sourcesContent":["import { _store } from \"./store.js\";\r\n\r\nexport let ATTR_PREFIX = \"mf_\";\r\nexport let _commaSepRx = /, {0,}/g;\r\n\r\nexport let _id = ()=> {\r\n    return `${Date.now()}.${Math.floor(Math.random() * 100_000)}`;\r\n}\r\n\r\n/** \r\n * @template T\r\n * @typedef {import(\"./store.js\").Store<T>} Store \r\n */\r\n\r\n/**\r\n * @param {import(\".\").MfldOps} ops\r\n * @param {HTMLElement} el\r\n * @returns {import(\".\").MfldOps}\r\n */\r\nexport let _getOpOverrides = (ops, el)=> {\r\n    let overrides = ops.profiles?.[el.dataset?.override || \"\"];\r\n    let res = { ...ops, ...overrides };\r\n    \r\n    // ad hoc overrides\r\n    for(let set in el.dataset) {\r\n        for(let key of [\"fetch\", \"trans\"]) {\r\n            if(set.startsWith(`${ATTR_PREFIX}${key}_`)) {\r\n                try {\r\n                    let prop = set.split(\"_\")[2];\r\n                    /** @type {any} */\r\n                    let val = el.dataset[set];\r\n                    if(val?.match(/\\{|\\[/)) val = JSON.parse(val);\r\n                    else if(parseInt(val)) val = parseInt(val);\r\n                    if(Array.isArray(val)) val = val.map(v=> parseInt(v) || v);\r\n                    res[key][prop] = val;\r\n                }\r\n                catch(e) {\r\n                    console.error(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\n/**\r\n * @param {string} condition \r\n * @param {string} [valArg] \r\n * @param {string} [keyArg] \r\n * @returns {{ func?: Function, as?: string[] }}\r\n */\r\nexport let _parseFunction = (condition, valArg, keyArg)=> {\r\n    try {\r\n        let [fnStr, asStr] = condition?.split(/\\s{1,}as\\s{1,}/) || [condition, \"value\"],\r\n            fn = fnStr?.match(/^\\s{0,}(function)?\\(.{0,}\\)(=>)?\\s{0,}/) ? `(${fnStr})()` : fnStr,\r\n            fnText = `let {$el, $st, $fn, ${valArg || \"$val\"}, ${keyArg || \"$key\"}, $body} = ops;return ${fn}`,    // Take $el as a reference to the element; assign global refs to $fn and $st\r\n            as = asStr?.split?.(_commaSepRx)?.map?.(s=> s.trim()) || [\"value\"] || [];\r\n        let func = new Function(\"ops\", fnText);\r\n        return { func, as };\r\n    }\r\n    catch(e) {\r\n        console.error(e);\r\n        return {};\r\n    }\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {Event} [ev]\r\n * @param {string} [href]\r\n */\r\nexport function _handlePushState(el, ev, href) {\r\n    ev?.preventDefault();\r\n\r\n    let pushState = el.dataset?.[`${ATTR_PREFIX}pushstate`];\r\n    /** @type {string | undefined} */\r\n    let push = href;\r\n    switch(pushState) {\r\n        case \"\": break;\r\n        case undefined: return;\r\n        default: push = `#${pushState}`\r\n    }\r\n\r\n    history.pushState(null, \"\", push);\r\n}","/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\nimport { _glob } from \"./store.js\";\r\nimport { ATTR_PREFIX } from \"./util.js\";\r\n\r\n/**\r\n * @typedef {Object} DomWorkOrder\r\n * @property {HTMLElement} in - The input HTMLElement\r\n * @property {HTMLElement} out - The output HTMLElement\r\n * @property {\"append\" | \"prepend\" | \"inner\" | \"outer\"} relation - The relation between the input and output elements\r\n * @property {Partial<MfldOps>} ops - The fetch options for the operation\r\n * @property {(el: HTMLElement | null) => void} done - The callback function to be executed when the operation is done\r\n */\r\n\r\n/** @type {(DomWorkOrder | Function)[]} */ let workArray = [];\r\nlet cancelAnimationFrame = 0;\r\n/** @type {Map<string, (any | ((any)=> any))>} */\r\n\r\n// Next tick queue\r\n/**\r\n * @type {Function[]}\r\n */\r\nlet _nextTickQueue = [];\r\n\r\n/** @type {HTMLElement | null} */\r\nlet spacer;\r\nlet spacerHeight = \"\";\r\n\r\nexport let _addToNextTickQueue = (fn)=> {\r\n    fn && _nextTickQueue.push(fn);\r\n}\r\n\r\nexport let _scheduleUpdate = (update)=> {\r\n    workArray.push(update);\r\n    if(!cancelAnimationFrame) {\r\n        cancelAnimationFrame = requestAnimationFrame(_runUpdates);\r\n    }\r\n}\r\n\r\nlet _addSpacer = (inEl, wrapper, wrapperHeight, ops)=> {\r\n    if(!(ops.trans?.smart ?? true)) return;\r\n    let { paddingTop, paddingBottom } = wrapper instanceof Element ? getComputedStyle(wrapper) : { paddingTop: 0, paddingBottom: 0 };\r\n    let spacer = document.createElement(\"div\");\r\n    spacer.style.height = `calc(${Math.abs(wrapperHeight - (inEl?.clientHeight || 0))}px - ${paddingTop} - ${paddingBottom})`;\r\n    wrapper?.after(spacer);\r\n}\r\n\r\nlet _adjustSizing = (inEl, ops)=> {\r\n    if(!ops.trans?.smart ?? true) return;\r\n    let dur = (ops?.trans?.dur?.[0] || ops?.trans?.dur || 600)/2\r\n    _scheduleUpdate(()=> {\r\n        spacer?.remove();\r\n        inEl?.animate?.([\r\n            { height: spacerHeight },\r\n            { height: `${inEl.clientHeight || 0}px` }\r\n        ], dur);\r\n    });\r\n}\r\n\r\nlet _runUpdates = ()=> {\r\n    cancelAnimationFrame = 0;\r\n    \r\n    for(let order of workArray) {\r\n        if(typeof order == \"function\") {\r\n            order();\r\n            continue;\r\n        }\r\n\r\n        let wrapperHeight = order.out ? order.out.clientHeight : 0;\r\n        let _getDimensionsAfterUpdate = order.relation == \"inner\";\r\n\r\n        if(order.relation == \"prepend\") {\r\n            _addSpacer?.(order.in, order.out, wrapperHeight, order.ops);\r\n            _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                order.out?.prepend(order.in);\r\n                _adjustSizing?.(order.in, order.ops);\r\n            });\r\n        }\r\n        else {\r\n            if([\"inner\", \"outer\"].includes(order.relation)) {\r\n                let container = /** @type {HTMLElement}*/(order.out?.cloneNode(true));\r\n                if(container) {\r\n                    order.out?.after(container);\r\n                    if(_getDimensionsAfterUpdate) {\r\n                        container.style.border = \"none\";\r\n                        order.out.replaceChildren();\r\n                    }\r\n                    _applyTransition(container, \"out\", order.ops, undefined, order.out, _getDimensionsAfterUpdate);\r\n                }\r\n            }\r\n\r\n            _addSpacer?.(order.in, order.out, wrapperHeight, order.ops);\r\n            _applyTransition(order.in, \"in\", order.ops, ()=> {\r\n                if(order.relation == \"outer\") order.out?.replaceWith(order.in)\r\n                else order.out?.appendChild(order.in);\r\n                _adjustSizing?.(order.in, order.ops);\r\n            });\r\n        }\r\n\r\n        order.done?.(order.in);\r\n    }\r\n\r\n    _nextTickQueue.forEach(fn => fn());\r\n    _nextTickQueue = [];\r\n    workArray = [];\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {\"in\" | \"out\"} dir \r\n * @param {Partial<MfldOps>} ops \r\n * @param {Function} [fn] \r\n * @param {HTMLElement} [refElement]\r\n * @param {boolean} [_getDimensionsAfterUpdate]\r\n * @param {Function} [after]\r\n * @returns \r\n */\r\nexport let _applyTransition = (el, dir, ops, fn, refElement, _getDimensionsAfterUpdate = false, after)=> {\r\n    if(el?.nodeType == Node.TEXT_NODE) {\r\n        el.replaceWith(document?.createElement(\"div\"));\r\n        el.textContent = el.textContent;\r\n    }\r\n\r\n    if(el) {\r\n        const dur = Array.isArray(ops.trans?.dur) ? ops.trans?.dur[dir == \"in\" ? 0 : 1] || ops.trans?.dur[0] : ops.trans?.dur || 0;\r\n        const transClass = ops?.trans?.class || `${ATTR_PREFIX}trans`;\r\n        el?.classList?.add(transClass);\r\n        ops.trans?.hooks?.[`${dir}-start`]?.(el);\r\n\r\n        if(dir == \"out\") {\r\n            refElement = refElement || el;\r\n            if(!refElement) return;\r\n            let dimensions = {};\r\n            if((ops.trans?.smart ?? true) && !_getDimensionsAfterUpdate) {\r\n                dimensions = _getDimensions(refElement);\r\n            }\r\n\r\n            _scheduleUpdate(()=> {\r\n                if((ops.trans?.smart ?? true) && _getDimensionsAfterUpdate && refElement) {\r\n                    dimensions = _getDimensions(refElement);\r\n                }\r\n\r\n                if(ops.trans?.smart ?? true) {\r\n                    el.style.position = \"fixed\";\r\n                    el.style.width = dimensions.w;\r\n                    el.style.left = dimensions.left;\r\n                    el.style.top = dimensions.top;\r\n                    el.style.margin = \"0\";\r\n                }\r\n                if(dur) el.style.transitionDuration = `${dur}ms`;\r\n\r\n                el.classList?.add(\"out\");\r\n            })\r\n        }\r\n        else {\r\n            el?.classList?.add(\"in\");\r\n            if(dur) el.style.transitionDuration = `${dur}ms`;\r\n            fn?.();\r\n            setTimeout(()=> {\r\n                _scheduleUpdate(()=> {\r\n                    setTimeout(()=> _scheduleUpdate(()=> el?.classList?.remove(dir)), 0);\r\n                });\r\n            }, ops.trans?.swap || 0);\r\n        }\r\n        \r\n        setTimeout(()=> {\r\n            _scheduleUpdate(()=> {\r\n                if(dir == \"out\") el?.remove();\r\n                el?.classList?.remove(transClass);\r\n                ops.trans?.hooks?.[`${dir}-end`]?.(el);\r\n                el.style.transitionDuration = \"\";\r\n                if(dir == \"in\") after?.(el);\r\n            });\r\n        }, \r\n        dur + (dir == \"in\" ? ops.trans?.swap || 0 : 0));\r\n    }\r\n}\r\n\r\nlet _getDimensions = (refElement)=> {\r\n    let style = getComputedStyle(refElement);\r\n    let rect = refElement.getBoundingClientRect();\r\n    return {\r\n        w: `calc(${(refElement).clientWidth}px - ${style.paddingLeft} - ${style.paddingRight})`,\r\n        left: `calc(${rect.left}px + ${_glob.scrollX}px)`,\r\n        top: `calc(${rect.top}px + ${_glob.scrollY}px)`\r\n    };\r\n}","/** \n * @template T\n * @typedef {import(\"./index.js\").UpdaterFunction<T>} UpdaterFunction \n */\n/** \n * @template T\n * @typedef {import(\"./index.js\").StoreOptions<T>} StoreOptions \n */\n\nimport { _scheduleUpdate } from \"./updates.js\";\nimport { _id } from \"./util.js\";\n\n/**\n * @template T\n * @param {string} name - The name of the store\n * @param {StoreOptions<T>} [ops] - Options to update the store\n * @returns {Store<T>}\n */\nexport let _store = (name, ops)=> {\n    let found_store = /** @type {Store<any>}*/(_glob.MFLD.st.get(name));\n    return ops ? (found_store ? found_store._modify(name, ops) : new Store(name, ops)) : (found_store || new Store(name, ops));\n}\n\n/**!\n * @typedef {object} MFLDGlobal\n * @property {Map<string, Store<any>>} st\n * property {Map<HTMLElement, { toRemove: Set<Store<any>>, observer: MutationObserver }>} mut\n * @property {<T>(name: string, ops?: import(\".\").StoreOptions<T> | undefined) => Store<T>} $st\n * @property {{[key: string]: Function}} $fn\n * @property {{[key: string]: CustomElementConstructor}} comp\n */\n\n/**!\n * @typedef {Window & { MFLD: MFLDGlobal }} MFLDWindowObj\n * @property {MFLDGlobal} MFLD\n */\n// @ts-ignore\nexport let _glob = /** @type {MFLDWindowObj}*/(window);\n\nif(!_glob.MFLD) _glob.MFLD = {\n    st: new Map(),\n    // mut: new Map(),\n    $st: new Proxy(_store, {\n        get: (store, property)=> {\n            return store(/** @type {string}*/(property))?.value;\n        },\n        set: (store, property, value)=> {\n            let propParts = /** @type {string}*/(property).split(/[\\.\\[\\]\\?]{1,}/g).map(s=> parseFloat(s.trim()) || s.trim()),\n                S = store(/** @type {string}*/(propParts[0])),\n                ret = S.value;\n\n            for(let part of propParts.slice(1) || []) ret = ret[part];\n            ret = value;\n            S.update(ret);\n\n            return true;\n        }\n    }),\n    $fn: {},\n    comp: {}\n}\n\n/**\n * @callback SubFunction\n * @param {any} value\n * @param {string} [ref]\n * @returns {void}\n */\n\n/**\n * @param {any} input \n * @returns {any}\n */\nlet _hashAny = (input)=> {\n    if(!input) return 0;\n    if(typeof input == 'number' || input === true) return input;\n    if(input instanceof Map || input instanceof Set) return _hashAny(Array.from(input.entries() || input));\n\n    let hash = 0;\n    for(let char of new TextEncoder().encode(input?.toString() || \"\")) \n        hash = ((hash << 5) - hash) + char;\n    return hash;\n}\n\n/**\n * @template T\n */\nexport class Store {\n    /** @type {UpdaterFunction<T> | undefined} */ _updater = undefined;\n    /** @type {Map<string, SubFunction>} */ _subscriptions = new Map();\n    /** @type {string | undefined} */ _storedHash = undefined;\n    /** @type {Set<Store<any>>} */ _upstreamStores = new Set();\n    /** @type {Set<Store<any>>} */ _downstreamStores = new Set();\n    /** @type {HTMLElement | SVGScriptElement | string | \"global\"} */ _scope;\n    /** @type {any | undefined} */ _updateTimeout;\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    constructor(name, ops) {\n        return this._modify(name, ops);        \n    }\n\n    /**\n     * @param {string} name\n     * @param {StoreOptions<T>} [ops]\n     */\n    _modify(name, ops) {\n        this.name = name;\n        this._scope = ops?.scope || document.currentScript || \"global\";\n        _glob.MFLD.st.set(name, this);\n\n        // //Watch for scope destroy\n        // if(this._scope instanceof Element) {\n        //     let mutOb = _glob.MFLD.mut.get(/** @type {HTMLElement}*/(this._scope)) || { toRemove: new Set(), observer: /** @type {MutationObserver | null}*/(null) };\n        //     if(!mutOb.observer) {\n        //         mutOb.observer = new MutationObserver((muts)=> {\n        //             for(let mut of muts) {\n        //                 if(mut.type == \"childList\") {\n        //                     for(let node of mut.removedNodes) {\n        //                         if(node instanceof Element) {\n        //                             for(let store of mutOb.toRemove) {\n        //                                 if(store._scope == /** @type {HTMLElement}*/(node)) {\n        //                                     let scope = this._scope;\n        //                                     _destroy(store);\n        //                                     mutOb.observer?.disconnect();\n        //                                     mutOb.toRemove.delete(store);\n        //                                     // @ts-ignore\n        //                                     MFLD.mut.delete(scope)\n        //                                 }\n        //                             }\n        //                         }\n        //                     }\n        //                 }\n        //             }\n        //         });\n        //         /** @type {MutationObserver}*/(mutOb.observer).observe(/** @type {HTMLElement}*/(this._scope?.parentElement), { childList: true });\n        //     }\n        //     mutOb.toRemove.add(this);\n        //     // @ts-ignore\n        //     MFLD.mut.set(this._scope, mutOb);\n        // }\n        \n        (ops?.upstream?.map(s=> {\n            let S = _store(s);\n            this._upstreamStores.add(S);\n            S._downstreamStores.add(this);\n            return S;\n        }) || []);\n\n        this.value = ops?.value;\n        this._updater = ops?.updater;\n        this._auto_update();\n        return this;\n    }\n\n    /**\n     * @param {(T)=> void} sub\n     * @param {string | undefined} [ref]\n     * @param {boolean} [immediate]\n     */\n    sub(sub, ref, immediate = true) {\n        this._subscriptions.set(ref || _id(), sub);\n        if(immediate) sub?.(this.value);\n    }\n\n    //Update (manual or automated -- cascades downstream on batch updates)\n    /**\n    * @template T\n    * @param {T | ((T)=> T | Promise<T>)} value\n    */\n    update(value) {\n        // Group updates\n        if(this._updateTimeout) clearTimeout(this._updateTimeout);\n        this._updateTimeout = setTimeout(()=> {\n            _scheduleUpdate(()=> {\n                //Apply new value   \n                let newValue = (typeof value == \"function\" ? /** @type {Function} */(value)?.(this.value) : value);\n                let newHash = _hashAny(newValue);\n                \n                if(newHash !== this._storedHash) {\n                    this.value = newValue;\n                    this._storedHash = newHash;\n\n                    // Add this store to the work order\n                    for(let ds of this._downstreamStores) ds._auto_update();\n\n                    // Wait for next animation frame to return the value\n                    for(let [ref, sub] of this?._subscriptions || []) sub?.(this.value, ref);\n                }\n                \n                return this.value;\n            });\n        }, 0);\n    }\n\n    _auto_update() {\n        let newVal = this._updater?.(\n            Array.from(this._upstreamStores)?.map(S => S?.value) || [], \n            /** @type {T} */(this?.value)\n        );\n\n        this.update(newVal === undefined ? this.value : newVal);\n    }\n}\n\n/**\n * STORE STATIC METHODS\n */\n\n/**\n * @param {HTMLElement | string} scope \n */\nexport let _clearScope = (scope)=> {\n    _glob.MFLD.st.forEach(store=> {\n        if(store._scope == scope) _destroy(store); \n    });\n}\n\n/**\n * @param {Store<any>} store \n */\nexport let _destroy = (store)=> {\n    _glob.MFLD.st.delete(store?.name || \"\");\n    // @ts-ignore\n    store = undefined;\n}","import { _handlePushState, _parseFunction, ATTR_PREFIX } from \"./util.js\";\r\nimport { _scheduleUpdate } from \"./updates\";\r\nimport { _register } from \"./registrar.js\";\r\nimport { _store } from \"./store.js\";\r\nimport { $fn, $st } from \"./index.js\";\r\n\r\n/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\r\n\r\n/**\r\n * @param {HTMLElement} el \r\n * @param {string} trigger \r\n * @param {MfldOps} fetchOps\r\n * @param {string} href\r\n * @param {string} [method] \r\n * @param {Function} [func]\r\n */\r\nexport let _handleFetch = (el, trigger, fetchOps, href, method, func)=> {\r\n    /**\r\n     * @param {Event} [e]\r\n     */\r\n\r\n    let ev = e=> _fetchAndInsert(e, method, fetchOps, href, el, true, func);\r\n\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}\r\n\r\n/**\r\n * @param {Event | undefined} e\r\n * @param {string | undefined} method\r\n * @param {MfldOps} fetchOps\r\n * @param {string} href\r\n * @param {HTMLElement | { dataset: {[key: string]: string} }} el\r\n * @param {boolean} domUpdate\r\n * @param {Function} [func]\r\n * @returns \r\n */\r\nexport let _fetchAndInsert = async (e, method, fetchOps, href, el, domUpdate, func)=> {\r\n    e?.preventDefault();\r\n    e?.stopPropagation();\r\n\r\n    // Set from target element if relevant; fall back to \"get\"\r\n    if(!method) method = /** @type {any}*/(e?.target)?.method || \"get\";\r\n\r\n    //Make sure we're allowed to fetch\r\n    /** @type {import(\"./index.js\").ExternalOptions | undefined} */\r\n    let externalPermissions = fetchOps?.fetch?.externals?.find(allowed=> {\r\n        return (\r\n            (\r\n                allowed.domain == \"$origin\" \r\n                && (\r\n                    href.startsWith(location.origin) || !href.match(/^(https?):\\/\\//)\r\n                )\r\n            )\r\n            || href?.startsWith(allowed.domain)\r\n        );\r\n    });\r\n    if(!externalPermissions) externalPermissions = href.startsWith(location.origin)\r\n        ? { domain: \"$origin\", scripts: \"selected\", styles: \"selected\" }\r\n        : undefined;\r\n\r\n    // Parse input\r\n    let input = func?.({$el: el, $st, $fn});\r\n    let body = input == \"$form\" ? new FormData(/** @type {HTMLFormElement}*/(el)) : input;\r\n\r\n    //Fetch data\r\n    let data = await fetch(href, {\r\n        ...(fetchOps?.fetch?.request || {}),\r\n        headers: {\r\n            ...fetchOps?.fetch?.request?.headers,\r\n            \"MFLD\": \"true\",\r\n        },\r\n        method,\r\n        body: input == \"$form\" || typeof body == \"string\" ? body : JSON.stringify(body),\r\n    })\r\n    .catch(error=> {\r\n        fetchOps?.fetch?.err?.(error);\r\n    });\r\n\r\n    //Handle onCode callback\r\n    let code = data?.status;\r\n    if(code && fetchOps?.fetch?.onCode?.(code, data) == false) return;\r\n\r\n    //Return JSON or text in callback\r\n    let resp = await data?.[fetchOps?.fetch?.resType || \"text\"]();\r\n\r\n    // Handle resolutions\r\n    /** @type {import(\"./updates\").DomWorkOrder | undefined} */\r\n    for(let instruction of [\"append\", \"prepend\", \"inner\", \"outer\"]) {\r\n        let ds = el.dataset[`${ATTR_PREFIX}${instruction}`];\r\n        if(ds === undefined) continue;\r\n        let [selector, toReplace] = ds?.split(\"->\").map(s=> s.trim()) || [];\r\n\r\n        //Extract content and schedule a DOM update\r\n        let fullMarkup = (new DOMParser())?.parseFromString?.(resp, 'text/html');\r\n        let inEl = /** @type {HTMLElement} */ (fullMarkup.querySelector(selector || \"body\"));\r\n\r\n        if(fullMarkup) {\r\n            let scripts = [];\r\n            if(!externalPermissions?.styles || externalPermissions?.styles == \"none\") fullMarkup.querySelectorAll(\"style\").forEach(s=> s.parentNode?.removeChild(s));\r\n            if(externalPermissions?.styles == \"all\") fullMarkup.querySelectorAll(\"style\").forEach(s=> inEl.appendChild(s));\r\n            (externalPermissions?.scripts == \"all\" ? fullMarkup : inEl).querySelectorAll(\"script\")?.forEach(s=> {\r\n                if([\"all\", \"selected\"].includes(externalPermissions?.scripts || \"\")) scripts.push(s);\r\n                s.parentNode?.removeChild(s);\r\n            });\r\n\r\n            if(domUpdate) _scheduleUpdate({\r\n                in: inEl,\r\n                out: /** @type {HTMLElement} */ (toReplace ? document.querySelector(toReplace) : el),\r\n                relation: /** @type {\"append\" | \"prepend\" | \"inner\" | \"outer\"}*/(instruction),\r\n                ops: fetchOps,\r\n                done: (el)=> {\r\n                    _register(el);\r\n                    for(let s of scripts) {\r\n                        let n = document.createElement(\"script\");\r\n                        n.textContent = s.textContent;\r\n                        el.appendChild(n);\r\n                    }\r\n                },\r\n            });\r\n            else {\r\n                document.body.appendChild(inEl);\r\n                for(let s of scripts) {\r\n                    let n = document.createElement(\"script\");\r\n                    for(let attr of s.attributes) n.setAttribute(attr.name, attr.value);\r\n                    n.textContent = s.textContent;\r\n                    inEl.before(n);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let resolveTxt = el.dataset?.[`${ATTR_PREFIX}resolve`];\r\n    let resolveFunc = _parseFunction(resolveTxt || \"\")?.func;\r\n    resolveFunc?.({$el: el, $st, $fn, $body: resp});\r\n\r\n    if(domUpdate) _handlePushState(/** @type {HTMLElement}*/(el), e, href);\r\n}","import { $fn, $st } from \"./registrar\";\r\nimport { _store } from \"./store\";\r\nimport { _id } from \"./util\";\r\n\r\n/**\r\n * @param {HTMLElement} el\r\n * @returns {HTMLTemplateElement}\r\n */\r\nexport let _ensureTemplate = (el)=> {\r\n    let nodeName = \"TEMPLATE\";\r\n    if(el.tagName == nodeName) return /** @type {HTMLTemplateElement}*/(el);\r\n\r\n    let newEl = /** @type {HTMLTemplateElement}*/(document.createElement(nodeName));\r\n    newEl.content.appendChild(el.cloneNode(true));\r\n    el.replaceWith(newEl);\r\n\r\n    return newEl;\r\n}\r\n\r\n/**\r\n * @param {any} obj \r\n * @param {(value: any, index: any)=> void} cb \r\n */\r\nexport let _iterable = (obj, cb)=> {\r\n    if(obj instanceof Map) for(const [key, value] of obj.entries()) cb(key, value);\r\n    else {\r\n        try { \r\n            let arr = Array.from(obj || []);\r\n            if(arr?.length) arr.forEach(cb);\r\n            else for(let key in obj) cb(key, obj[key]);\r\n        }\r\n        catch(e) { console.error(`${obj} is not iterable`); }\r\n    }\r\n}\r\n\r\n// Returns the sibling that fails the condition\r\n/**\r\n * @param {Element | null} [sib] \r\n * @param {Function} [breakFn] \r\n * @param {Function | null} [cb] \r\n * @returns {Element | null | undefined}\r\n */\r\nexport function _iterateSiblings(sib, breakFn, cb, reverse = false) {\r\n    let dir = reverse ? \"previousElementSibling\" : \"nextElementSibling\";\r\n    return breakFn?.(sib) ? sib : _iterateSiblings((cb?.(sib) || sib)?.[dir], breakFn, cb, reverse);\r\n}\r\n\r\n/**\r\n * @param {string[]} upstream\r\n * @property {Function} [func]\r\n * @property {HTMLElement} [observeEl]\r\n * @returns \r\n */\r\nexport let _registerInternalStore = (upstream, func, $el)=> {\r\n    // Register new store (to prevent excess evaluations)\r\n    return _store(_id(), {\r\n        upstream,\r\n        updater: ()=> func?.({$el, $st, $fn}),\r\n        scope: $el,\r\n    });\r\n}","import { $fn, $st } from \"./registrar\";\r\nimport { _registerInternalStore } from \"./domutil\";\r\nimport { _handlePushState } from \"./util\";\r\n\r\nexport let _handleBind = (el, func, dependencyList)=> {\r\n    _registerInternalStore(\r\n        dependencyList, \r\n        ()=> {\r\n            return func?.({$el: el, $st, $fn});\r\n        },\r\n        el\r\n    );\r\n}\r\n\r\nexport let _handleSync = (el, trigger, func)=> {\r\n    let ev = (e)=> {\r\n        func?.({$el: el, $st, $fn});\r\n        _handlePushState(el, e);\r\n    }\r\n    if(trigger == \"$mount\") ev();\r\n    else el.addEventListener(trigger, ev);\r\n}","import { $fn, $st } from \"./registrar\";\nimport { _ensureTemplate, _iterable, _iterateSiblings, _registerInternalStore } from \"./domutil\";\nimport { _register } from \"./registrar\";\nimport { _applyTransition, _scheduleUpdate } from \"./updates\";\nimport { _parseFunction, ATTR_PREFIX } from \"./util\";\n\n/**\n * Handle conditional and loop elements\n * @param {HTMLElement} el \n * @param {string} mode \n * @param {string[]} as \n * @param {Function | undefined} func\n * @param {string[]} dependencyList\n * @param {import(\".\").MfldOps} ops \n */\nexport let _handleTemplates = (el, mode, as, func, dependencyList, ops)=> {\n    let startElement = document.createElement(\"template\"),\n        templ = /** @type {HTMLTemplateElement}*/(_ensureTemplate(/** @type {HTMLElement}*/(el.cloneNode(true)))),\n        templStore,\n        conditional = mode.match(/if|else/), \n        conditionalSub = mode.match(/(else|elseif)(\\s|$)/), // Whole word match to allow for exact checks later on (otherwise else is greedy)\n        newFunc = undefined,\n        prevConditions = [];\n\n    startElement.classList.add(`${mode}-start`);\n    templ.classList.add(`${mode}-end`);\n\n    el.before(startElement);\n    el.after(templ);\n    el.remove();\n\n    // Handle conditional elements\n    if(conditional) {\n        // Get upstream conditions\n        if(conditionalSub) {\n            let first = _iterateSiblings(startElement, (sib)=> sib?.classList?.contains(`${ATTR_PREFIX}if-end`), null, true);\n            _iterateSiblings(\n                first, \n                sib=> sib == templ, \n                sib=> { if(sib?.dataset?.[`${ATTR_PREFIX}cstore`]) prevConditions.push(sib?.dataset?.[`${ATTR_PREFIX}cstore`]) }\n            );\n        }\n\n        // Create function\n        newFunc = ({$el: el, $st, $fn})=> {\n            if(conditionalSub) {\n                for(let d of prevConditions) {\n                    if($st[d]) return false;\n                }\n            }\n            return conditionalSub?.[0] == \"else\" ? true : func?.({$el: el, $st, $fn}) == true;\n        }\n    }\n\n    templStore = _registerInternalStore([...dependencyList, ...prevConditions], conditional ? newFunc : func, templ);\n    templ.dataset[`${ATTR_PREFIX}cstore`] = templStore.name;\n\n    // Clear old elements\n    templStore.sub(val=> {\n        if(val === undefined) return;\n        _scheduleUpdate(()=> {\n            _iterateSiblings(\n                startElement?.nextElementSibling, \n                (sib)=> sib?.classList?.contains(`${mode}-end`),\n                (sib)=> _applyTransition(/** @type {HTMLElement}*/(sib), \"out\", ops, ()=> sib?.remove()), \n            );\n\n            if(conditional && !val) return;\n\n            _iterable(mode.match(/each/) ? val : [val], (val, key)=> {\n                // Get all logical bindings and replace values\n                let item = /** @type {HTMLTemplateElement}*/ (templ.cloneNode(true));\n                if(!conditional) {\n                    let html = templ?.innerHTML?.replace(\n                        /\\$:{([^}]*)}/g, \n                        (_, cap)=> _parseFunction(cap, as[0], as[1])?.func?.({$el: el, $st, $fn, [as[0]]: val, [as[1]]: key}) || \"\"\n                    ) || \"\";\n                    if(item?.innerHTML) item.innerHTML = html;\n                }\n\n                // Replace values\n                for(let element of item.content.children) {\n                    if(!element?.innerHTML) element.innerHTML = val;\n                    templ.before(element);\n                    _applyTransition(/** @type {HTMLElement}*/(element), \"in\", ops);\n                }\n            });\n        });\n    });\n}","import { _glob, _store } from \"./store.js\";\nimport { _scheduleUpdate } from \"./updates.js\";\nimport { _commaSepRx, _getOpOverrides, _id, _parseFunction, ATTR_PREFIX } from \"./util.js\";\nimport { _handleFetch } from \"./fetch.js\";\nimport { _handleBind, _handleSync } from \"./bindsync.js\";\nimport { _handleTemplates } from \"./templates.js\";\n/** @typedef {import(\"./index.js\").MfldOps} MfldOps */\n\n/** @type {Partial<MfldOps>} */\nlet _ops = {};\nlet _modes = [\"bind\", \"sync\", \"templ\", \"if\", \"elseif\", \"else\", \"each\", \"get\", \"head\", \"post\", \"put\", \"delete\", \"patch\", \"promote\"].map(m=> `${ATTR_PREFIX}${m}`);\n\n/**!\n * @param {Partial<MfldOps>} newops \n * @param {string} [profileName] \n */\nexport let _setOptions = (newops, profileName)=> {\n    if(profileName) _ops.profiles = { ..._ops.profiles, [profileName]: newops };\n    else _ops = { ..._ops, ...newops };\n}\n\n// Handle location state changes\n_glob.addEventListener(\"popstate\", ()=> {\n    location.reload();\n});\n\nexport let {$fn, $st} = _glob.MFLD;\n\n//Register subscriptions on the DOM (scopable in case an update needs run on a subset of the DOM)\n/**\n * @param {HTMLElement | null} [parent] \n */\nexport let _register = (parent)=> {\n    if(parent?.nodeType == Node.TEXT_NODE) return;\n\n    /** @type {NodeListOf<HTMLElement>} */\n    let els = (parent || document.body).querySelectorAll(\n        `[data-${_modes.join(`],[data-`)}],a,form`\n    );\n\n    for(let el of [/** @type {HTMLElement}*/(parent), ...els]) {\n        let _op_overrides = _getOpOverrides(structuredClone(_ops), el);\n        if(!el.id) el.id = _id();\n\n        //Check for <a> and <form> elements\n        if(el.dataset?.[`${ATTR_PREFIX}promote`] !== undefined) {\n            let [mode, href, input, trigger] = el.tagName == \"A\" ?\n                [\"get\", /** @type {HTMLAnchorElement}*/(el).href, undefined, \"click\"] : \n                [/** @type {HTMLFormElement}*/(el).method.toLowerCase(), /** @type {HTMLFormElement}*/(el).action, ()=> \"$form\", \"submit\"];\n\n            if(href) {\n                _handleFetch(el, trigger, _op_overrides, href, mode, input);\n                continue;\n            }\n        }\n\n        //Loop over all data attributes (modes)\n        for(let mode in el.dataset) {\n            if(!_modes.includes(mode)) continue;\n\n            //Loop over provided settings\n            for(let setting of el.dataset?.[mode]?.split(\";;\") || []) {\n                //Break out settings\n                let isFetch = mode.match(/get|head|post|put|delete|patch/) ? true : false,\n                    parts = setting?.split(/\\s*->\\s*/g),\n                    href = isFetch ? parts.pop() || \"\" : \"\",\n                    triggers = isFetch || mode.match(/sync/) ? parts.shift()?.match(/[^\\(\\)]{1,}/g)?.pop()?.split(_commaSepRx)?.map(s=> s.trim()) : [] || [],\n                    funcStr = parts?.[0] || \"\",\n                    dependencyList = Array.from(new Set([...funcStr?.matchAll(/\\$st\\.(\\w{1,})/g)].map(m=> m[1])));\n\n                let {func, as} = _parseFunction(funcStr);\n                \n                //Handle templs and loops\n                if(mode.match(/each|templ|if|else/)) _handleTemplates(el, mode, as || [], func, dependencyList, _op_overrides);\n                else {\n                    //Loop over triggers\n                    if(!triggers?.length) triggers = [\"\"]\n                    for(let trigger of triggers) {\n                        if(mode.match(/bind/)) _handleBind(el, func, dependencyList);\n                        else if(mode.match(/sync/)) _handleSync(el, trigger, func);\n                        else _handleFetch(el, trigger, _op_overrides, href, mode.replace(ATTR_PREFIX, \"\"), func);\n                    }\n                }\n            }; //End loop settings\n        }; //End loop dataset\n    };  //End loop elements\n}","import { _glob, _store } from \"./store.js\";\nimport { _addToNextTickQueue } from \"./updates.js\";\nimport { _register, _setOptions } from \"./registrar.js\";\nimport { _makeComponent, _component } from \"./component.js\";\n\n/**! @typedef {\"in-start\"|\"in-end\"|\"out-start\"|\"out-end\"} HookKey*/\n\n/**!\n * @typedef {object} ExternalOptions\n * @property {string} domain - The domain name these settings apply to\n * @property {\"all\" | \"selected\" | \"none\"} [scripts] - Allow scripts from this domain to execute\n * @property {\"all\" | \"selected\" | \"none\"} [styles] - Allow styles from this domain to apply\n */\n\n/**!\n * @typedef {object} FetchOptions\n * @property {RequestInit} [request] - Fetch request options\n * @property {\"json\"|\"text\"} [resType] - Response type (default: \"text\")\n * @property {(err: Error)=> void} [err] - Error callback - run on fetch error\n * @property {(code: number, data: void | Response)=> boolean | void} [onCode] - Callback function - run on fetch response code; return `false` to prevent further processing\n * @property {ExternalOptions[]} [externals] - External domain fetch settings\n */\n\n/**!\n * @typedef {object} TransitionOptions\n * @property {string} [class] - CSS class applied to transitions (default: `mfTrans`)\n * @property {[number, number] | number} [dur] - Transition duration: [in, out] or single value (in ms); default: 300\n * @property {number} [swap] - Swap delay (in ms) - applied between one element's outro start and the replacement's intro start; default: 0\n * @property {boolean} [smart] - Enable smart transitions (default: true)\n * @property {{ [key in HookKey]?: (el: HTMLElement)=> void }} [hooks] - Transition hooks\n */\n\n/**!\n * Manifold options for `fetch`, `trans`, and `profiles`.\n * @typedef {Object} MfldOps\n * @property {{ [ key: string ]: Partial<MfldOps> }} [profiles] - Fetch profiles assignable to elements\n * @property {FetchOptions} [fetch] - Fetch options - see https://google.com\n * @property {TransitionOptions} [trans] - Transition settings - see https://google.com\n */\n\n/**!\n * @template T\n * @callback UpdaterFunction\n * @param {Array<any>} upstreamValues\n * @param {T} value\n * @returns {T | Promise<T>}\n */\n\n/**!\n * @template T\n * @callback ValueDeterminer\n * @param {T} [currentValue]\n * @returns {T | Promise<T> | undefined}\n */\n\n/**!\n * @template T\n * @callback UpdateFunction\n * @param {T | ValueDeterminer<T>} value\n * @returns {T | Promise<T> | undefined}\n */\n\n/**!\n * @template T\n * @callback SubDeterminer\n * @param {T} value\n * @returns {void}\n */\n\n/**!\n * @template T\n * @callback SubFunction\n * @param {SubDeterminer<T>} value The store's current value\n * @returns void\n */\n\n/**!\n * @template T\n * @typedef {Object} StoreOptions\n * @property {T} [value]\n * @property {Array<string>} [upstream]\n * @property {UpdaterFunction<T>} [updater]\n * @property {HTMLElement | SVGScriptElement | \"global\"} [scope]\n */\n\n/**!\n * @template T\n * @typedef Store\n * @prop {T} value - The store's current value (read only)\n * @prop {UpdateFunction<T>} update - Update the store's current value\n * @prop {SubFunction<T>} sub - Add a subscription function to the store\n */\n\n/**!\n * @typedef {Function} MfldFunc\n * @param {any} val\n * @param {HTMLElement} [el]\n */\n\n/**!\n * The global Manifold interface.\n */\nexport let Mfld = {\nstore: \n/**!\n* - Create or overwrite a _typed_ global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<T\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @template T\n* @param {string} store_name\n* @param {StoreOptions<T> | T} store_ops\n* @return {Store<T>}\n*/ (store_name, store_ops)=> {\n    if(!store_ops?.hasOwnProperty(\"value\") && !store_ops?.hasOwnProperty(\"updater\")) {\n        store_ops = /** @type {StoreOptions<T>}*/({ value: /** @type {T}*/store_ops });\n    }\n    return /**@type {Store<T>}*/(_store(store_name, /**@type {StoreOptions<T>}*/store_ops))\n},\nustore: \n/**!\n* - Create or overwrite an untyped global Manifold store by passing `store_ops` (`MfldOps`) -> *returns `Store\\<any\\>`* \n* - Retrieve an untyped reference to the store specified by name by omitting `store_ops` -> *returns `Store\\<any\\>`*\n* @param {string} store_name\n* @param {StoreOptions<any> | any} store_ops\n* @return {Store<any>}\n*/ (store_name, store_ops)=> /**@type {Store<any>}*/(_store(store_name, store_ops)),\nfuncs: \n/**!\n * - Add functions to the Manifold function registry in key-value pairs.\n * - Functions must be registered in order to be accessible to HTML elements via `mfBind`, `mfSync`, and `mfResolve`. \n * - It may still be beneficial to keep a reference to the original function if you need to preserve type information.\n * @param {{ [key: string]: MfldFunc }} funcs\n */ funcs=> {\n    for(let key in funcs) {\n    _glob.MFLD.$fn[key] = funcs[key];\n }},\nconfig:\n/**!\n * - Set Manifold configuration options, including `trans` (DOM transition settings), `fetch` (fetch options), and `profiles` (configuration option overrides that can be set on elements ad-hoc via `mfOverrides`).\n * - Providing the optional `profileName` parameter allows you to save the configuration as a named profile. Otherwise, the profile is saved as the default configuration.\n * @param {MfldOps} new_ops\n * @param {string} [profile_name]\n */ (new_ops, profile_name)=> _setOptions(new_ops, profile_name),\n onTick:\n /**!\n  * - Wait for the next Manifold data update cycle to complete before executing the callback function.\n  * @param {()=> void} cb\n  */ (cb)=> _addToNextTickQueue(cb),\nregister:\n/**!\n * - Register Manifold subscriptions on the DOM. *Optional:* Pass an `HTMLElement` or selector string to scope the registration to a specific element.\n * @param {HTMLElement | string | null} [parent]\n */ (parent)=> {\n    if(typeof parent == \"string\") parent = /** @type {HTMLElement | null}*/(document.querySelector(parent));\n        _register(parent)\n    },\n};\n\nexport let $st = _glob.MFLD.$st;\nexport let $fn = _glob.MFLD.$fn;\nexport let makeComponent = _makeComponent;\nexport let component = _component;\n\n","import { _fetchAndInsert } from \"./fetch\";\r\nimport { _register } from \"./registrar\";\r\nimport { _glob } from \"./store\";\r\nimport { ATTR_PREFIX } from \"./util\";\r\n\r\n/**\r\n * @param {string} name \r\n * @param {{ \r\n *  href?: string,\r\n *  shadow?: \"open\" | \"closed\",\r\n *  templ?: HTMLTemplateElement,\r\n *  selector?: string,\r\n *  constructor?: Function, \r\n *  connected?: Function, \r\n *  observedAttributes?: string[],\r\n *  disconnected?: Function, \r\n *  adopted?: Function,\r\n *  attributeChanged?: Function \r\n * }} [ops]\r\n */\r\nexport let _makeComponent = (name, ops)=> {\r\n    _glob.MFLD.comp[name] = class extends HTMLElement {\r\n        /** @type {HTMLTemplateElement | null} */ template;\r\n        constructor() {\r\n            super();\r\n            ops?.constructor?.bind(this)?.();\r\n            this.connected = ops?.connected?.bind(this);\r\n            this.disconnected = ops?.disconnected?.bind(this);\r\n            this.attributeChanged = ops?.attributeChanged?.bind(this);\r\n            this.template = ops?.templ || /** @type {HTMLTemplateElement}*/(document.getElementById(ops?.selector || name));\r\n            if(this.template?.nodeName != \"TEMPLATE\") this.template = null;\r\n        }\r\n        connectedCallback() {\r\n            const   shadow = this.attachShadow({ mode: ops?.shadow || \"closed\" }),\r\n                    template = this.template?.content.cloneNode(true);\r\n            if(template) {\r\n                shadow.append(template);\r\n                for(let child of shadow.children) {\r\n                    if(child.nodeName == \"SLOT\") {\r\n                        for(let slotChild of /** @type {HTMLSlotElement}*/(child).assignedNodes()) {\r\n                            _register(/** @type {HTMLElement}*/(slotChild));\r\n                        }\r\n                    }\r\n                    else if(child.nodeName != \"TEMPLATE\") { \r\n                        _register(/** @type {HTMLElement}*/(child));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        attributeChangedCallback(attr, oldVal, newVal) {\r\n            this.attributeChanged?.(attr, oldVal, newVal);\r\n        }\r\n        disconnectedCallback() {\r\n            this.disconnected?.();\r\n        }\r\n    }\r\n\r\n    if(_glob.MFLD.comp[name]) customElements.define(name, _glob.MFLD.comp[name]);\r\n}\r\n\r\nexport let _component = async (src)=> {\r\n    await _fetchAndInsert(\r\n        undefined, \r\n        \"get\", \r\n        { \r\n            fetch: { \r\n                externals: [{ \r\n                    domain: \"$origin\", scripts: \"all\", styles: \"all\" \r\n                }]\r\n            }\r\n        },\r\n        src,\r\n        { dataset: { [`${ATTR_PREFIX}append`]: \"template -> body\" }},\r\n        false\r\n    )\r\n}","import { Mfld, $fn, $st, makeComponent, component } from \"./index\";\r\nif(!globalThis.Mfld) globalThis.Mfld = Mfld;\r\nif(!globalThis.$st) globalThis.$st = $st;\r\nif(!globalThis.$fn) globalThis.$fn = $fn;\r\nif(!globalThis.makeComponent) globalThis.makeComponent = makeComponent;\r\nif(!globalThis.component) globalThis.component = component;\r\n"],"names":["ATTR_PREFIX","_commaSepRx","_id","Date","now","Math","floor","random","_getOpOverrides","ops","el","overrides","profiles","dataset","override","res","set","key","startsWith","prop","split","val","match","JSON","parse","parseInt","Array","isArray","map","v","e","console","error","_parseFunction","condition","valArg","keyArg","fnStr","asStr","fnText","as","s","trim","func","Function","_handlePushState","ev","href","preventDefault","pushState","push","undefined","history","workArray","cancelAnimationFrame","_nextTickQueue","_scheduleUpdate","update","requestAnimationFrame","_runUpdates","_addSpacer","inEl","wrapper","wrapperHeight","trans","smart","paddingTop","paddingBottom","Element","getComputedStyle","spacer","document","createElement","style","height","abs","clientHeight","after","_adjustSizing","dur","animate","order","out","_getDimensionsAfterUpdate","relation","in","_applyTransition","prepend","includes","container","cloneNode","border","replaceChildren","replaceWith","appendChild","done","forEach","fn","dir","refElement","nodeType","Node","TEXT_NODE","textContent","transClass","class","classList","add","hooks","dimensions","_getDimensions","position","width","w","left","top","margin","transitionDuration","setTimeout","remove","swap","rect","getBoundingClientRect","clientWidth","paddingLeft","paddingRight","_glob","scrollX","scrollY","_store","name","found_store","MFLD","st","get","_modify","Store","Map","$st","Proxy","store","property","value","propParts","parseFloat","S","ret","part","slice","$fn","comp","_hashAny","input","Set","from","entries","hash","char","TextEncoder","encode","toString","_updater","_subscriptions","_storedHash","_upstreamStores","_downstreamStores","_scope","_updateTimeout","constructor","this","scope","currentScript","upstream","updater","_auto_update","sub","ref","immediate","clearTimeout","newValue","newHash","ds","newVal","_handleFetch","trigger","fetchOps","method","_fetchAndInsert","addEventListener","async","domUpdate","stopPropagation","target","externalPermissions","fetch","externals","find","allowed","domain","location","origin","scripts","styles","$el","body","FormData","data","request","headers","stringify","catch","err","code","status","onCode","resp","resType","instruction","selector","toReplace","fullMarkup","DOMParser","parseFromString","querySelector","querySelectorAll","parentNode","removeChild","_register","n","attr","attributes","setAttribute","before","resolveTxt","resolveFunc","$body","_iterateSiblings","sib","breakFn","cb","reverse","_registerInternalStore","_handleBind","dependencyList","_handleSync","_handleTemplates","mode","templStore","newFunc","startElement","templ","nodeName","tagName","newEl","content","conditional","conditionalSub","prevConditions","first","contains","d","nextElementSibling","obj","arr","length","_iterable","item","html","innerHTML","replace","_","cap","element","children","_ops","_modes","m","reload","parent","els","join","_op_overrides","structuredClone","id","toLowerCase","action","setting","isFetch","parts","pop","triggers","shift","funcStr","matchAll","Mfld","store_name","store_ops","hasOwnProperty","ustore","funcs","config","new_ops","profile_name","_setOptions","newops","profileName","onTick","register","makeComponent","HTMLElement","template","super","bind","connected","disconnected","attributeChanged","getElementById","connectedCallback","shadow","attachShadow","append","child","slotChild","assignedNodes","attributeChangedCallback","oldVal","disconnectedCallback","customElements","define","component","src","globalThis"],"mappings":"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"}